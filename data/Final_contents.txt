掌握了Python的数据类型、语句和函数，基本上就可以编写出很多有用的程序了。
比如构造一个1, 3, 5, 7, ..., 99的列表，可以通过循环实现：
取list的前一半的元素，也可以通过循环实现。
但是在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。
基于这一思想，我们来介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。
Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。
Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：
以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。
缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的惯例，应该始终坚持使用4个空格的缩进。
缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。
缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。
最后，请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。
Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进；
在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。
当我们用if ... elif ... elif ... else ...判断时，会写很长一串代码，可读性较差。
如果要针对某个变量匹配若干种情况，可以使用match语句。
例如，某个学生的成绩只能是A、B、C，用if语句编写如下：
如果用match语句改写，则改写如下：
使用match语句时，我们依次用case xxx匹配，并且可以在最后（且仅能在最后）加一个case _表示“任意值”，代码较if ... elif ... else ...更易读。
match语句除了可以匹配简单的单个值外，还可以匹配多个值、匹配一定范围，并且把匹配后的值绑定到变量：
在上面这个示例中，第一个case x if x < 10表示当age < 10成立时匹配，且赋值给变量x，第二个case 10仅匹配单个值，第三个case 11|12|...|18能匹配多个值，用|分隔。
可见，match语句的case匹配非常灵活。
match语句还可以匹配列表，功能非常强大。
我们假设用户输入了一个命令，用args = ['gcc', 'hello.c']存储，下面的代码演示了如何用match匹配来解析这个列表：
第一个case ['gcc']表示列表仅有'gcc'一个字符串，没有指定文件名，报错；
第二个case ['gcc', file1, *files]表示列表第一个字符串是'gcc'，第二个字符串绑定到变量file1，后面的任意个字符串绑定到*files（符号*的作用将在函数的参数中讲解），它实际上表示至少指定一个文件；
第三个case ['clean']表示列表仅有'clean'一个字符串；
最后一个case _表示其他所有情况。
可见，match语句的匹配规则非常灵活，可以写出非常简洁的代码。
do_match.py
在Python的交互式命令行写程序，好处是一下就能得到结果，坏处是没法保存，下次还想运行的时候，还得再敲一遍。
所以，实际开发的时候，我们总是使用一个文本编辑器来写代码，写完了，保存为一个文件，这样，程序就可以反复运行了。
现在，我们就把上次的'hello, world'程序用文本编辑器写出来，保存下来。
那么问题来了：文本编辑器到底哪家强？
我们推荐微软出品的Visual Studio Code，它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨平台！Windows、Mac和Linux通用。
请注意，不要用Word和Windows自带的记事本。Word保存的不是纯文本文件，而记事本会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果会导致程序运行出现莫名其妙的错误。
安装好文本编辑器后，输入以下代码：
注意print前面不要有任何空格。然后，选择一个目录，例如C:\work，把文件保存为hello.py，就可以打开命令行窗口，把当前目录切换到hello.py所在目录，就可以运行这个程序了：
也可以保存为别的名字，比如first.py，但是必须要以.py结尾，其他的都不行。此外，文件名只能是英文字母、数字和下划线的组合。
如果当前目录下没有hello.py这个文件，运行python hello.py就会报错：
报错的意思就是，无法打开hello.py这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。如果hello.py存放在另外一个目录下，要首先用cd命令切换当前目录。
有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：
然后，通过命令给hello.py以执行权限：
就可以直接运行hello.py了，比如在Mac下运行：
hello.py
用文本编辑器写Python程序，然后保存为后缀为.py的文件，就可以用Python直接运行这个程序了。
Python的交互模式和直接运行.py文件有什么区别呢？
直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。
直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。
用Python开发程序，完全可以一边在文本编辑器里写代码，一边开一个交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27'的超大显示器！
用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出'hello, world'，用代码实现如下：
print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：
print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：
print()也可以打印整数，或者计算结果：
因此，我们可以把计算100 + 200的结果打印得更漂亮一点：
注意，对于100 + 200，Python解释器自动计算出结果300，但是，'100 + 200 ='是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。
现在，你已经可以用print()输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：
当你输入name = input()并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。
输入完成后，不会有任何提示，Python交互式命令行又回到>>>状态了。那我们刚才输入的内容到哪去了？答案是存放到name变量里了。可以直接输入name查看变量内容：
**什么是变量？**请回忆初中数学所学的代数基础知识：
设正方形的边长为a，则正方形的面积为a x a。把边长a看做一个变量，我们就可以根据a的值计算正方形的面积，比如：
若a=2，则面积为a x a = 2 x 2 = 4；
若a=3.5，则面积为a x a = 3.5 x 3.5 = 12.25。
在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，name作为一个变量就是一个字符串。
要打印出name变量的内容，除了直接写name然后按回车外，还可以用print()函数：
有了输入和输出，我们就可以把上次打印'hello, world'的程序改成有点意义的程序了：
运行上面的程序，第一行代码会让用户输入任意字符作为自己的名字，然后存入name变量中；第二行代码会根据用户的名字向用户说hello，比如输入Michael：
但是程序运行的时候，没有任何提示信息告诉用户：“嘿，赶紧输入你的名字”，这样显得很不友好。幸好，input()可以让你显示一个字符串来提示用户，于是我们把代码改成：
再次运行这个程序，你会发现，程序一运行，会首先打印出please enter your name: ，这样，用户就可以根据提示，输入名字后，得到hello, xxx的输出：
每次运行该程序，根据用户输入的不同，输出结果也会不同。
在命令行下，输入和输出就是这么简单。
任何计算机程序都是为了执行一个特定的任务，有了输入，用户才能告诉计算机程序所需的信息，有了输出，程序运行后才能告诉用户任务的结果。
输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。
input()和print()是在命令行下面最基本的输入和输出，但是，用户也可以通过其他更高级的图形界面完成输入和输出，比如，在网页上的一个文本框输入自己的名字，点击“确定”后在网页上看到输出信息。
请利用print()输出1024 * 768 = xxx：
do_input.py
要计算1+2+3，我们可以直接写表达式：
要计算1+2+3+...+10，勉强也能写出来。
但是，要计算1+2+3+...+10000，直接写表达式就不可能了。
为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。
Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：
执行这段代码，会依次打印names的每一个元素：
所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。
再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：
如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：
range(101)就可以生成0-100的整数序列，计算如下：
请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。
第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：
在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。
请利用循环依次对list中的每个名字打印出Hello, xxx!：
在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字：
上面的代码可以打印出1~100。
如果要提前结束循环，可以用break语句：
执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。
可见break的作用是提前结束循环。
在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。
上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环：
执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。
可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。
do_for.py
do_while.py
循环是让计算机做重复任务的有效的方法。
break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。
要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。
有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。
请试写一个死循环程序。
我们知道圆的面积计算公式为：
当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：
当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。
有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。
基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。
抽象是数学中非常常见的概念。举个例子：
计算数列的和，比如：1 + 2 + 3 + ... + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + ... + 100记作：
这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。
而且，这种抽象记法是可扩展的，比如：
还原成加法运算就变成了：
(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)
可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。
写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。
计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。
比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：
根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。
也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：
注意不要少写了冒号:。
当然上面的判断是很粗略的，完全可以用elif做更细致的判断：
elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：
if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager：
if判断条件还可以简写，比如写：
只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。
最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：
输入1982，结果报错：
这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：
再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：
原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。
如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。
小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：
用if-elif判断并打印结果：
do_if.py
条件判断可以让计算机自己做选择，Python的if...elif...else很灵活。
条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的elif和else都不再执行。
Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。
举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：
给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。
如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：
为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。
第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。
dict就是第二种实现方式，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。
你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。
把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
如果key不存在，dict就会报错：
要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：
二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：
注意：返回None的时候Python的交互环境不显示结果。
要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。
和list比较，dict有以下几个特点：
而list相反：
所以，dict是用空间来换取时间的一种方法。
dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。
这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。
要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：
set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
要创建一个set，用{x,y,z,...}列出每个元素：
或者提供一个list作为输入集合：
注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。
重复元素在set中自动被过滤：
通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：
通过remove(key)方法可以删除元素：
set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：
set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。
上面我们讲了，str是不变对象，而list是可变对象。
对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：
而对于不可变对象，比如str，对str进行操作呢：
虽然字符串有个replace()方法，也确实变出了'Abc'，但变量a最后仍是'abc'，应该怎么理解呢？
我们先把代码改成下面这样：
要始终牢记的是，a是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'：
当我们调用a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了：
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
the_dict.py
the_set.py
使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。
tuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。
Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。
比如，列出班里所有同学的名字，就可以用一个list表示：
变量classmates就是一个list。用len()函数可以获得list元素的个数：
用索引来访问list中每一个位置的元素，记得索引是从0开始的：
当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。
如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：
以此类推，可以获取倒数第2个、倒数第3个：
当然，倒数第4个就越界了。
list是一个可变的有序表，所以，可以往list中追加元素到末尾：
也可以把元素插入到指定的位置，比如索引号为1的位置：
要删除list末尾的元素，用pop()方法：
要删除指定位置的元素，用pop(i)方法，其中i是索引位置：
要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
list里面的元素的数据类型也可以不同，比如：
list元素也可以是另一个list，比如：
要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：
要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。
如果一个list中一个元素也没有，就是一个空的list，它的长度为0：
另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：
现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。
不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。
tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：
如果要定义一个空的tuple，可以写成()：
但是，要定义一个只有1个元素的tuple，如果你这么定义：
定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。
所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：
Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。
最后来看一个“可变的”tuple：
这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？
别急，我们先看看定义的时候tuple包含的3个元素：
当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：
表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！
理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。
请用索引取出下面list的指定元素：
请问以下变量哪些是tuple类型：
the_list.py
the_tuple.py
list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。
在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。
我们以自定义一个求绝对值的my_abs函数为例：
请自行测试并调用my_abs看看返回结果是否正确。
请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。
如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。
在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次回车重新回到>>>提示符下：
如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：
import的用法在后续模块一节中会详细介绍。
如果想定义一个什么事也不做的空函数，可以用pass语句：
pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。
pass还可以用在其他语句里，比如：
缺少了pass，代码运行就会有语法错误。
调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：
但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：
当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。
让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：
添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：
错误和异常处理将在后续讲到。
函数可以返回多个值吗？答案是肯定的。
比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：
import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。
然后，我们就可以同时获得返回值：
但其实这只是一种假象，Python函数返回的仍然是单一值：
原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。
请定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程 ax2+bx+c=0ax^2+bx+c=0ax2+bx+c=0 的两个解。
提示：
一元二次方程的求根公式为：
计算平方根可以调用math.sqrt()函数：
def_func.py
定义函数时，需要确定函数名和参数个数；
如果有必要，可以先对参数的数据类型做检查；
函数体内部可以用return随时返回函数结果；
函数执行完毕也没有return语句时，自动return None。
函数可以同时返回多个值，但其实就是一个tuple。
在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。
举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：
所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。
于是，fact(n)用递归的方式写出来就是：
上面就是一个递归函数。可以试试：
如果我们计算fact(5)，可以根据函数定义看到计算过程如下：
递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：
解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：
可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。
fact(5)对应的fact_iter(5, 1)的调用如下：
尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。
汉诺塔的移动可以用递归函数非常简单地实现。
请编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如：
recur.py
使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。
Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。
Python内置了很多有用的函数，我们可以直接调用。
要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档，也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。
调用abs函数：
调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：
如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：
而max函数max()可以接收任意多个参数，并返回最大的那个：
Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：
函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：
请利用Python内置的hex()函数把一个整数转换成十六进制表示的字符串：
call_func.py
调用Python的函数，需要根据函数定义，传入正确的参数。如果函数调用出错，一定要学会看错误信息，所以英文很重要！
计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：
Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。
计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。
对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。十六进制数也可以写成0xa1b2_c3d4。
浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。
整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。
字符串是以单引号'或双引号"括起来的任意文本，比如'abc'，"xyz"等等。请注意，''或""本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用""括起来，比如"I'm OK"包含的字符是I，'，m，空格，O，K这6个字符。
如果字符串内部既包含'又包含"怎么办？可以用转义字符\来标识，比如：
表示的字符串内容是：
转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：
如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：
如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：
上面是在交互式命令行内输入，注意在输入多行内容时，提示符由>>>变为...，提示你可以接着上一行输入，注意...是提示符，不是代码的一部分：
当输入完结束符```和括号)后，执行该语句并打印结果。
如果写成程序并存为.py文件，就是：
多行字符串'''...'''还可以在前面加上r使用，请自行测试：
布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：
布尔值可以用and、or和not运算。
and运算是与运算，只有所有都为True，and运算结果才是True：
or运算是或运算，只要其中有一个为True，or运算结果就是True：
not运算是非运算，它是一个单目运算符，把True变成False，False变成True：
布尔值经常用在条件判断中，比如：
空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。
变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。
变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：
变量a是一个整数。
变量t_007是一个字符串。
变量Answer是一个布尔值True。
在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：
这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：
和静态语言相比，动态语言更灵活，就是这个原因。
请不要把赋值语句的等号等同于数学的等号。比如下面的代码：
如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。
最后，理解变量在计算机内存中的表示也非常重要。当我们写：
时，Python解释器干了两件事情：
也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：
最后一行打印出变量b的内容到底是'ABC'呢还是'XYZ'？如果从数学意义上理解，就会错误地得出b和a相同，也应该是'XYZ'，但实际上b的值是'ABC'，让我们一行一行地执行代码，就可以看到到底发生了什么事：
执行a = 'ABC'，解释器创建了字符串'ABC'和变量a，并把a指向'ABC'：
执行b = a，解释器创建了变量b，并把b指向a指向的字符串'ABC'：
执行a = 'XYZ'，解释器创建了字符串'XYZ'，并把a的指向改为'XYZ'，但b并没有更改：
所以，最后打印变量b的结果自然是'ABC'了。
所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：
但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。
最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：
/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：
还有一种除法是//，称为地板除，两个整数的除法仍然是整数：
你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。
因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：
无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。
请打印出以下变量的值：
Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。
对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。
注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。
Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。
我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。
因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。
由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。
但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。
你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。
因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。
Unicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。
现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。
字母A用ASCII编码是十进制的65，二进制的01000001；
字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；
汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。
你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。
新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。
所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：
从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。
搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：
在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。
用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：
浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：
所以你看到很多网页的源码上会有类似<meta charset="UTF-8" />的信息，表示该网页正是用的UTF-8编码。
搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。
在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：
对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：
如果知道字符的整数编码，还可以用十六进制这么写str：
两种写法完全是等价的。
由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。
Python对bytes类型的数据用带b前缀的单引号或双引号表示：
要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。
以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：
纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。
在bytes中，无法显示为ASCII字符的字节，用\x##显示。
反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：
如果bytes中包含无法解码的字节，decode()方法会报错：
如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：
要计算str包含多少个字符，可以用len()函数：
len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：
可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。
在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。
由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；
第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。
申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8编码。
如果.py文件本身使用UTF-8编码，并且也申明了# -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文：
最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似'亲爱的xxx你好！你xx月的话费是xx，余额是xx'之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。
在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：
你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。
常见的占位符有：
其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：
如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：
有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：
另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：
最后一种格式化字符串的方法是使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换：
上述代码中，{r}被变量r的值替换，{s:.2f}被变量s的值替换，并且:后面的.2f指定了格式化参数（即保留两位小数），因此，{s:.2f}的替换结果是19.62。
小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出'xx.x%'，只保留小数点后1位：
the_string.py
Python 3的字符串使用Unicode，直接支持多语言。
当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：
但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。
格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。
定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。
Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。
我们先写一个计算x2的函数：
对于power(x)函数，参数x就是一个位置参数。
当我们调用power函数时，必须传入有且仅有的一个参数x：
现在，如果我们要计算x3怎么办？可以再定义一个power3函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。
你也许想到了，可以把power(x)修改为power(x, n)，用来计算xn，说干就干：
对于这个修改后的power(x, n)函数，可以计算任意n次方：
修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。
新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：
Python的错误信息很明确：调用函数power()缺少了一个位置参数n。
这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：
这样，当我们调用power(5)时，相当于调用power(5, 2)：
而对于n > 2的其他情况，就必须明确地传入n，比如power(5, 3)。
从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：
一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；
二是如何设置默认参数。
当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。
使用默认参数有什么好处？最大的好处是能降低调用函数的难度。
举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：
这样，调用enroll()函数只需要传入两个参数：
如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。
我们可以把年龄和城市设为默认参数：
这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：
只有与默认参数不符的学生才需要提供额外的信息：
可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。
有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。
也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。
默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：
先定义一个函数，传入一个list，添加一个END再返回：
当你正常调用时，结果似乎不错：
当你使用默认参数调用时，一开始结果也是对的：
但是，再次调用add_end()时，结果就不对了：
很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。
原因解释如下：
Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。
特别注意
定义默认参数要牢记一点：默认参数必须指向不变对象！
要修改上面的例子，我们可以用None这个不变对象来实现：
现在，无论调用多少次，都不会有问题：
为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。
在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。
我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。
要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：
但是调用的时候，需要先组装出一个list或tuple：
如果利用可变参数，调用函数的方式可以简化成这样：
所以，我们把函数的参数改为可变参数：
定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：
如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：
这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：
*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。
可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：
函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：
也可以传入任意个数的关键字参数：
关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。
和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：
当然，上面复杂的调用可以用简化的写法：
**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。
对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。
仍以person()函数为例，我们希望检查是否有city和job参数：
但是调用者仍可以传入不受限制的关键字参数：
如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。
调用方式如下：
如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：
命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：
由于调用时缺少参数名city和job，Python解释器把前两个参数视为位置参数，后两个参数传给*args，但缺少命名关键字参数导致报错。
命名关键字参数可以有缺省值，从而简化调用：
由于命名关键字参数city具有默认值，调用时，可不传入city参数：
使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：
在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
比如定义一个函数，包含上述若干种参数：
在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。
最神奇的是通过一个tuple和dict，你也可以调用上述函数：
所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。
提示
虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。
以下函数允许计算两个数的乘积，请稍加改造，变成可接收一个或多个数并计算乘积：
var_args.py
kw_args.py
Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。
默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！
要注意定义可变参数和关键字参数的语法：
*args是可变参数，args接收的是一个tuple；
**kw是关键字参数，kw接收的是一个dict。
以及调用函数时如何传入可变参数和关键字参数的语法：
可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。
命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。
通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。
所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。
要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：
创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。
我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？
如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：
我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。
当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：
所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。
generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。
比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：
注意，赋值语句：
相当于：
但不必显式写出临时变量t就可以赋值。
上面的函数可以输出斐波那契数列的前N个数：
仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。
也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator函数，只需要把print(b)改为yield b就可以了：
这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator函数，调用一个generator函数将返回一个generator：
这里，最难理解的就是generator函数和普通函数的执行流程不一样。普通函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
举个简单的例子，定义一个generator函数，依次返回数字1，3，5：
调用该generator函数时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：
可以看到，odd不是普通函数，而是generator函数，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。
有的童鞋会发现这样调用next()每次都返回1：
原因在于odd()会创建一个新的generator对象，上述代码实际上创建了3个完全独立的generator，对3个generator分别调用next()当然每个都会返回第一个值。
正确的写法是创建一个generator对象，然后不断对这一个generator对象调用next()：
回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。
同样的，把函数改成generator函数后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：
但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：
关于如何捕获错误，后面的错误处理还会详细讲解。
杨辉三角定义如下：
把每一行看做一个list，试写一个generator，不断输出下一行的list：
do_generator.py
generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。
要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。
请注意区分普通函数和generator函数，普通函数调用直接返回结果：
generator函数的调用实际返回一个generator对象：
由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。
函数对象有一个__name__属性（注意：是前后各两个下划线），可以拿到函数的名字：
现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。
本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：
观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：
调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：
把@log放到now()函数的定义处，相当于执行了语句：
由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。
wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。
如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：
这个3层嵌套的decorator用法如下：
执行结果如下：
和两层嵌套的decorator相比，3层嵌套的效果是这样的：
我们来剖析上面的语句，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。
以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'：
因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。
不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：
或者针对带参数的decorator：
import functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。
请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：
请编写一个decorator，能在函数调用的前后打印出'begin call'和'end call'的日志。
再思考一下能否写出一个@log的decorator，使它既支持：
又支持：
decorator.py
在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。
decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。
在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。
使用模块有什么好处？
最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。
使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点这里查看Python的所有内置函数。
你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。
举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。
现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：
引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。
请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。
类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：
文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。
特别注意
自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。
mycompany.web也是一个模块，请指出该模块对应的.py文件。
模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。
创建自己的模块时，要注意：
列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。
举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：
但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：
但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：
写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。
for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：
还可以使用两层循环，可以生成全排列：
三层和三层以上的循环就很少用到了。
运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：
for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：
因此，列表生成式也可以使用两个变量来生成list：
最后把一个list中所有的字符串变成小写：
使用列表生成式的时候，有些童鞋经常搞不清楚if...else的用法。
例如，以下代码正常输出偶数：
但是，我们不能在最后的if加上else：
这是因为跟在for后面的if是一个筛选条件，不能带else，否则如何筛选？
另一些童鞋发现把if写在for前面必须加else，否则报错：
这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：
上述for前面的表达式x if x % 2 == 0 else -x才能根据x计算出确定的结果。
可见，在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else。
如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错：
使用内建的isinstance函数可以判断一个变量是不是字符串：
请修改列表生成式，通过添加if语句保证列表生成式能正确地执行：
do_list_compr.py
运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。
高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：
但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：
当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：
调用函数f时，才真正计算求和的结果：
在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：
f1()和f2()的调用结果互不影响。
注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：
在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。
你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：
全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。
注意
返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
再看看结果：
缺点是代码较长，可利用lambda函数缩短代码。
使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常：
但是，如果对外层变量赋值，由于Python解释器会把x当作函数fn()的局部变量，它会报错：
原因是x作为局部变量并没有初始化，直接计算x+1是不行的。但我们其实是想引用inc()函数内部的x，所以需要在fn()函数内部加一个nonlocal x的声明。加上这个声明后，解释器把fn()的x看作外层函数的局部变量，它已经被初始化了，可以正确计算x+1。
提示
使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。
利用闭包返回一个计数器函数，每次调用它返回递增整数：
return_func.py
一个函数可以返回一个计算结果，也可以返回一个函数。
返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。
Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。
在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：
int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：
但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：
假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：
这样，我们转换二进制就非常方便了：
functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：
所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：
最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：
实际上固定了int()函数的关键字参数base，也就是：
相当于：
当传入：
实际上会把10作为*args的一部分自动加到左边，也就是：
相当于：
结果为10。
do_partial.py
当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。
取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：
取前3个元素，应该怎么做？
笨办法：
之所以是笨办法是因为扩展一下，取前N个元素就没辙了。
取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：
对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。
对应上面的问题，取前3个元素，用一行代码就可以完成切片：
L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
如果第一个索引是0，还可以省略：
也可以从索引1开始，取出2个元素出来：
类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：
记住倒数第一个元素的索引是-1。
切片操作十分有用。我们先创建一个0-99的数列：
可以通过切片轻松取出某一段数列。比如前10个数：
后10个数：
前11-20个数：
前10个数，每两个取一个：
所有数，每5个取一个：
甚至什么都不写，只写[:]就可以原样复制一个list：
tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：
字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：
在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。
利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法：
do_slice.py
有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。
Python内建了map()和reduce()函数。
如果你读过Google的那篇大名鼎鼎的论文“MapReduce: Simplified Data Processing on Large Clusters”，你就能大概明白map/reduce的概念。
我们先看map。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：
现在，我们用Python代码实现：
map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。
你可能会想，不需要map()函数，写一个循环，也可以计算出结果：
的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？
所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：
只需要一行代码。
再看reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
比方说对一个序列求和，就可以用reduce实现：
当然求和运算可以直接用Python内建函数sum()，没必要动用reduce。
但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：
这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：
整理成一个str2int的函数就是：
还可以用lambda函数进一步简化成：
也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！
lambda函数的用法在后面介绍。
利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：
Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积：
利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456：
do_map.py
do_reduce.py
map用于将一个函数作用于一个序列，以此得到另一个序列；
reduce用于将一个函数依次作用于上次计算的结果和序列的下一个元素，以此得到最终结果。
我们已经知道，可以直接作用于for循环的数据类型有以下几种：
一类是集合数据类型，如list、tuple、dict、set、str等；
一类是generator，包括生成器和带yield的generator function。
这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。
可以使用isinstance()判断一个对象是否是Iterable对象：
而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。
可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。
可以使用isinstance()判断一个对象是否是Iterator对象：
生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。
把list、dict、str等Iterable变成Iterator可以使用iter()函数：
你可能会问，为什么list、dict、str等数据类型不是Iterator？
这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。
Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。
do_iterator.py
凡是可作用于for循环的对象都是Iterable类型；
凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。
Python的for循环本质上就是通过不断调用next()函数实现的，例如：
实际上完全等价于：
当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。
在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：
通过对比可以看出，匿名函数lambda x: x * x实际上就是：
关键字lambda表示匿名函数，冒号前面的x表示函数参数。
匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。
用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：
同样，也可以把匿名函数作为返回值返回，比如：
请用匿名函数改造下面的代码：
Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。
Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。
我们以内建的sys模块为例，编写一个hello的模块：
第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；
第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；
第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；
以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。
后面开始就是真正的代码部分。
你可能注意到了，使用sys模块的第一步，就是导入该模块：
导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。
sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：
运行python3 hello.py获得的sys.argv就是['hello.py']；
运行python3 hello.py Michael获得的sys.argv就是['hello.py', 'Michael']。
最后，注意到这两行代码：
当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。
我们可以用命令行运行hello.py看看效果：
如果启动Python交互环境，再导入hello模块：
导入时，没有打印Hello, word!，因为没有执行test()函数。
调用hello.test()时，才能打印出Hello, word!：
在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。
正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；
类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；
类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；
之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。
private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：
我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：
外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。
如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。
在Python中，迭代是通过for ... in来完成的，而很多语言比如C语言，迭代list是通过下标完成的，比如C代码：
可以看出，Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。
list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：
因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。
默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。
由于字符串也是可迭代对象，因此，也可以作用于for循环：
所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。
那么，如何判断一个对象是可迭代对象呢？方法是通过collections.abc模块的Iterable类型判断：
最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：
上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：
请使用迭代查找一个list中最小和最大值，并返回一个tuple：
do_iter.py
任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。
在Python中，安装第三方模块，是通过包管理工具pip完成的。
如果你正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。
如果你正在使用Windows，请参考安装Python一节的内容，确保安装时勾选了pip和Add python.exe to Path。
在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。
注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。
例如，我们要安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。
一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：
耐心等待下载并安装后，就可以使用Pillow了。
在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。
可以从Anaconda官网下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。
安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：
可以尝试直接import numpy等已安装的第三方模块。
当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：
默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：
如果我们要添加自己的搜索目录，有两种方法：
一是直接修改sys.path，添加要搜索的目录：
这种方法是在运行时修改，运行结束后失效。
第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加我们自己的搜索路径，Python本身的搜索路径不受影响。
排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。
Python内置的sorted()函数就可以对list进行排序：
此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：
key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：
然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：
我们再看一个字符串排序的例子：
默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面。
现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。
这样，我们给sorted传入key函数，即可实现忽略大小写的排序：
要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：
从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。
sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。
假设我们用一组tuple表示学生名字和成绩：
请用sorted()对上述列表分别按名字排序：
再按成绩从高到低排序：
do_sorted.py
Python内建的filter()函数用于过滤序列。
和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
例如，在一个list中，删掉偶数，只保留奇数，可以这么写：
把一个序列中的空字符串删掉，可以这么写：
可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。
注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。
计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：
首先，列出从2开始的所有自然数，构造一个序列：
2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：
3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：
5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
取新序列的第一个数5，然后用5把序列的5的倍数筛掉：
7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
不断筛下去，就可以得到所有的素数。
用Python来实现这个算法，可以先构造一个从3开始的奇数序列：
注意这是一个生成器，并且是一个无限序列。
然后定义一个筛选函数：
最后，定义一个生成器，不断返回下一个素数：
这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。
由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：
注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。
回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：
filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。
do_filter.py
prime_numbers.py
高阶函数英文叫Higher-order function。什么是高阶函数？我们以实际代码为例子，一步一步深入概念。
以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：
但是，如果只写abs呢？
可见，abs(-10)是函数调用，而abs是函数本身。
要获得函数调用结果，我们可以把结果赋值给变量：
但是，如果把函数本身赋值给变量呢？
结论：函数本身也可以赋值给变量，即：变量可以指向函数。
如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：
成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。
那么函数名是什么呢？函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！
如果把abs指向其他对象，会有什么情况发生？
把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！
当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。
注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。
既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
一个最简单的高阶函数：
当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：
用代码验证一下：
编写高阶函数，就是让函数的参数能够接收别的函数。
do_f_add.py
把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。
函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。
而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。
我们首先要搞明白计算机（Computer）和计算（Compute）的概念。
在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。
而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。
对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。
函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。
面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。
面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。
而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。
在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。
我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。
假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：
而处理学生成绩可以通过函数实现，比如打印学生的成绩：
如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。
给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：
面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。
所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。
面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。
数据封装、继承和多态是面向对象的三大特点，我们后面会详细讲解。
在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。
比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：
当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：
对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。
继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animal实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：
运行结果如下：
当然，也可以对子类增加一些方法，比如Dog类：
继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...，因此，对Dog和Cat类改进如下：
再次运行，结果如下：
当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。
要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：
判断一个变量是否是某个类型可以用isinstance()判断：
看来a、b、c确实对应着list、Animal、Dog这3种类型。
但是等等，试试：
看来c不仅仅是Dog，c还是Animal！
不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！
所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：
Dog可以看成Animal，但Animal不可以看成Dog。
要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：
当我们传入Animal的实例时，run_twice()就打印出：
当我们传入Dog的实例时，run_twice()就打印出：
当我们传入Cat的实例时，run_twice()就打印出：
看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：
当我们调用run_twice()时，传入Tortoise的实例：
你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。
多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：
对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：
对扩展开放：允许新增Animal子类；
对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。
继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：
对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。
对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：
这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。
Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。
继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。
动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。
animals.py
get_instance.py
由于Python是动态语言，根据类创建的实例可以任意绑定属性。
给实例绑定属性的方法是通过实例变量，或者通过self变量：
但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：
当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：
从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。
为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：
实例属性属于各个实例所有，互不干扰；
类属性属于类所有，所有实例共享一个属性；
不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。
当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？
首先，我们来判断对象类型，使用type()函数：
基本类型都可以用type()判断：
如果一个变量指向函数或者类，也可以用type()判断：
但是type()函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：
判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以使用types模块中定义的常量：
对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。
我们回顾上次的例子，如果继承关系是：
那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：
然后，判断：
没有问题，因为h变量指向的就是Husky对象。
再判断：
h虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型。换句话说，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。
因此，我们可以确信，h还是Animal类型：
同理，实际类型是Dog的d也是Animal类型：
但是，d不是Husky类型：
能用type()判断的基本类型也可以用isinstance()判断：
并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：
提示
总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。
如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：
类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：
我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：
剩下的都是普通属性或方法，比如lower()返回小写的字符串：
仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：
紧接着，可以测试该对象的属性：
如果试图获取不存在的属性，会抛出AttributeError的错误：
可以传入一个default参数，如果属性不存在，就返回默认值：
也可以获得对象的方法：
通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：
就不要写：
一个正确的用法的例子如下：
假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。
请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。
get_type.py
attrs.py
在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。
但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：
如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：
改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：
这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。
但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：
如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：
你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：
需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。
有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：
但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。
总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。
最后注意下面的这种错误写法：
表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：
请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性：
protected_student.py
面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。
仍以Student类为例，在Python中，定义类是通过class关键字：
class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。
定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：
可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。
可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：
由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：
注意
特殊方法__init__前后分别有两个下划线！！！
注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。
有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：
和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。
面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：
但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：
要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：
这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。
封装的另一个好处是可以给Student类增加新的方法，比如get_grade：
同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节：
类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；
方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；
通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。
和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：
student.py

3.1  数值数据类型 
计算机刚开发出来时，它们主要被视为数字处理器，现在这仍然是一个重要的应用。
如你所见，涉及数学公式的问题很容易转化为Python 程序。在本章中，我们将仔细观察一
些程序，它们的目的是执行数值计算。
计算机程序存储和操作的信息通常称为“数据”。不同种类的数据以不同的方式存储和
操作。请考虑这个计算零钱的程序：
下面是输出示例：
第3 章  数字计算
这个程序实际上操作两种不同的数字。用户输入的值（5，3，4，6）是整数，它们
没有任何小数部分。硬币的值（.25，.10，.05，.01）是分数的十进制表示。在计算机内
部，整数和具有小数部分的数字以不同的方式存储。从技术上讲，这是两种不同的“数
对象的数据类型决定了它可以具有的值以及可以对它执行的操作。整数用“integer”数
据类型（简写为“int”）表示。int 类型的值可以是正数或负数。可以具有小数部分的数字表
示为“floating-point（浮点）”（或“float”）值。那么我们如何判断一个数值是int 还是float
呢？不包含小数点的数值字面量生成一个int 值，但是具有小数点的字面量由float 表示（即
使小数部分为0）。 
Python 提供了一个特殊函数，名为type，它告诉我们任何值的数据类型（或“class”）。
下面是与Python 解释器的交互，显示int 和float 字面量之间的区别： 
你可能希望知道，为什么有两种不同的数据类型。一个原因涉及程序风格。表示计数
的值不能为小数，例如，我们不能有3.12 个季度。使用int 值告诉读者程序的值不能是一个
分数。另一个原因涉及各种操作的效率。对于int，执行计算机运算的基础算法更简单，因
此可以更快，而float 值所需的算法更通用。当然，在现代处理器上，浮点运算的硬件实现
是高度优化的，可能与int 运算一样快。 
int 和float 之间的另一个区别是，float 类型只能表示对实数的近似。我们会看到，存储
值的精度（或准确度）存在限制。由于浮点值不精确，而int 总是精确的，所以一般的经验
法则应该是：如果不需要小数值，就用int。 
值的数据类型决定了可以使用的操作。如你所见，Python 支持对数值的一般数学运算。
表3.1 总结了这些操作。实际上，这个表有些误导。由于这两种类型具有不同的底层表示，
所以它们各自具有不同的一组操作。例如，我只列出了一个加法操作，但请记住，对float
值执行加法时，计算机硬件执行浮点加法，而对int 值，计算机执行整数加法。Python 基于
操作数选择合适的底层操作（int 或float）。 
3.1  数值数据类型 
Python 内置的数值操作 
请考虑以下Python 交互： 
在大多数情况下，对float 的操作产生float，对int 的操作产生int。大多数时候，我们
甚至不必担心正在执行什么类型的操作。例如，整数加法与浮点加法产生的结果几乎相同，
我们可以相信Python 会做正确的事情。 
然而，在除法时，事情就比较有趣了。如表所列，Python（版本3.0）提供了两种不同
的运算符。通常的符号（/）用于“常规”除法，双斜线（//）用于表示整数除法。找到它们
之间差异的最佳方法就是试一下。
第3 章  数字计算
请注意，“/”操作符总是返回一个浮点数。常规除法通常产生分数结果，即使操作数可
能是int。Python 通过返回一个浮点数来满足这个要求。10/3 的结果最后有一个5，你是否
感到惊讶？请记住，浮点值总是近似值。该值与Python 将3 1
3 表示为浮点数时得到的近似
要获得返回整数结果的除法，可以使用整数除法运算“//”。整数除法总是产生一个整
数。 把整数除法看作gozinta（进入或整除）。表达式10 // 3 得到3，因为3 进入 10 共计3
次（余数为1）。虽然整数除法的结果总是一个整数，但结果的数据类型取决于操作数的数
据类型。浮点整数整除浮点数得到一个浮点数，它的分数分量为0。最后两个交互展示了余
数运算%。请再次注意，结果的数据类型取决于操作数的类型。 
由于数学背景不同，你可能没用过整数除法或余数运算。要记住的是，这两个操作是
密切相关的。整数除法告诉你一个数字进入另一个数字的次数，剩余部分告诉你剩下多少。
数学上你可以写为a = (a//b)(b) + (a%b)。 
作为示例应用程序，假设我们以美分来计算零钱（而不是美元）。如果我有383 美分，
那么我可以通过计算383 // 100 = 3 找到完整美元的数量，剩余的零钱是383%100 = 83。因
此，我肯定共有3 美元和83 美分的零钱。 
顺便说一句，虽然Python（版本3.0）将常规除法和整数除法作为两个独立的运算符，
但是许多其他计算机语言（和早期的Python 版本）只是使用“/”来表示这两种情况。当操
作数是整数时，“/”表示整数除法，当它们是浮点数时，它表示常规除法。这是一个常见的
错误来源。例如，在我们的温度转换程序中，公式9/5 * celsius + 32 不会计算正确的结果，
因为9/5 将使用整数除法计算为1。在这些语言中，你需要小心地将此表达式编写为9.0 / 5.0 
* celsius + 32，以便使用正确的除法形式，从而得到分数结果。
3.2  类型转换和舍入 
在某些情况下，值可能需要从一种数据类型转换为另一种数据类型。你已知道，int 和
int 组合（通常）产生一个int，float 和float 组合创建另一个float。但是如果我们写一个混合
int 和float 的表达式会发生什么呢？例如，在下列赋值语句之后，x 的值应该是什么： 
如果这是浮点乘法，则结果应为浮点值10.0。如果执行整型乘法，结果就是10。在继
续读下去获得答案之前，请花一点时间考虑：你认为Python 应该怎样处理这种情况。 
为了理解表达式5.0 * 2，Python 必须将5.0 转换为5 并执行int 操作，或将2 转换为2.0
并执行浮点操作。一般来说，将float 转换为int 是一个危险的步骤，因为一些信息（小数部
分）会丢失。另一方面，int 可以安全地转换为浮点，只需添加一个小数部分0。因此，在
“混合类型表达式”中，Python 会自动将int 转换为浮点数，并执行浮点运算以产生浮点数
3.2  类型转换和舍入 
有时我们可能希望自己执行类型转换。这称为显式类型转换。Python 为这些场合提供
了内置函数int 和float。以下一些交互示例说明了它们的行为： 
如你所见，转换为int 就是丢弃浮点值的小数部分，该值将被截断，而不是舍入。如果
你希望一个四舍五入的结果，假设值为正，可以在使用int()之前加上0.5。对数字进行四舍
五入的更一般方法是使用内置的round 函数，它将数字四舍五入到最接近的整数值。 
请注意，像这样调用round 会产生一个int 值。因此，对round 的简单调用是将float 转
换为int 的另一种方法。 
如果要将浮点值舍入为另一个浮点值，则可以通过提供第二个参数来指定在小数点后
的数字位数。下面的交互处理π 的值： 
请注意，当我们将π近似舍入到两位或三位小数时，我们得到一个浮点数，其显示值
看起来像一个完全舍入的结果。记住，浮点值是近似。真正得到的是一个非常接近我们要
求的值。实际存储的值类似于3.140000000000000124345……，最接近的可表示的浮点值为
3.14。幸运的是，Python 是聪明的，知道我们可能不希望看到所有这些数字，所以它显示了
舍入的形式。这意味着如果你编写一个程序，将一个值四舍五入到两位小数，并打印出来，
就会看到两位小数，与你期望的一样。在第5 章中，我们将看到如何更好地控制打印数字
的显示方式，那时如果你希望，就能查看所有的数字。
类型转换函数int 和float 也可以用于将数字字符串转换为数字。 
作为替代eval 从用户获取数字数据的另一种方法，这特别有用。例如，下面是本章开
第3 章  数字计算
始时零钱计数程序的一个改进版本：
在input 语句中使用int 而不是eval，可以确保用户只能输入有效的整数。任何非法（非
int）输入将导致程序崩溃和错误消息，从而避免代码注入攻击的风险（在第2.5.2 节讨论）。
另一个好处是，这个版本的程序强调输入应该是整数。
使用数字类型转换代替eval 的唯一缺点是，它不支持同时输入（在单个输入中获取多
个值），如下例所示：
这个代价很小，换来了额外的安全性。在第5 章，你将学习如何克服这个限制。作为
一种良好的实践，你应该尽可能使用适当的类型转换函数代替eval。 
3.3  使用math 库 
除表3.1 中列出的操作之外，Python 还在一个特殊的math“库”中提供了许多其他有
用的数学函数。库就是一个模块，包含了一些有用定义。我们的下一个程序展示了使用这
个库来计算二次方程的根。
二次方程的形式为ax2 + bx + c = 0。这样的方程有两个解，由求根公式给出： 
让我们编写一个程序，找到二次方程的解。程序的输入将是系数a、b 和c 的值，输出
3.3  使用math 库 
是由求根公式给出的两个值。下面是完成这项工作的程序：
该程序使用了math 库模块的平方根函数sqrt。在程序的顶部，import math 告诉Python
我们正在使用math 模块。导入模块让程序中定义的任何内容都可用。要计算
用math.sqrt(x)。这个特殊的点符号告诉Python，使用“生存”在math 模块中的sqrt 函数。
在二次方程程序中，我们用下面的代码行来计算
下面是程序运行的情况：
只要我们要解的二次方程有实数解，这个程序就很好。但是，一些输入会导致程序崩
溃。下面是另一个运行示例：
第3 章  数字计算
这里的问题是b2 − 4ac < 0，sqrt 函数无法计算负数的平方根。Python 打印“math domain 
error”。这告诉我们，负数不在sqrt 函数的定义域中。现在，我们没有工具来解决这个问题，
所以我们只需要假设用户会给我们可解的方程。
实际上，quadratic.py 不需要使用math 库。我们可以用乘方**来取平方根。（你知道怎
么做吗？）使用math.sqrt 更高效一些，而且它让我展示使用math 库。一般来说，如果你的
程序需要一个通用的数学函数，首先要看看math 库。表3.2 显示了math 库中提供的一些其
一些math 库函数 
x 的自然对数（以e 为底） 
x 的常用对数（以10 为底） 
最小的>=x 的整数 
最大的<=x 的整数 
3.4  累积结果：阶乘 
假设你有一个根汁饮料样品包，含有6 种不同的根汁饮料。以不同的顺序喝各种口味
可能会影响它们的味道。如果你希望尝试一切可能，有多少不同的顺序？结果答案是一个
大得惊人的数字，720。你知道这个数字怎么来的吗？720 是6 的“阶乘”。 
在数学中，阶乘通常用感叹号（!）表示，整数n 的阶乘定义为n! = n(n – 1)(n – 2)……
(1)。这恰好是n 项的不同排列的数量。给定6 个项，我们计算6! = (6)(5)(4)(3)(2)(1) = 720
让我们编写一个程序，来计算用户输入数字的阶乘。程序的基本结构遵循“输入、处
理、输出”模式：
输入要计算阶乘的数，n 
计算n 的阶乘，fact 
3.4  累积结果：阶乘 
显然，这里棘手的是第二步。
实际如何计算阶乘？让我们手工尝试一下，以便得到处理的思路。在计算6 的阶乘时，
我们首先计算6(5) = 30。然后我们取该结果并做另一个乘法：30(4) = 120。这个结果乘以3：
120(3) = 360。这个结果乘以2：360(2) = 720。根据定义，最后我们将这个结果乘以1，但不
会改变最终值720。 
现在让我们考虑更一般的算法。这里实际上发生了什么？我们正在做重复乘法，在做
的过程中，我们记下得到的乘积。这是一种非常常见的算法模式，称为“累积器”。我们一
步一步得到（或累积）最终的值。为了在程序中实现这一点，我们使用“累积器变量”和
循环结构。一般模式如下：
初始化累积器变量 
循环直到得到最终结果 
更新累积器变量的值 
意识到这是解决阶乘问题的模式，我们只需要填写细节。我们将累积阶乘。让我们把
它保存在一个名为fact 的变量中。每次通过循环，我们需要用fact 乘以因子序列n、(n – 
1)、……、1 中的一个。看起来我们应该用一个for 循环，迭代这个因子序列。例如，要计
算6 的阶乘，我们需要像这样工作的循环： 
请花一分钟跟踪这个循环的执行，并说服自己它有效。当循环体首次执行时，fact 的值
为1，因子为6。因此，fact 的新值为1 * 6 = 6。下一次通过循环，因子将为5，fact 更新为
6 * 5 = 30。该模式对后续每个因子继续，直到累积得到最终结果720。 
循环之前对fact 赋初始值1，是循环开始所必需的。每次通过循环体（包括第一个），
fact 的当前值用于计算下一个值。初始化确保fact 在第一次迭代时有一个值。每次使用累积
器模式时，应确保包含正确的初始化。忘记这一点是新程序员的一个常见错误。
当然，我们还有很多其他的方法来编写这个循环。正如你从数学课上了解到的，乘法
是可交换和结合的，所以执行乘法的顺序并不重要。我们可以很容易地走另一个方向。你
可能还会注意到，在因子列表中包含1 是不必要的，因为乘以1 不会更改结果。下面是另
一个版本，计算出相同的结果：
不幸的是，这两个循环都不能解决原来的问题。我们手工编码了因子列表来计算6 的
阶乘。我们真正希望的是，一个可以计算任何给定输入n 的阶乘的程序。我们需要某种方
法，从n 的值生成适当的因子序列。 
好在用Python 的range 函数，这很容易做到。回想一下，range(n)产生一个数字序列，
从0 开始，增长到n，但不包括n。range 有一些其他调用方式，可用于产生不同的序列。利
用两个参数，range(start，n)产生一个以值start 开始的序列，增长到n，但不包括n。第三个
版本的range(start，n，step)类似于双参数版本，但它使用step 作为数字之间的增量。下面
第3 章  数字计算
给定输入值n，我们有几种不同的range 命令，能产生适当的因子列表，用于计算n 的
阶乘。为了从最小到最大生成它们（我们的第二种循环），我们可以使用range(2，n + 1)。
注意，我使用n + 1 作为第二个参数，因为范围将上升到n + 1，但不包括此值。我们需要加
1 来确保n 本身被包括，作为最后一个因子。 
另一种可能是使用三参数版本的range 和负数步长，产生另一个方向（我们的第一种循
环）的因子，导致倒计数：range(n，1，−1)。这个循环产生一个列表，从n 开始并向下计数
（step 为−1）到1，但不包括1。 
下面是一种可能的阶乘程序版本：
当然，写这个程序还有很多其他方法。我已经提到改变因子的顺序。另一种可能是将
fact 初始化为n，然后使用从n−1 开始的因子（只要n> 0）。你可以尝试这样一些变化，看
看你最喜欢哪一个。
3.5  计算机算术的局限性 
有时我们会联想到，用“!”表示阶乘是因为该函数增长非常快。例如，下面是用我们
的程序求100 的阶乘： 
这是一个相当大的数字！
尽管最新版本的Python 对此计算没有困难，但是旧版本的Python（以及其他语言的现
代版本，例如C ++和Java）不会如此。例如，下面是使用Java 编写的类似程序的几次运行： 
3.5  计算机算术的局限性 
这看起来不错。我们知道6! = 720。快速检查也确认12! = 479001600。遗憾的是，事实
证明，13! = 6227020800。看起来Java 程序给出了不正确的答案！ 
这里发生了什么？到目前为止，我们已经讨论了数值数据类型作为熟悉数字的表示，
例如整数和小数（分数）。然而，重要的是要记住，数字的计算机表示（实际数据类型）并
不总是表现得像它们所代表的数字那样。
在第1 章中你了解到，计算机的CPU 可以执行非常基本的操作，如两个数字相加或相
乘，还记得吗？更准确地说，CPU 可以对计算机的数字的内部表示执行基本操作。这个Java
程序的问题是它使用计算机的底层int 数据类型来表示整数，并依赖于计算机对int 的乘法
运算。不幸的是，这些机器int 不完全像数学整数。有无穷多个整数，但int 的范围是有限
的。在计算机内部，int 以固定大小的二进制表示存储。为了理解这一切，我们需要了解硬件
层面发生了什么。
计算机存储器由电“开关”组成，每个开关可以处于两种可能状态之一，即开或关。
每个开关表示一个二进制数字的信息，称为“位”。一位可以编码两种可能性，通常用数字
0（关闭）和1（打开）表示。位序列可以用于表示更多的可能性。用两位，我们可以表示
三位允许我们通过对四个两位模式中的每一个添加0 或1，来表示八个不同的值： 
你可以看到这里的模式。每增加一位让不同模式的数量加倍。通常，n 位可以表示2n
特定计算机用来表示int 的位数取决于CPU 的设计。现在，典型的PC 使用32 或64 位。
对于32 位CPU，这意味着有232 个可能的值。这些值以0 为中心，表示正整数和负整数的
范围。现在232/2 = 231。因此，可以在32 位int 值中表示的整数范围是−231 到231 − 1。在上
限−1 的原因是考虑在范围的上半部分中的0 的表示。 
第3 章  数字计算
有了这个知识，让我们试着理解Java 阶乘例子中发生的事情。如果Java 程序依赖于32
位int 表示，它可以存储的最大数字是多少？Python 可以给我们一个快速的答案： 
注意，这个值（约21 亿）在12!（约4.8 亿）和13！（约62 亿）之间。这意味着Java
程序可以很好地计算到12 的阶乘，但是之后，表示“溢出”，结果是垃圾。现在你知道了
为什么简单的Java 程序不能计算13!。当然，这给我们留下了另一个谜题。为什么现代Python
程序似乎能很好地用大整数计算？
首先，你可能认为Python 使用浮点数据类型来绕过int 的大小限制。然而，事实证明，
浮点数并没有真正解决这个问题。下面是使用浮点数的修改后的阶乘程序的示例运行：
虽然这个程序运行很好，但切换到浮点数后，我们不再能得到确切的答案。
非常大（或非常小）的浮点值使用“指数”的方式打印，称为“科学记数法”。结束时
的e + 32 表示结果等于2.6525285981219103 * 1032。你可以把+32 作为一个标记，表示小数
点的位置。在这个例子中，它必须向右移动32 个位置以获取实际值。但是，小数点右边只
有16 位数字，因此我们已经“丢失”了最后16 位数字。 
使用浮点数，我们可以表示比32 位int 更大的“范围”的值，但“精度”仍然是固定
的。事实上，计算机将浮点数保存为一对固定长度（二进制）整数。一个整数称为“尾数”，
表示值中的数字串，第二个称为“指数”，记录整数部分结束和小数部分开始的位置（“二
进制小数点”在哪里）。回忆一下，我告诉过你浮点是近似值。现在你可以看到原因。因为
底层数字是二进制的，所以只有涉及2 的幂的分数可以被精确地表示。任何其他分数产生
无限重复的尾数。（就像1/3 产生无限重复的十进制，因为3 不是10 的幂）。当无限长的尾
数被截断到固定长度以进行存储时，结果是近似的。用于尾数的位数决定了近似值的精确
程度，但绕不过它们是近似的事实。
幸运的是，Python 对于大的、精确的值有一个更好的解决方案。Python 的int 不是固定
的大小，而是扩展到适应任何值。唯一的限制是计算机可用的内存量。当值很小时，Python
就用计算机的底层int 表示和操作。当值变大时，Python 会自动转换为使用更多位的表示。
当然，为了对更大的数字执行操作，Python 必须将操作分解为计算机硬件能够处理的更小
的单元，类似于你手工计算长除法的方式。这些操作不会那么有效（它们需要更多的步骤），
但是它们允许Python 的int 增长到任意大小。这就是为什么我们的简单阶乘程序可以计算一
些大的结果。这是一个非常酷的Python 特性。 
本章介绍了一些有关进行数值计算的程序的重要细节。下面是一些关键概念的快速摘要。 
  计算机表示特定类型的信息的方式称为数据类型。对象的数据类型决定了它可以
具有的值和它支持的操作。
  Python 有几种不同的数据类型来表示数值，包括int 和float。 
  整数通常使用int 数据类型表示，小数值使用float 表示。所有Python 数字数据类
型都支持标准的内置数学运算：加法（+）、减法（−）、乘法（*）、除法（/），
整除（//），取余（%）和绝对值（abs(x)）。 
  Python 在某些情况下，自动将数字从一种数据类型转换为另一种。例如，在涉及int
和float 的混合类型表达式中，Python 先将int 转换为float，然后使用浮点运算。 
  程序还可以使用函数float()、int()和round()将一个数据类型显式转换为另一个数据
类型。通常应该使用类型转换函数代替eval 来处理用户的数字输入。 
  其他数学函数在math 库中定义。要使用这些功能，程序必须首先导入该库。 
数值结果通常通过计算值序列的和或积来计算。循环累积器编程模式对于这种计
  int 和float 在底层计算机上都使用固定长度的位序列表示。这让这些表示有某些限
制。在32 位的机器上，硬件int 必须在−231～231−1 中。浮点数的精度有限，不能
精确地表示大多数数字。
  Python 的int 数据类型可以用于存储任意大小的整数。如果int 值对于底层硬件int
太大，就会自动转换为更长的表示。涉及这些长int 的计算比只使用短int 的计算
1．由计算机存储和操作的信息称为数据。 
2．由于浮点数是非常准确的，所以通常应该使用它们，而不是int。 
3．像加法和减法这样的操作在math 库中定义。 
4．n 项的可能排列的数目等于n！。 
5．sqrt 函数计算数字的喷射（squirt）。 
6．float 数据类型与实数的数学概念相同。 
7．计算机使用二进制表示数字。 
8．硬件float 可以表示比硬件int 更大范围的值。 
9．在获取数字作为用户输入时，类型转换函数（如float）是eval 的安全替代。 
10．在Python 中，4 + 5 产生与4.0 + 5.0 相同的结果类型。 
项不是内置的Python 数据类型。 
第3 章  数字计算
c．rational  
d．string 
项不是内置操作。
d．sqrt() 
3．为了使用math 库中的函数，程序必须包括    。 
d．import 语句 
5．用于存储π的值，最合适的数据类型是    。 
c．irrational 
d．string 
6．可以使用5 位比特表示的不同值的数量是    。 
7．在包含int 和float 的混合类型表达式中，Python 会进行的转换是
a．浮点数到整数 
b．整数到字符串 
c．浮点数和整数到字符串 
d．整数到浮点数 
项不是Python 类型转换函数。 
9．用于计算阶乘的模式是
b．输入、处理、输出 
10．在现代Python 中，int 值大于底层硬件int 时，会    。 
b．转换为float 
d．使用更多的内存 
1．显示每个表达式求值的结果。确保该值以正确的形式表示其类型（int 或float）。如
果表达式是非法的，请解释为什么。
a．4.0 / 10.0 + 3.5 * 2
b．10 % 4 + 6 / 2 
b．abs(4 - 20 // 3) ** 3 
d．sqrt(4.5 - 5.0) + 7 * 3 
e．3 * 10 // 3 + 10 % 3
f．3 ** 3
2．将以下每个数学表达式转换为等效的Python 表达式。你可以假定math 库已导入（通
过import math）。 
a．(3 + 4)(5) 
3．显示将由以下每个range 表达式生成的数字序列。 
a．range(5)  
b．range(3, 10)
c．range(4, 13, 3) 
d．range(15, 5, -2)
e．range(5, 3)
4．显示以下每个程序片段产生的输出。 
a．for i in range(1, 11): 
b．for i in [1,3,5,7,9]:
d．ans = 0
5．如果使用负数作为round 函数中的第二个参数，你认为会发生什么？例如，
round(314.159265，−1)的结果应该是什么？请解释答案的理由。在你写下答案后，请参阅
Python 文档或尝试一些例子，看看Python 在这种情况下实际上做了什么。 
6．当整数除法或余数运算的操作数为负数时，你认为会发生什么？考虑以下每种情
况并尝试预测结果。然后在Python 中试试。（提示：回顾一下神奇的公式a = (a//b)(b) + 
a．−10 // 3 
b．−10 % 3 
c．10 // −3 
d．10 % −3 
e．−10 // −3 
1．编写一个程序，利用球体的半径作为输入，计算体积和表面积。以下是一些可能有
V = 4/3πr3 
A = 4πr2 
2．给定圆形比萨饼的直径和价格，编写一个程序，计算每平方英寸的成本。面积公式
为A = πr2。 
3．编写一个程序，该程序基于分子中的氢、碳和氧原子的数量计算碳水化合物的分子
量（以克/摩尔计）。程序应提示用户输入氢原子的数量、碳原子的数量和氧原子的数量。然
后程序基于这些单独的原子量打印所有原子的总组合分子量。
第3 章  数字计算
质量（克/摩尔） 
例如，水（H2O）的分子量为2（1.00794）+ 15.9994 = 18.01528。 
4．编写一个程序，根据闪光和雷声之间的时间差来确定雷击的距离。声速约为1100
英尺/秒，1 英里为5280 英尺。 
5．Konditorei 咖啡店售卖咖啡，每磅10.50 美元加上运费。每份订单的运费为每磅0.86
美元 +固定成本1.50 美元。编写计算订单费用的程序。 
6．使用坐标（x1，y1）和（x2，y2）指定平面中的两个点。编写一个程序，计算通过
用户输入的两个（非垂直）点的直线的斜率。
7．编写一个程序，接受两点（见上一个问题），并确定它们之间的距离。 
8．格里高利闰余是从1 月1 日到前一个新月的天数。此值用于确定复活节的日期。它
由下列公式计算（使用整型算术）：
编写程序，提示用户输入4 位数年份，然后输出闰余的值。 
9．使用以下公式编写程序以计算三角形的面积，其三边的长度为a、b 和c： 
10．编写程序，确定梯子斜靠在房子上时，达到给定高度所需的长度。梯子的高度和
角度作为输入。计算长度使用公式为：
注意：角度必须以弧度表示。提示输入以度为单位的角度，并使用以下公式进行转换： 
radians = π
11．编程计算前n 个自然数的和，其中n 的值由用户提供。 
12．编程计算前n 个自然数的立方和，其中n 的值由用户提供。 
13．编程对用户输入的一系列数字求和。 程序应该首先提示用户有多少数字要求和，
然后依次提示用户输入每个数字，并在输入所有数字后打印出总和。（提示：在循环体中使
14．编程计算用户输入的一系列数字的平均值。与前面的问题一样，程序会首先询问
用户有多少个数字。注意：平均值应该始终为float，即使用户输入都是int。 
15．编写程序，通过对这个级数的项进行求和来求近似的π 值：4/1 – 4/3 + 4/5 – 4/7 + 4/9 
− 4/11 +……程序应该提示用户输入n，要求和的项数，然后输出该级数的前n 个项的和。
让你的程序从math.pi 的值中减去近似值，看看它的准确性。 
16．斐波那契序列是数字序列，其中每个连续数字是前两个数字的和。经典的斐波那
契序列开始于1，1，2，3，5，8，13，……。编写计算第n 个斐波纳契数的程序，其中n
是用户输入的值。例如，如果n = 6，则结果为8。 
17．你已经看到math 库包含了一个计算数字平方根的函数。在本练习中，你将编写自
己的算法来计算平方根。解决这个问题的一种方法是使用猜测和检查。你首先猜测平方根
可能是什么，然后看看你的猜测是多么接近。你可以使用此信息进行另一个猜测，并继续
猜测，直到找到平方根（或其近似）。一个特别好的猜测方法是使用牛顿法。假设x 是我们
希望的根，guess 是当前猜测的答案。猜测可以通过使用计算下一个猜测来改进：
编程实现牛顿方法。程序应提示用户找到值的平方根（x）和改进猜测的次数。从猜测
值x / 2 开始，你的程序应该循环指定的次数，应用牛顿的方法，并报告猜测的最终值。你
还应该从math.sqrt(x)的值中减去你的估计值，以显示它的接近程度。 
理解对象的概念以及如何用它们来简化编程。
  熟悉graphics 库中可用的各种对象。 
能够在程序中创建对象并调用适当的方法来进行图形计算。
了解计算机图形学的基本概念，特别是坐标系统和坐标变换的作用。
了解如何在图形编程语境中使用基于鼠标和基于文本的输入。
  能够使用graphics 库编写简单的交互式图形程序。 
到目前为止，我们一直在使用Python 内置的数字和字符串数据类型来编写程序。我们
看到，每个数据类型可以表示一组特定的值，并且每个数据类型都有一组相关的操作。基
本上，我们将数据视为一些被动实体，通过主动操作来控制和组合它们。这是一种传统的
看待计算的视角。然而，为了构建复杂的系统，采用更丰富的视角来看待数据和操作之间
的关系是有帮助的。
大多数现代计算机程序是用“面向对象”（OO）方法构建的。面向对象不容易定义。它
包含了许多设计和实现软件的原则，我们将在本书的整个过程中反复提到。本章通过一些
计算机图形提供了对象概念的基本介绍。
图形编程很有乐趣，并提供了一种极好的方式来学习对象。在此过程中，你还将学习
计算机图形学的一些原理，它们是许多现代计算机应用程序的基础。你熟悉的大多数应用
程序可能有一个所谓的“图形用户界面”（GUI），提供了诸如窗口、图标（代表性图片）、
按钮和菜单等可视元素。
交互式图形编程可以非常复杂，有一些教科书整本书都在讲复杂的图形和图形界面。
工业级的GUI 应用程序通常使用专用的图形编程框架来开发。Python 自带的标准GUI 模块
名为Tkinter。Tkinter 是最易用的GUI 框架之一，Python 是开发真实世界GUI 的极好语言。
然而，在你的编程生涯中，此时学习任何GUI 框架的复杂细节都将是一个挑战，而且这样
做不会对达成本章的主要目标有所帮助。本章的主要目标是向你介绍对象和计算机图形学
为了让这些基本概念更容易学习，我们将使用专门为本教材编写的图形库（graphics.py）。
4.3  简单图形编程 
这个库是Tkinter 的一层包装，让它更适合新程序员。它是作为一个Python 模块文件免费提
①，欢迎你使用它，只要你认为合适。最终，你可能希望研究该库本身的代码，作为学
习如何直接用Tkinter 编程的垫脚石。 
4.2  对象的目标 
面向对象开发的基本思想，是将一个复杂的系统视为一些较简单“对象”的交互。这
里使用的“对象”一词有特定的技术意义。OO 编程的一部分挑战是弄清楚词汇表。你可以
将OO 对象视为一种结合数据和操作的主动数据类型。简单来说，对象“知道一些事情”（它
们包含数据），并且可以“做一些事情”（它们有操作）。对象通过彼此发送消息来交互。消
息就是请求，让对象执行它的一个操作。
请考虑一个简单的例子。假设我们希望为学院或大学开发数据处理系统。我们需要记
录相当多的信息。首先，必须记录入学的学生。每个学生都可以在程序中表示为一个对象。
学生对象将包含一些特定数据，如姓名、ID 号、所选的课程、校园地址、家庭地址、GPA
等。每个学生对象也能够响应某些请求。例如，要发送邮件，我们需要为每个学生打印一
个地址。此任务可能由printCampusAddress 操作处理。如果向一个特定的学生对象发送
printCampusAddress 消息，它就打印出自己的地址。要打印出所有的地址，程序将循环遍历
学生对象的集合，并依次发送printCampusAddress 消息。 
对象可以引用其他对象。在我们的示例中，学院中的每门课程也可能由一个对象表示。
课程对象将知道一些信息，如教师是谁、课程中有哪些学生、先决条件是什么以及课程的
时间地点。一个操作的例子可能是addStudent，它导致学生在课程中注册。正在注册的学生
将由适当的学生对象表示。教师将是另一种对象，房间也是，甚至时间也是。你可以看到
这些想法如何不断细化，从而得到一个相当复杂的大学信息结构模型。
作为一名新程序员，你可能还没有准备好处理大学信息系统。现在，我们将在一些简
单的图形编程的语境中研究对象。
4.3  简单图形编程 
为了在本章（以及本书的其余部分）中运行图形程序和示例，你需要graphics.py 的拷
贝，它与补充材料一起提供。使用graphics 库很简单，只要将graphics.py 文件的拷贝与图
形程序放在同一文件夹中。或者，你可以将它放在存储其他Python 库的系统目录中，以便
能够在系统的任何文件夹中使用它。
graphics 库让我们可以轻松地体验交互方式图形，编写简单的图形程序。在做的过程中，
你将学习面向对象编程和计算机图形学的原理，可以在更复杂的图形编程环境中应用。graphics
模块的细节将在后面的部分探讨。在这里，我们将专注于基本实战介绍，让你有点感觉。
①graphics 模块可从本书的支持网站获得。 
第4 章  对象和图形
像往常一样，开始学习新概念的最好方法是尝试一些例子。第一步是导入graphics 模块。
假设你已将graphics.py 放置在适当的位置，可以将graphics 的命令导入到交互式Python 会
话中。如果你在使用IDLE，可能必须首先将IDLE“指向”保存graphics.py 的文件夹。实
现这一点的简单方法，是从该文件夹加载并运行一个原有的程序。然后你应该能够将
graphics 导入shell 窗口： 
如果这个导入失败，就意味着Python 找不到graphics 模块。应确保文件放在正确的文
件夹中，然后重试。
接下来，我们需要在屏幕上创建一个地方来显示图形。这个地方是一个“图形窗口”，
即GraphWin，它由graphics 模块提供： 
注意，使用点符号来调用位于graphics 库中的GraphWin 函数。这类似于用math.sqrt(x)
从math 库模块中调用平方根函数。GraphWin()函数在屏幕上创建一个新窗口。该窗口的标
题是“Graphics Window”。GraphWin 可能遮住你的Python shell 窗口，因此你可能要调整大
小或移动shell，让两个窗口完全可见。图4.1 展示了一个屏幕视图的样子。 
图4.1 带有Python shell 和GraphWin 的屏幕截图 
GraphWin 是一个对象，我们将它赋给变量win。我们现在可以通过这个变量来操作窗
口对象。例如，我们用完窗口后，可以销毁它。这可以通过发出close 命令来做到： 
4.3  简单图形编程 
键入此命令将导致窗口从屏幕中消失。
注意，我们再次使用了点表示法，但现在使用它时，在点的左侧用了变量名称，而不
是模块名称。回想一下，win 早先被赋为GraphWin 类型的对象。GraphWin 对象可以做的事
情之一是关闭自己。你可以将该命令视为调用与这个窗口相关联的close 操作。结果是窗口
顺便说一句，我应该在这里提到，像这样交互式尝试图形命令，在一些环境中可能很
棘手。如果你在IDE 中使用shell（如IDLE），则有可能在你的特定平台上图形窗口表现为
无响应。例如，当你将鼠标悬停在窗口上时，可能会看到“忙”光标，你可能无法拖动窗
口来定位它。在某些情况下，你的图形窗口可能完全隐藏在IDE 下面，你必须去搜索它。
这些故障是由于IDE 和图形窗口都努力控制你的交互。尽管你在玩交互式图形时可能遇到
困难，但请放心，使用graphics 库的程序在大多数标准环境中应该运行良好。它们肯定能在
Windows、macOS 和Linux 下工作。 
我们将使用来自graphics 库的许多命令，每次我们使用一个命令就不得不键入
“graphics”符号，这很无趣。Python 的另一种导入方式有所帮助： 
from 语句允许你从库模块加载特定的定义。你可以列出要导入定义的名称，也可以使
用星号（如上）导入模块中定义的所有内容。导入的命令可直接使用，而无需使用模块名
称前缀。完成这个导入后，我们可以更简单地创建GraphWin： 
接下来所有的graphics 示例将假设整个graphics 模块已用from 导入。 
让我们动手尝试绘制一些图形。图形窗口实际上是一些小点的集合，这些小点称为“像
素”（“图像元素”的缩写）。通过控制每个像素的颜色，我们控制窗口中显示的内容。默认
情况下，GraphWin 的高度为200 像素，宽度为200 像素。这意味着GraphWin 中有4 万像
素。通过为每个单独的像素分配颜色来绘制图像将是一个艰巨的挑战。作为替代，我们将
依赖一个图形对象库。每种类型的对象都记录自己的信息，并知道如何将自己绘制到
GraphWin 中。 
图形模块中最简单的对象是Point（点）。在几何中，点是空间中的位置。通过参考坐标
系来定位点。我们的图形对象Point 是类似的，它可以表示GraphWin 中的一个位置。我们通
过提供x 和y 坐标（x, y）来定义一个点。x 值表示点的水平位置，y 值表示点的垂直位置。 
传统上，图形程序员将点(0, 0)定位在窗口的左上角。因此，x 值从左到右增加，y 值从
上到下增加。在默认的200×200 GraphWin 中，右下角坐标为(199, 199)。绘制点将设置
GraphWin 中对应像素的颜色。绘图的默认颜色为黑色。 
下面是一个与Python 交互的示例，展示了Point 的用法： 
第4 章  对象和图形
第一行创建了一个位于（50, 60）的Point。创建Point 后，它的坐标值可以通过getX
和getY 操作来访问。与所有函数调用一样，在尝试使用操作时，应确保将括号放在末尾。
用draw 操作将点绘制到窗口中。这个例子创建了两个不同的Point 对象（p 和p2），并绘制
到GraphWin 对象中，其名为win。图4.2 展示了生成的图形输出。 
除了点，graphics 库还包含了一些命令，用于绘制线段、圆、矩形、椭圆、多边形和文
本。这些对象中的每一个都以类似的方式创建和绘制。下面的示例交互将各种形状绘制到
GraphWin 中： 
请尝试弄清楚其中每个语句所做的事。如果你照样输入它们，最终的结果如图4.3 所示。 
图4.2 绘制两个点的图形窗口
图4.3 graphics 模块的各种形状 
4.4  使用图形对象 
以上交互中的一些示例可能看起来有点奇怪。为了真正理解graphics 模块，我们需要采
取面向对象的视角。记住，对象让数据与操作相结合。要求对象执行它的一个操作，就执
4.4  使用图形对象 
行了计算。为了使用对象，你需要知道如何创建它们以及如何请求操作。
在上面的交互示例中，我们处理了GraphWin、Point、Circle、Oval、Line、Text 和Rectangle
等几种不同类型的对象。这些是“类”的示例。每个对象都是某个类的“实例”，类描述了
实例将具有的属性。
借用一个生物学的隐喻，如果我们说Fido 是一只狗，实际上是说，Fido 是所有狗构成
的大类中的一个特定个体。用OO 术语来说，Fido 是狗类的一个实例。因为Fido 是这个类
的一个实例，我们有某些预期。Fido 有四条腿，一条尾巴，冷而湿润的鼻子，会吠叫。如
果Rex 是狗，我们预期它会有类似的属性，即使Fido 和Rex 可能在具体细节上不同，如大
同样的想法对我们的计算对象也成立。我们可以创建两个单独的Point 实例，例如p 和
p2。 每个点都有x 和y 值，它们都支持相同的操作集，如getX 和draw。这些属性成立，
因为对象是Point。然而，不同的实例可以在特定细节（诸如它们的坐标值）上变化。 
要创建一个类的新实例，我们使用一个特殊操作，称为“构造函数”。对构造函数的调
用是一个表达式，它创建了一个全新的对象。一般形式如下：
这里<class-name>是我们要创建一个新实例的类的名称，例如Circle 或Point。括号中的
表达式是初始化对象所需的任何参数。参数的数量和类型取决于该类。Point 需要两个数字
值，而GraphWin 可以不使用任何参数。通常，在赋值语句的右侧使用构造函数，生成的对
象立即赋给左侧的变量，然后用它来操作该对象。
举一个具体的例子，让我们来看看创建一个图形点时会发生什么。下面是来自上面的
交互示例的构造函数语句：
Point 类的构造函数需要两个参数，给出新点的x 和y 坐标。这些值作为“实例变量”
存储在对象内。在这种情况下，Python 创建一个Point 的实例，其x 值为50，y 值为60。然
后将生成的点赋给变量p。 
结果的概念图如图4.4 所示。注意，在该图以及类
似的图中，仅示出最突出的细节。点还包含其他信息，
如它们的颜色以及它们绘制在哪个窗口（如果有的话）。
在创建点时，大多数信息设置为默认值。
为了让对象执行操作，我们向对象发送一条消息。
对象响应的消息集称为对象的“方法”。你可以将方法
看作是存在于对象中的函数。使用点表示法来调用方法。
参数的数量和类型由所用的方法决定。一些方法根本不需要参数。你可以在上面的交
互示例中找到许多方法调用的例子。
作为无参数方法的示例，请考虑下面两个表达式：
图4.4 变量p 指的是一个新的Point 
第4 章  对象和图形
getX 和getY 方法分别返回点的x 和y 值。这些方法有时被称为“取值方法”，因为它
们允许我们从对象的实例变量访问信息。
其他方法改变了对象的实例变量的值，因此改变了对象的“状态”。所有图形对象都有
一个move 方法。下面是规格说明： 
move(dx,dy)：让对象在x 方向上移动dx 单位，在y 方向上移动dy 单位。 
要将点p 移动到右边10 个单位，我们可以用下列语句： 
这改变了p 的x 实例变量，添加了10 个单位。如果该点当前在GraphWin 中绘制，则
move 将负责擦除旧图像并在新位置绘制。改变对象状态的方法有时称为“设值方法”。 
move 方法必须提供两个简单的数字参数，指示沿每个维度移动对象的距离。一些方法
需要的参数本身也是复杂对象。例如，将Circle 绘制到GraphWin 中涉及两个对象。让我们
来看一个命令序列：
第一行创建一个圆，其中心位于Point(100, 100)，半径为30。请注意，我们使用Point 构造
函数为Circle 构造函数创建了第一个参数的位置。第二行创建一个GraphWin。你看到第三行发
生了什么吗？这是对Circle 对象的请求，用于将自己绘制到GraphWin 对象中。该语句的可视
效果就是GraphWin 中的一个圆，中心在(100, 100)，半径为30。在幕后，发生了更多事情。 
记住，draw 方法存在于circ 对象内部。使用来自实例变量的关于圆的中心和半径的信
息，draw 方法向GraphWin 发出适当的低级绘图命令序列（一系列方法调用）。Point、Circle
和GraphWin 对象之间的交互的概念图如图4.5 所示。幸运的是，我们通常不必担心这些细
节，它们都由图形对象来处理。我们只是创建对象、调用适当的方法，让它们完成工作。
这就是面向对象编程的力量。
图4.5 绘制圆的对象交互 
4.4  使用图形对象 
在使用对象时，需要记住一点微妙的“领悟”。两个不同的变量指的对象可能完全相同，
通过一个变量对对象所做的更改也会对另一个变量可见。例如，假设我们试图写一段绘制
笑脸的代码。我们希望创建两个相距20 个单位的眼睛。下面是画眼睛的代码序列： 
基本思想是创建左眼，然后将其复制到右眼，再移动20 个单位。 
这不行。这里的问题是只创建了一个Circle 对象。赋值rightEye = leftEye 只是让rightEye
指向与leftEye 完全相同的圆。图4.6 展示了这种情况。在最后一行代码中移动圆时，rightEye
和leftEye 都在它右边的新位置引用它。这种情况下，两个变量引用同一个对象称为“别名”，
它有时会产生意想不到的结果。
图4.6 变量leftEye 和rightEye 是别名 
这个问题的一个解决方案是为每只眼睛创建一个单独的圆：
这肯定行，但它很麻烦。我们不得为双眼写重复的代码。虽然用“剪切”和“粘贴”
的方法很容易做到，但它不是很优雅。如果我们决定改变眼睛的外观，我们必须确保在两
个地方进行更改。
graphics 库提供了更好的解决方案，所有图形对象都支持复制对象的clone 方法。利用
clone，我们可以挽救原来的方法： 
有策略地使用clone 可以让一些图形任务更容易。 
第4 章  对象和图形
4.5  绘制终值 
在对如何使用graphics 的对象有了一些概念之后，我们就可以尝试一些真正的图形编
程。图形的最重要的用途之一是提供数据的可视表示。人们说一张图值一千字，它几乎肯
定比一千个数字更好。任何操作数字数据的程序都可以通过输出一点图形来改进。还记得
第2 章中计算十年投资终值的程序吗？让我们试着创建一个图形汇总。 
使用图形编程需要仔细规划。在规划时，你可能需要铅笔和纸张，绘制一些图表并勾
画一些计算草图。像往常一样，我们首先考虑程序要做什么的规格说明。
原来的程序futval.py 有投资金额和年利率两个输入。利用这些输入，该程序用公式
principal = principal * (1 + apr) 计算逐年的本金变化，共10 年。然后打印出本金的最终值。
在图形版本中，输出将是十年的条形图，其中连续条形的高度表示连续几年中本金的值。
让我们用一个具体的例子来说明。假设我们以10%的利率投资2000 美元。表4.1 展示
了十年期间投资的增长情况。我们的程序将在条形图中显示此信息。图4.7 以图形方式显示
了相同的数据。该图形包含十一个柱形，第一个柱形显示本金的原始值。为了引用方便，
让我们根据累计利息的年数对这些柱形进行编号，从0 到10。 
以10%利率计算的2000 美元增长的情况 
下面是程序的大致设计：
从用户处获取principal 和apr 
创建一个GraphWin 
在窗口的左侧绘制刻度标签 
在位置0 处绘制柱形，高度对应principal 
对接下来的1 到10 年 
计算principal = principal * (1 + apr) 
绘制该年的柱形，高度对应principal 
等待用户按下回车键。 
4.5  绘制终值 
最后一步产生的暂停对于保持图形窗口显示是必要的，这样我们就可以解读结果。没
有这样的暂停，程序将结束，GraphWin 会消失。 
虽然这个设计为我们的算法提供了粗线条的描
述，但有一些非常重要的细节被掩藏了。我们必须
确定图形窗口将有多大，以及如何定位出现在此窗
口中的对象。例如，“绘制第五年的柱形，对应高度
为3221.02 美元”是什么意思？ 
让我们从GraphWin 的大小开始。回想一下，
窗口的大小是根据每个维度中的像素数量给出的。
计算机屏幕也以像素为单位度量。屏幕的像素数或
分辨率由你用的计算机中的显示器和显卡决定。最
近在个人计算机上可能遇到的最低分辨率屏幕是所
谓的扩展VGA 屏幕，是1024 像素×768 像素。大多
数屏幕相当大。我们默认的200 像素×200 像素窗口可能看起来有点小。我们让GraphWin
的大小为320 像素×240 像素，这使它大约占1/8 的小屏幕大小。 
鉴于这种分析，我们可以让设计具体一点。设计的第三行现在应该是：
创建一个320 像素×240 像素的GraphWin，标题为“Investment Growth Chart” 
你可能希望知道如何将它转换为Python 代码。你已经看到GraphWin 构造函数允许一
个可选参数指定窗口的标题。你还可以提供width 和height 参数来控制窗口的大小。因此，
创建输出窗口的命令将是：
接下来我们讨论沿着窗口左侧边缘显示标签的问题。为了简化问题，我们假设图形的
刻度最大总是10000 美元，带有五个标签“0.0K”到“10.0K”，如示例窗口所示。问题是如
何绘制标签？我们需要一些Text 对象。创建Text 时，我们指定锚点（文本居中的点）以及
用作标签的字符串。
标签字符串很容易。最长的标签是五个字符，标签应该都在列的右侧排列，因此较短
字符串的左侧将用空格填充。选择标签的位置需要一点计算和试错。通过一些交互尝试，
水平方向上长度为5 的字符串，将中心放在从左边缘开始20 个像素的位置，这样看起来很
好。在边缘只留下一点空白。
在垂直方向，有超过200 像素。简单的刻度将是用100 像素代表5000 美元。这意味着我
们的五个标签应该间隔50 像素。用200 像素表示范围0～10000，留下240 % 200 = 40 像素，
分开来作为顶部和底部边距。我们可能希望在顶部多留一点边距，以容纳超过10000 美元的值。
通过一个小的实验表明，将“0.0K”标签放在离底部10 像素（位置230），看起来挺好。 
细化我们的算法，包括这些细节，“在窗口的左侧绘制刻度标签”这一步变成一系列步骤： 
在(20, 230)绘制标签" 0.0K" 
在(20, 180)绘制标签" 2.5K" 
在(20, 130)绘制标签" 5.0K" 
在(20, 80)绘制标签" 7.5K" 
在(20, 30)绘制标签"10.0K" 
图4.7 柱状图显示在10%利率时 
2000 美元的增长 
第4 章  对象和图形
最初设计中的下一步需要绘制对应于本金初始值的柱形。很容易看到这个柱形的左下
角应该在哪里。0.0 美元的值垂直位置在像素230 处，标签的中心距离左边缘20 像素。再
加上20 个像素就是标签的右边缘。因此，第0 个柱形的左下角应该在位置（40，230）。 
现在我们只需要弄清楚柱形的对角（右上角）应该在哪里，就可以绘制一个合适的矩
形。在垂直方向上，柱形的高度由本金的值确定。在绘制刻度时，我们决定100 像素等于
5000 美元。这意味着我们有100 / 5000 = 0.02 像素对应1 美元。这告诉我们，例如，2000
美元的本金应该产生高度2000(.02)= 40 像素的柱形。一般来说，右上角的y 位置将由230 − 
(principal)(0.02)给出。（记住，230 是0 点，y 坐标向上增加。） 
柱形应该有多宽？该窗口宽320 像素，但40 个像素被左边的标签占据。这让我们有280
像素画11 个柱形：280÷11 = 25.4545。我们给每个柱形25 像素，这会在右边留出一点边距。
因此，我们的第一个柱形的右边缘将在位置40 + 25 = 65 像素处。 
我们现在可以将绘制第一个柱形的细节填充到算法中：
从(40, 230) 至 (65, 230 - principal * 0.02)绘制一个矩形 
此时，我们已经做出了完成这个问题需要的所有主要决定和计算，剩下的就是将这些
细节渗透到算法的其余部分。图4.8 展示了带有我们选择的一些尺寸的窗口一般布局。 
图4.8 图像元素在终值柱形图中的位置 
让我们弄清楚每个柱形的左下角在哪里。我们选择的柱形宽度是25，因此每一个连续
年份的柱形将从上一年右边25 像素开始。我们可以使用变量year 代表年份数，计算左下角
的x 坐标为(year)(25) + 40。（+ 40 为标签留下左边缘的空间。）当然，这个点的y 坐标仍然
是230（图的底部）。 
要找到柱形的右上角，我们将左下角的x 值加上25（柱形的宽度）。右上角的y 值通过
（更新的）本金值来确定，像我们确定第一个柱形一样。下面是细化的算法：
对于year 从1 增长10: 
计算principal = principal * (1 + apr) 
计算xll = 25 * year + 40 
计算height = principal * 0.02 
从(xll, 230) 至 (xll+25, 230 - height)绘制一个矩形 
变量xll 表示x 左下角（x lower-left）：柱形左下角的x 值。 
4.5  绘制终值 
综上所述，得到详细的算法如下：
从用户处获取principal 和apr 
创建一个320x240 的GraphWin，标题为”Investment Growth Chart” 
在(20, 230)绘制标签" 0.0K" 
在(20, 180)绘制标签" 2.5K" 
在(20, 130)绘制标签" 5.0K" 
在(20, 80)绘制标签" 7.5K" 
在(20, 30)绘制标签"10.0K" 
从(40, 230) 至 (65, 230 - principal * 0.02)绘制一个矩形 
对于year 从1 增长10: 
    计算principal = principal * (1 + apr) 
    计算xll = 25 * year + 40 
    计算height = principal * 0.02 
    从(xll, 230) 至 (xll+25, 230 - height)绘制一个矩形 
等待用户按下回车键。 
哇！工作量不小，但我们终于准备好将这个算法翻译成实际的Python 代码了。利用
graphics 库中的对象可以直接进行翻译。下面是程序： 
第4 章  对象和图形
如果仔细研究这个程序，就会看到，我添加了一些功能，让它更漂亮一些。所有图形
对象都支持更改颜色的方法。我将窗口的背景颜色设为白色：
我也改变了bar 对象的颜色。下面一行要求bar 将内部填充为绿色（因为它是钱，你
你还可以用setOutline 方法更改形状轮廓的颜色。在这种情况下，我选择让轮廓保持默
认的黑色，这样柱形能彼此分离。为了增强这种效果，以下代码让轮廓更宽（2 像素，而不
你可能还注意到在绘制标签时，对符号的节约使用。由于我们不更改标签，因此不必将它
们赋给变量。我们可以创建一个Text 对象，告诉它绘制自己，然后就完了。下面是一个例子： 
最后，请仔细看看循环中year 变量的使用： 
表达式range(1,11)产生1～10 的整数序列。循环索引变量year 在循环的连续迭代中遍
历该序列。因此，第一次迭代时year 是1，然后是2，然后是3，依此类推，最多到10。year
的值然后用于计算每个柱形左下角的合适位置：
我希望你开始掌握图形编程的窍门。这有点困难，但很容易上瘾。
4.6  选择坐标 
在设计终值图形程序的工作中，大部分的工作是确定控件放在屏幕上的精确坐标。大
多数图形编程问题需要某种“坐标变换”，将来自真实世界问题的值变成窗口坐标，映射到
计算机屏幕上。在我们的示例中，问题域要求x 值表示年份（0～10），y 值和表示货币金额
（0～10000 美元）。我们不得不将这些值转换，展现在320 像素×240 像素的窗口中。通过
一两个例子来看看这种转换如何发生，这很好，但它使得编程变得冗长乏味。
坐标变换是计算机图形学中一个完整的、深入研究过的组成部分。不需要太多的数学
知识就能看到，转换过程总是遵循相同的一般模式。任何遵循模式的事情都可以自动完成。
为了节省在坐标系之间来回显式转换的麻烦，graphics 库提供了一种简单的机制，替你完成。
创建GraphWin 时，可以用setCoords 方法为窗口指定坐标系。该方法需要分别指定左下角
和右上角的坐标的四个参数。然后可以用此坐标系将图形对象放在窗口中。
4.6  选择坐标 
举一个简单的例子，假设我们只是希望将窗口分成九个相等的正方形，像井字游戏那
样。用默认的200 像素×200 像素窗口也没有太多的麻烦，但需要一点算术。如果我们先在
两个维度上将窗口的坐标改为从0 到3，问题就简单了： 
这种方法的另一个好处在于，可以通过简单地改变创建窗口时使用的尺寸来改变窗口
的大小（例如win = GraphWin("Tic-Tac-Toe", 300, 300)）。因为该窗口使用相同的坐标（由于
setCoords），所以对象将适当地缩放到新的窗口大小。使用“原始的”窗口坐标，则需要改
变这些线的定义。
我们可以用这个想法来简化图形终值程序。基本上，我们希望图形窗口在x 维度上从0～
10（代表年），在y 维度上从0～10000（代表美元）。我们可以创建一个这样的窗口： 
然后为任何年份和本金的值创建一个柱形就简单了。每个柱形开始于给定年份，基线
为0，并且增长到下一年，高度等于本金。 
这个方案有一个小问题。你能发现我忘了什么吗？十一个柱形将填充整个窗口，我们
没有在边缘留下任何空间给标签或边距。这很容易修正，只要稍微扩展窗口的坐标。由于
柱形从0 开始，我们可以定位左侧的标签为−1。我们可以让坐标稍微超出图形所需的坐标，
从而在图形周围添加一些空白。通过一个小实验，这个窗口定义如下：
下面再次列出程序，它使用了替代坐标系：
第4 章  对象和图形
请注意，它如何消除了繁琐的坐标计算。此版本也让更改GraphWin 的大小变得容易。
将窗口大小更改为640 像素×480 像素会生成更大但正确绘制的柱形图。在原来的程序中，
必须重新进行所有计算以适应较大窗口中的新缩放因子。
显然，程序的第二个版本更容易开发和理解。进行图形编程时，应考虑选择一个坐标
系，这将使你的任务尽可能简单。
4.7  交互式图形 
图形界面可用于输入和输出。在GUI 环境中，用户通常通过点击按钮，从菜单中选择
菜单项，并在屏幕文本框中键入信息来与应用交互。这些应用程序使用一种称为“事件驱
动”编程的技术。基本上，程序在屏幕上绘制一组界面元素（通常称为“控件”），然后等
如果用户移动鼠标、单击按钮或在键盘上键入一个键，就会生成一个“事件”。基本上，
事件是一个对象，封装了刚刚发生的事情的数据。然后事件对象被发送到程序的适当部分，
进行处理。例如，点击按钮可能产生“按钮事件”。该事件将被传递到按钮处理代码，然后
这段代码将执行按钮对应的适当动作。
事件驱动编程对于新程序员可能有点棘手，因为在任意给定时刻很难弄清楚“谁负责”。
graphics 模块隐藏了底层事件处理机制，并提供了一些在GraphWin 中获取用户输入的简单
4.7  交互式图形 
4.7.1  获取鼠标点击 
我们可以通过GraphWin 类的getMouse 方法从用户获取图形信息。如果在GraphWin 上
调用getMouse，程序将暂停，并等待用户在图形窗口中某处单击鼠标。用户单击的位置作
为一个Point 返回给程序。下面是一段代码，报告十次连续鼠标点击的坐标： 
getMouse()返回的值是一个现成的Point。我们可以像使用任何其他Point 一样使用它，
使用getX 和getY 等取值方法，或draw 和move 等其他方法。 
下面是一个交互式程序的例子，允许用户通过点击图形窗口中的三个点来绘制一个三
角形。该示例完全是图形化的，使用Text 对象作为提示。不需要与Python 文本窗口进行交
互。如果你在Microsoft Windows 环境中编程，可以使用.pyw 扩展名命名此程序。然后在程
序运行时，甚至不会显示Python 的shell 窗口。 
点击三个点绘制三角形展示了graphics 模块的一些新功能。但是，没有三角形类，只有
一个一般类Polygon 可以用于任意封闭的多边形。Polygon 的构造函数接受任意数量的点，
第4 章  对象和图形
用线段按给定顺序连接点，并将最后一个点连接回第一个点，从而创建多边形。三角形就
是有三条边的多边形。一旦我们有了三个Point（p1，p2 和p3），就可以立即创建三角形： 
你还应该学习如何使用Text 对象来提供提示。在接近程序开始处创建并绘制了单个Text
要更改提示，我们不需要创建一个新的Text 对象，可以只改变显示的文本。这在接近
程序结束处用setText 方法实现： 
可以看到，GraphWin 的getMouse 方法提供了一种在面向图形的程序中与用户交互的简
4.7.2  处理文本输入 
在三角形示例中，所有输入都通过鼠标点击提供。通常我们将允许用户通过键盘与图
形窗口进行交互。GraphWin 对象提供了一个getKey()方法，其工作方式非常类似于getMouse
方法。这是一个简单的点击程序的扩展，允许用户在每个鼠标点击后键入一个按键，在窗
请注意循环体中发生了什么。首先，它等待鼠标单击，并将生成的点保存为变量p。然
后程序等待用户在键盘上键入一个键。 被按下的键作为字符串返回，并保存为变量key。
例如，如果用户按下键盘上的g，那么key 将是字符串“g”。点和字符串然后用于创建文本
对象（称为标签），被绘制到窗口中。
你应该尝试这个程序，感受getKey 方法的作用。特别是，查看键入一些比较奇怪的键
（如<Shift>、<Ctrl>或光标移动键）时返回的字符串。 
虽然getKey 方法肯定有用，但它并不是从用户获取任意字符串（例如数字或名称）的非常
实用的方法。幸运的是，图形库提供了一个Entry 对象，允许用户实际输入到GraphWin 中。 
Entry 对象在屏幕上绘制一个可以包含文本的框。它就像Text 对象一样理解setText 和
getText 方法，区别在于用户可以编辑Entry 的内容。下面是来自第2 章的温度转换程序的一
个版本，带有图形用户界面：
4.7  交互式图形 
运行时，会生成一个窗口，其中包含用于输入摄氏温度的输入框和用于执行转换的“按
钮”。按钮只是为了显示。程序实际上只是暂停，等待在窗口中的任何位置点击鼠标。图4.9
展示了程序启动时窗口的样子。
最初，输入框设置为包含值0.0。用户可以删除此值并键入另一个温度。程序暂停，直
到用户单击鼠标。注意，用户点击的点甚至没有保存，getMouse 方法仅用于暂停程序，直
到用户有机会在输入框中输入值。
然后程序用3 个步骤处理输入。首先，输入框中的文本被转换为数字（通过float）。然
后将此数字转换为华氏度。最后，结果数字显示在输出文本区域中。虽然fahrenheit 是一个
float 值，但setText 方法会自动将其转换为字符串，以便在输出文本框中显示。 
图4.10 展示了用户键入输入并点击鼠标后窗口的样子。请注意，转换后的温度显示在
输出区域，按钮上的标签已变更为“Quit”，表示再次单击将退出程序。使用graphics 库中
的一些选项，改变各种控件的颜色、大小和线宽，可以让这个示例变得更漂亮。该程序的
代码有意采用简洁的方式，只展示GUI 设计的基本要素。 
第4 章  对象和图形
     图4.9 图形温度转换器的初始屏幕
图4.10 用户输入后的图形温度转换器 
虽然基本工具getMouse、getKey 和Entry 没有提供一个完整的GUI 环境，但我们将在
后面的章节看到，这些简单的机制是如何支持令人惊讶的丰富交互的。
4.8  graphics 模块参考 
本章中的示例涉及了graphics 模块中的大多数元素。本节提供了graphics 中的对象和功
能的完整参考。由模块提供的对象和函数集有时称为“应用编程接口”或“API”。有经验
的程序员研究API 以了解新库。你也应该读一遍本小节，看看graphics 库提供了什么。 
以后，当你编写自己的图形程序时，可能会经常参考这个部分。
学习API 的最大障碍之一，就是熟悉所使用的各种数据类型。在阅读参考文档时，应
仔细注意各种方法的参数类型和返回值。例如，创建一个圆时，需要提供的第一个参数必
须是一个Point 对象（作为圆心），第二个参数必须是一个数字（半径）。使用不正确的类型
有时会立即得到错误消息，但另外一些时候，问题可能到后来才会突然出现，比如绘制对
象的时候。每个方法描述末尾的示例结合了Python 字面量，来说明参数的适当数据类型。 
4.8.1  GraphWin 对象 
GraphWin 对象表示屏幕上可绘制图形图像的窗口。程序可以定义任意数量的
GraphWins。GraphWin 包含以下方法。 
GraphWin(title, width, height) 构造一个新的图形窗口，用于在屏幕上绘图。参数是可选
的，默认标题为“Graphics Window”，默认大小为200 像素×200 像素。 
示例：win = GraphWin("Investment Growth", 640, 480) 
plot(x, y, color) 在窗口中(x, y)处绘制像素。颜色是可选的，黑色是默认值。 
示例：win.plot(35, 128, "blue") 
plotPixel(x, y, color) 在“原始”位置（x, y）处绘制像素，忽略setCoords 设置的任何坐
示例：win.plotPixel(35, 128, "blue") 
4.8  graphics 模块参考 
setBackground(color)将窗口背景设置为给定的颜色。默认背景颜色取决于系统。有关指
定颜色的信息，请参见第4.8.5 节。 
示例：win.setBackground("white") 
close() 关闭屏幕窗口。 
示例：win.close() 
getMouse() 暂停等待用户在窗口中单击鼠标，并用Point 对象返回鼠标单击的位置。 
示例：clickPoint = win.getMouse() 
checkMouse()与getMouse()类似，但不会暂停等待用户单击。返回鼠标点击的最后一个
点，如果自上次调用checkMouse 或getMouse 后未点击窗口，则返回None
①。这对于控制动
画循环特别有用（参见第8 章）。 
示例：clickPoint = win.checkMouse() 
注意：clickPoint 可能为None。 
getKey() 暂停等待用户在键盘上键入一个键，并返回一个表示被按下键的字符串。 
示例：keyString = win.getKey() 
checkKey()与getKey()类似，但不会暂停等待用户按下一个键。返回被按下的最后一个
键，如果从上一次调用checkKey 或getKey 后没有按下任何键，则返回""。这对于控制简单
的动画循环特别有用（参见第8 章）。 
示例：keyString = win.checkKey() 
注意：keyString 可能是空字符串""。 
setCoords(xll, yll, xur, yur)设置窗口的坐标系。左下角是（xll, yll），右上角是（xur, yur）。
当前绘制的对象被重绘，而后续的绘制将相对于新的坐标系统（除plotPixel 以外）。 
示例：win.setCoords(0，0，200，100) 
4.8.2  图形对象 
该模块提供了类Point、Line、Circle、Oval、Rectangle、Polygon 和Text 的可绘制对象。
最初创建的所有对象都有未填充的黑色轮廓。所有图形对象都支持以下通用的方法集。
setFill(color)将对象的内部设置为给定的颜色。 
示例：someObject.setFill("red") 
setOutline(color) 将对象的轮廓设置为给定的颜色。 
示例：someObject.setOutline("yellow") 
setWidth(pixels) 将对象的轮廓宽度设置为所需的像素数。（不适用于Point。） 
示例：someObject.setWidth(3) 
draw(aGraphWin) 将对象绘制到给定的GraphWin 中并返回绘制对象。 
示例：someObject.draw(someGraphWin) 
undraw() 从图形窗口中擦除对象。如果对象当前未绘制，则不采取任何操作。 
示例：someObject.undraw() 
move(dx,dy) 在x 方向上移动对象dx 单位，在y 方向上移动dy 单位。如果对象当前已
①None 是一个特殊的Python 对象，常用于表示一个变量没有值。我们在第6 章中讨论None。 
第4 章  对象和图形
绘制，则将图像调整到新位置。
示例：someObject.move(10，15.5) 
clone() 返回对象的副本。克隆始终以未绘制状态创建。除此之外，它们与被克隆的对
示例：objectCopy = someObject.clone() 
Point 方法 
Point(x,y) 构造具有给定坐标的点。 
示例：aPoint = Point(3.5, 8) 
getX() 返回点的x 坐标。 
示例：xValue = aPoint.getX() 
getY() 返回点的y 坐标。 
示例：yValue = aPoint.getY() 
Line(point1, point2) 构造从point1 到point2 的线段。 
示例：aLine = Line(Point(1,3), Point(7,4)) 
setArrow(endString) 设置线段的箭头状态。箭头可以在第一端点、最后端点或两个端点
上绘制。endString 的可能值为"first"、"last"、"both"和"none"。默认设置为"none"。 
示例：aLine.setArrow("both") 
getCenter() 返回线段中点的克隆。 
示例：midPoint = aLine.getCenter() 
getP1()、getP2() 返回线段的对应端点的克隆。 
示例：startPoint = aLine.getP1() 
Circle 方法 
Circle(centerPoint, radius)构造具有给定圆心和半径的圆。 
示例：a Circle = Circle(Point(3,4), 10.5) 
getCenter() 返回圆心的克隆。 
示例：centerPoint = aCircle.getCenter() 
getRadius() 返回圆的半径。 
示例：radius = aCircle.getRadius() 
getP1()，getP2()返回圆的边界框的对应角落的克隆。它们是围绕圆的正方形的对角点。 
示例：cornerPoint = aCircle.getP1() 
Rectangle 方法 
Rectangle(point1, point2) 构造一个对角点在point1 和point2 的矩形。 
示例：aRectangle = Rectangle(Point(1,3), Point(4,7)) 
getCenter() 返回矩形中心点的克隆。 
4.8  graphics 模块参考 
示例：centerPoint = aRectangle.getCenter() 
getP1()、getP2() 返回用于构造矩形的对应点的克隆。 
示例：cornerPoint = aRectangle.getP1() 
Oval(point1, point2) 在由point1 和point2 确定的边界框中构造一个椭圆。 
示例：anOval = Oval(Point(1,2), Point(3,4)) 
getCenter() 返回椭圆形中心点的克隆。 
示例：centerPoint = anOval.getCenter() 
getP1()、getP2() 返回用于构造椭圆的对应点的克隆。 
示例：cornerPoint = anOval.getP1() 
Polygon 方法 
Polygon(point1, point2, point3, ...) 构造一个以给定点为顶点的多边形。也接受单个参数，
示例：aPolygon = Polygon(Point(1,2), Point(3,4), Point(5,6)) 
示例：aPolygon = Polygon([Point(1,2), Point(3,4), Point(5,6)]) 
getPoints() 返回一个列表，包含用于构造多边形的点的克隆。 
示例：pointList = aPolygon.getPoints() 
Text(anchorPoint, textString) 构造一个文本对象，显示以anchorPoint 为中心的文本字符
串。文本水平显示。
示例：message = Text(Point(3,4), "Hello!") 
setText(string) 将对象的文本设置为字符串。 
示例：message.setText("Goodbye!") 
getText() 返回当前字符串。 
示例：msgString = message.getText() 
getAnchor() 返回锚点的克隆。 
示例：centerPoint = message.getAnchor() 
setFace(family) 将字体更改为给定的系列。可能的值是"helvetica"、"courier"、"times 
roman"和"arial"。 
示例：message.setFace("arial") 
setSize(point) 将字体大小更改为给定的点大小。从5 点到36 点是合法的。 
示例：message.setSize(18) 
setStyle(style) 将字体更改为给定的样式。可能的值有"normal"、"bold"、"italic"和"bold 
italic"。 
示例：message.setStyle("bold") 
setTextColor(color) 将文本的颜色设置为彩色。注意：setFill 有同样的效果。 
第4 章  对象和图形
示例：message.setTextColor("pink") 
4.8.3  Entry 对象 
Entry 类型的对象显示为一个文本输入框，可由程序的用户编辑。Entry 对象支持通用
的图形方法move()、draw(graphwin)、undraw()、setFill(color)和clone()。Entry 特有的方法
Entry(centerPoint, width) 构造具有给定中心点和宽度的Entry。宽度用可显示的文本字
示例：inputBox = Entry(Point(3,4), 5) 
getAnchor() 返回输入框居中点的克隆。 
示例：centerPoint = inputBox.getAnchor() 
getText() 返回当前在输入框中的文本字符串。 
示例：inputStr = inputBox.getText() 
setText(string) 将输入框中的文本设置为给定字符串。 
示例：inputBox.setText("32.0") 
setFace(family) 将字体更改为给定的系列。可能的值是"helvetica"、"courier"、"times 
roman"和"arial"。 
示例：inputBox.setFace("courier") 
setSize(point) 将字体大小更改为给定的点大小。从5 点到36 点是合法的。 
示例：inputBox.setSize(12) 
setStyle(style) 将字体更改为给定的样式。可能的值有"normal"、"bold"、"italic"和"bold 
italic"。 
示例：inputBox.setStyle("italic") 
setTextColor(color) 设置文本的颜色。 
示例：inputBox.setTextColor("green") 
4.8.4  显示图像 
graphics 模块还提供了在GraphWin 中显示和操作图像的最小支持。大多数平台至少支
持PPM 和GIF 图像。显示是使用Image 对象完成的。图像支持通用方法move(dx,dy)、
draw(graphwin)、undraw()和clone()。Image 特有的方法如下。 
Image(anchorPoint, filename) 利用给定文件的内容构造图像，以给定锚点为中心。也可
以使用width 和height 参数而不是filename 来调用。在这种情况下，将创建给定宽度和高度
（以像素为单位）的空白（透明）图像。
示例：flowerImage = Image(Point(100,100), "flower.gif") 
示例：blankImage = Image(320, 240) 
getAnchor() 返回图像居中点的克隆。 
示例：centerPoint = flowerImage.getAnchor() 
getWidth() 返回图像的宽度。 
4.8  graphics 模块参考 
示例：widthInPixels = flowerImage.getWidth() 
getHeight() 返回图像的高度。 
示例：heightInPixels = flowerImage.getHeight() 
getPixel(x, y) 返回位置（x，y）处的像素的RGB 值的列表[红，绿，蓝]。每个值都是0～
255 范围内的数字，表示相应RGB 颜色的强度。这些数字可以用color_rgb 函数转换为颜色
字符串（参见下一节）。注意，像素位置是相对于图像本身的，而不是绘制图像的窗口。图
像的左上角始终是像素（0,0）。 
示例：red，green，blue = flowerImage.getPixel(32,18) 
setPixel(x, y, color) 将位置（x,y）处的像素设置为给定颜色。 
注意：这是一个缓慢的操作。
示例：flowerImage.setPixel(32, 18, "blue") 
save(filename) 将图像保存为文件。所得文件的类型（如GIF 或PPM）由文件名的扩展
示例：flowerImage.save("mypic.ppm") 
4.8.5  生成颜色 
颜色由字符串表示。最常见的颜色，如"red"、"purple"、"green"、"cyan"等，应该直接
可用。许多颜色具有各种色调，例如"red1"、"red2"、"red3"、"red4"，这是越来越暗的红色。
关于完整列表，可在网络上查找X11 颜色名称。 
grahpics 模块还提供了一个函数，以数字方式混合你自己的颜色。函数color_rgb(red, 
green, blue)将返回一个表示颜色的字符串，该颜色是指定的红色、绿色和蓝色的强度的混合。
它们应该是在0～255 范围内的int。因此，color_rgb(255, 0, 0)是亮红色，而color_rgb(130, 0, 
130)是中等品红色。
示例：aCircle.setFill(color rgb(130, 0, 130))
4.8.6  控制显示更新（高级）
通常，每当任何图形对象的可见状态以某种方式改变时，GraphWin 的可视显示就会更
新。然而，在某些情况下，例如在一些交互式shell 中使用graphics 库时，可能需要强制窗
口更新以便看到改变。update()函数用于执行此操作。 
update() 导致所有挂起的图形操作得到执行，并显示结果。 
出于效率的原因，有时期望关闭每当一个对象改变时窗口所进行的自动更新。例
如，在动画中，你可能需要在显示动画的下一“帧”之前更改多个对象的外观。GraphWin
构造函数包括了一个名为autoflush 的特殊额外参数，用于控制这种自动更新。默认情
况下，创建窗口时，自动更新将打开。要关闭它，autoflush 参数应该设置为False，像
现在对win 中对象的更改只会在图形系统有一些空闲时间或者通过调用update()强制更
第4 章  对象和图形
update()方法还接受一个可选参数，指定可以进行更新的最大速率（每秒）。这对于以独
立于硬件的方式控制动画的速度是有用的。例如，将命令update(30)放置在循环的底部，确
保循环将每秒“回转”最多30 次。update 命令将每次插入一个适当的暂停，以保持相对恒
定的速率。当然，只在循环本身的执行少于1/30 秒时，速率调节才起作用。 
示例：1000 帧，每秒30 帧 
本章介绍了计算机图形学和基于对象的编程。下面是一些重要概念的摘要。
对象是结合了数据和操作的计算实体。对象知道一些信息，可以执行一些操作。
对象的数据存储在实例变量中，其操作称为方法。
每个对象都是某个类的实例。类确定对象将具有什么方法。通过调用构造函数方
对象的属性通过点符号访问。通常，通过调用对象的方法来执行对象的计算。取
值方法返回有关对象的实例变量的信息。设置方法更改实例变量的值。
  本书提供的graphics 模块提供了许多对图形编程有用的类。GraphWin 表示用于显
示图形的屏幕上的窗口的对象。Point、Line、Circle、Rectangle、Oval、Polygon
和Text等各种图形对象可以在GraphWin中绘制。用户可以通过单击鼠标或在Entry
框中输入，与GraphWin 进行交互。 
  图形编程中的一个重要考虑是选择适当的坐标系。graphics 库提供了自动化某些坐
  两个变量引用同一对象的情况称为别名。别名有时会导致意外的结果。在图形库
中使用克隆方法有助于防止这些情况出现。
4.10  练习 
1．利用graphics.py 可以在Python 的shell 窗口中绘制图形。 
2．传统上，图形窗口的左上角坐标为（0,0）。 
4.10  练习 
3．图形屏幕上的单个点称为像素。 
4．创建类的新实例的函数称为取值方法。 
5．实例变量用于在对象内存储数据。 
6．语句myShape.move(10,20)将myShape 移动到点（10,20）。 
7．如果两个变量引用同一个对象，就产生了别名。 
8．提供copy 方法是用于生成图形对象的副本。 
9．图形窗口的标题总是“Graphics Window”。 
10．graphics 库中，用于获取鼠标点击的方法是readMouse。 
1．返回对象的实例变量的值的方法称为
2．改变对象状态的方法称为
图形类最适合绘制一个正方形。
a．Square  
b．Polygon 
d．Rectangle 
命令会将win 的坐标设置变为左下角是（0,0），右上角是（10,10）。 
a．win.setCoords(Point(0,0), Point(10,10))
b．win.setCoords((0,0), (10,10))
c．win.setCoords(0, 0, 10, 10)
d．win.setCoords(Point(10,10), Point(0,0))
将创建从（2,3）到（4,5）的线段。 
a．Line(2, 3, 4, 5)
b．Line((2,3), (4,5))
c．Line(2, 4, 3, 5)
d．Line(Point(2,3), Point(4,5))
可以将图形对象shape 绘制到图形窗口win 中。 
a．win.draw(shape) 
b．win.show(shape)
c．shape.draw()
d．shape.draw(win)
计算点p1 和p2 之间的水平距离。 
a．abs(p1-p2)
b．p2.getX() - p1.getX()
c．abs(p1.getY() - p2.getY())
d．abs(p1.getX() - p2.getX())
可以用来在图形窗口中获取文本输入。
d．Keyboard 
9．围绕视觉元素和用户动作组织的用户界面被称为
b．application  
c．windower  
10．color_rgb(0,255,255)是
第4 章  对象和图形
1．选择一个有趣的现实世界对象的例子，通过列出它的数据（属性，它“知道什么”）
及方法（行为，它可以“做什么”），将它描述为一个编程对象。
2．用你自己的话描述graphics 模块的下列操作产生的每个对象，尽可能精确。务必描
述各种对象的大小、位置和外观等。如果需要，可以画草图。
a．Point(130,130)
b．c = Circle(Point(30,40),25)
c．r = Rectangle(Point(20,20), Point(40,40))
d．l = Line(Point(100,100), Point(100,200))
e．Oval(Point(50,50), Point(60,100))
f．shape = Polygon(Point(5,5), Point(10,10), Point(5,10), Point(10,5))
g．t = Text(Point(100,100), "Hello World!")
3．描述以下交互式图形程序运行时会发生什么： 
1．修改上一个讨论问题的程序，做到： 
a．使它绘制正方形而不是圆。 
4.10  练习 
b．每次连续点击在屏幕上绘制一个额外的方块（而不是移动已有的方块）。 
c．循环之后在窗口上打印消息“Click again to quit”，等待最后一次点击，然后关闭窗口。 
2．箭靶的中心圆为黄色，围绕着红色、蓝色、黑色和白色的同心环。每个环具有相同
的宽度，与黄色圆的半径相同。编写一个绘制这种箭靶的程序。（提示：稍后绘制的对象将
出现在先前绘制的对象的上面。）
3．编写一个绘制某种面孔的程序。 
4．编写一个用圣诞树和雪人绘制冬季场景的程序。 
5．编写一个程序，在屏幕上绘制5 个骰子，是一把顺子（1,2,3,4,5 或2,3,4,5,6）。 
6．修改图形终值程序，让输入（本金和APR）也用Entry 对象以图形方式完成。 
编写一个计算圆与水平线的交点的程序，并以文本和图形方式显示信息。
输入：圆的半径和线的y 截距。 
输出：在坐标为从（−10，−10）到（10,10）的窗口中，以(0, 0)为中心,以给定半径绘制
用给定的y 轴截取一根水平线穿过窗口。 
以红色绘制两个交点。
打印出交叉点的x 值。 
该程序允许用户绘制线段，然后显示关于线段的一些图形和文本信息。
输入：两次鼠标点击线段的终点。
输出：以青色绘制线段的中点。
打印线的长度和斜率。
dx = x2 – x1 
dy = y2 – y1 
此程序显示有关用户绘制的矩形的信息。
输入：两次鼠标点击作为矩形的对角。
输出：绘制矩形。
打印矩形的周长和面积。
公式：面积=（长度）（宽度） 
周长= 2（长度+宽度） 
10．三角形信息。 
与上一个问题相同，但三角形的顶点有三次点击。
公式：关于周长，可参阅线段问题中的长度。
第4 章  对象和图形
，其中a、b、c 是边长，
11．五次点击的房子。 
编写一个程序，允许用户通过五次鼠标点击，绘制一个简单的房子。前两次点击是房
子的矩形框架的对角。第三次点击指出矩形门的顶部边缘的中心。门的宽度应为房屋框架
宽度的1/5。门的边框应从顶部的转角延伸到框架的底部。第四次点击指出正方形窗口的中
心。窗口的宽度是门的一半。最后一次点击指出屋顶的顶点。屋顶的边缘将从顶点延伸到
房屋框架的顶部边缘的转角。
了解字符串数据类型以及如何在计算机中表示字符串。
熟悉通过内置函数和字符串方法对字符串执行的各种操作。
  理解序列和索引的基本概念，因为它们适用于Python 的字符串和列表。 
能够用字符串格式化来产生有吸引力的、富含信息的程序输出。
  了解在Python 中读取和写入文本文件的基本文件处理概念和技术。 
了解加密的基本概念。
理解和编写处理文本信息的程序。
5.1  字符串数据类型 
到目前为止，我们一直在讨论用于操作数字和图形的程序。但你知道，计算机对于存
储和操作文本信息也很重要。事实上，个人计算机最常见的用途之一就是文字处理。本章
关注文本应用程序，介绍一些关于文本如何存储在计算机上的重要思想。你可能不觉得基
于文字的应用程序令人兴奋，但你很快会看到，这里提到的基本思想几乎应用于所有计算
领域，也支撑着万维网。
文本在程序中由字符串数据类型表示。你可以将字符串视为一个字符序列。在第2 章
中你已了解到，通过用引号将一些字符括起来形成字符串字面量。Python 还允许字符串由
单引号（撇号）分隔。它们没有区别，但用时一定要配对。字符串也可以保存在变量中，
像其他数据一样。下面有一些例子，说明了两种形式的字符串字面量：
你已经知道如何打印字符串。你也看到了如何从用户获取字符串输入。回想一下，input
函数返回用户键入的任何字符串对象。这意味着如果你希望得到一个字符串，可以使用其
“原始”（未转换）形式的输入。下面的简单交互说明了这一点：
第5 章  序列：字符串、列表和文件
请注意，我们如何用变量来保存用户名称，然后用该变量将名称打印出来。
到目前为止，我们已经看到了如何获取字符串作为输入，将它们分配给变量，以及如
何将它们打印出来。这足以写一个鹦鹉学舌式的程序，但不能做任何严肃的基于文本的计
算。因此，我们需要一些字符串操作。本节的其余部分将带你了解更重要的Python 字符串
操作。在下一节中，我们会在一些示例程序中，将这些想法付诸实践。
我们可以用字符串做怎样的事？对于初学者，要记住一个字符串是什么：一个字符序
列。我们可能希望做的一件事是访问组成字符串的单个字符。在Python 中，这可以通过“索
引”操作来完成。我们可以认为字符串中的位置被编号，从左边开始为0。图5.1 用字符串
"Hello Bob"加以说明。索引在字符串表达式中用于访问字符串中的特定字符位置。索引的一
般形式是<string> [<expr>]。表达式的值确定从字符串中选择哪个字符。 
图5.1 字符串"Hello Bob"的索引 
以下是一些交互式的索引示例：
请注意，在n 个字符的字符串中，最后一个字符位于位置n−1，因为索引从0 开始。现
在也许应该提醒你，字符串对象与实际打印输出之间的差异。在上面的交互中，Python shell
通过将字符串的值放在单引号中来显示值，这是Python 的沟通方式，告诉我们正在看一个
字符串对象。实际打印字符串时，Python 不会在字符序列周围添加任何引号。我们只是得
到包含在字符串中的文本。
顺便说一下，Python 还允许使用负索引，从字符串的右端索引。 
这对于获取字符串的最后一个字符特别有用。
索引返回包含较大字符串中单个字符的字符串。也可以从字符串中访问连续的字符序
列或“子字符串”。在Python 中，这是通过一个名为“切片”的操作来实现的。你可以把切
片想象成在字符串中索引一系列位置的方法。切片的形式是<string> [<start>：<end>]。start
和end 都应该是int 值表达式。切片产生从start 直到（但不包括）end 位置给出的子串。 
5.1  字符串数据类型 
继续我们的交互示例，下面是一些切片：
最后三个示例表明，如果任何一个表达式缺失，字符串的开始和结束都是假定的默认
值。最后的表达式实际上给出整个字符串。
索引和切片是将字符串切成更小片段的有用操作。字符串数据类型还支持将字符串放
在一起的操作。连接（+）和重复（*）是两个方便的运算符。连接通过将两个字符串“粘
合”在一起来构建字符串；重复通过字符串与多个自身连接，来构建字符串。另一个有用
的函数是len，它告诉你字符串中有多少个字符。最后，由于字符串是字符序列，因此可以
使用Python 的for 循环遍历这些字符。 
以下是各种字符串操作的一些示例：
基本的字符串操作总结在表5.1 中。 
Python 字符串操作 
第5 章  序列：字符串、列表和文件
5.2  简单字符串处理 
既然明白了各种字符串操作可以做什么，那我们就准备好编写一些程序了。我们的第
一个例子是计算一个计算机系统的用户名的程序。
许多计算机系统使用用户名和密码组合来认证系统用户。系统管理员必须为每个用户
分配唯一的用户名。通常，用户名来自用户的实际姓名。一种用于生成用户名的方案是使
用用户的第一个首字母，然后是用户姓氏的最多七个字母。利用这种方法，Zaphod Beeblebrox
的用户名将是“zbeebleb”，而John Smith 就是“jsmith”。 
我们希望编写一个程序，读取一个人的名字并计算相应的用户名。我们的程序将遵循
基本的输入、处理、输出模式。为简洁起见，我将跳过对算法开发的讨论，并跳到代码。
算法的概要作为注释包含在最终程序中。
这个程序首先利用input 从用户获取字符串，然后组合使用索引、切片和连接来生成用
户名。下面是运行示例：
你知道介绍和名字的提示之间的空白行是从哪里来的吗？在第一个print 语句中将换行
符（\n）放在字符串的末尾，这导致输出跳过一个额外的行。这是一个简单的技巧，输出一
些额外的空白，更好看一些。
下面是另一个问题，我们可以用字符串操作解决。假设要打印给定月份数对应的月份
缩写。程序的输入是一个int，代表一个月份（1～12），输出是相应月份的缩写。例如，如
果输入为3，则输出应为Mar，即3 月。 
初看，这个程序似乎超出了你目前的能力。经验丰富的程序员明白，这是一个判断问
题。也就是说，我们必须根据用户给出的数字，决定12 种不同输出中哪一种合适。我们以
后再介绍判断结构。但是，我们可以通过一些巧妙的字符串切片来编写程序。
5.2  简单字符串处理 
基本思想是将所有月份名称存储在一个大字符串中：
我们可以通过切出适当的子字符串来查找特定的月份，诀窍是计算在哪里切片。由于
每个月由三个字母表示，如果知道一个给定的月份在字符串中开始的位置，就可以很容易
这将获得从pos 指示位置开始的长度为3 的子串。 
如何计算这个位置？让我们试试几个例子（如表5.2 所列），看看有什么发现。记住，
字符串索引从0 开始。 
月份缩写字符串中的位置关系 
当然，这些位置都是3 的倍数。为了得到正确的倍数，我们从月数中减去1，然后乘以
3。所以对于1，我们得到（1−1）* 3 = 0 * 3 = 0，对于12，我们有（12−1）* 3 = 11 * 3 = 33。 
现在我们准备好对程序进行编码了。同样，最终结果又短又好。注释记录了我们开发
请注意，该程序的最后一行利用字符串连接，将句点放在月份缩写的末尾。
下面是程序输出的示例：
这个例子使用“字符串作为查找表”方法，它有一个弱点，即仅当子串都有相同的长
度（在本例中，是3）时才有效。假设我们希望编写一个程序，输出给定数字的完整月份名
第5 章  序列：字符串、列表和文件
称，该如何实现呢？
5.3  列表作为序列 
严格地说，表5.1 中的操作实际上并不是字符串操作。它们是应用于序列的操作。正如
你从第2 章的讨论中知道的，Python 列表也是一种序列。这意味着我们也可以索引、切片
和连接列表，如下面的会话所示：
列表的一个好处是它们比字符串更通用。字符串总是字符序列，而列表可以是任意对
象的序列。你可以创建数字列表或字符串列表。事实上，你甚至可以混合它们，创建一个
包含数字和字符串的列表：
在后面的章节中，我们将把所有的东西放到列表中，如点、矩形、骰子、按钮甚至学生！ 
使用字符串列表，我们可以重写上一节中的月份缩写程序，使其更简单：
关于这个程序，应该注意几点。我创建了一个名为months 的字符串列表作为查找表。
创建列表的代码分为两行。通常，Python 语句写在一行上，但在这种情况下Python 知道列
表没有结束，直到遇到结束括号“]”。将这条语句分成两行让代码更可读。 
列表就像字符串一样，从0 开始索引，因此在此列表中，值[0]是字符串“Jan”。一般
来说，第n 个月在位置n−1。因为这个计算很简单，我甚至不打算把它作为一个单独的步骤，
而是在print 语句中直接用表达式months[n−1]。 
这个缩写问题的解决方案不仅更简单，而且更灵活。例如，改变程序以便打印出整个
月份的名称会很容易。我们只需要重新定义查找列表。
5.4  字符串表示和消息编码 
虽然字符串和列表都是序列，但两者之间有一个重要的区别。列表是可变的。这意味
着列表中项的值可以使用赋值语句修改。另一方面，字符串不能在“适当位置”改变。下
面是一个示例交互，说明了区别：
第一行创建了一个包含4 个数字的列表。索引位置2 返回值15（同样，索引从0 开始）。
下一个命令将值0 赋给位置2 中的项目。赋值后，对列表求值显示新值已替换旧值。在字
符串上尝试类似的操作会产生错误。字符串不可变，但列表可以变。
5.4  字符串表示和消息编码 
5.4.1  字符串表示 
希望你已经开始掌握文本（字符串）数据计算的窍门。但是，我们还没有讨论计算机
实际如何操作字符串。在第3 章，你看到数字以二进制符号（0 和1 组成的序列）存储。计
算机CPU 包含用这种表示进行运算的电路。文本信息以完全相同的方式表示。在底层，计
算机操作文本时，与数字运算真的没有什么不同。
要理解这一点，你可以想想消息和密码。请考虑“老年小学困境”。你坐在课堂上，希
望把一张纸条传给房间里的一个朋友。不幸的是，纸条在到达最终目的地之前，必须经过
许多同学的手以及许多好奇的眼睛。而且，当然总有这样的风险，纸条可能落入敌人（老
师）之手。所以你和你的朋友需要设计一个方案来编码消息的内容。
一种方法是简单地将消息转换为数字序列。你可以选择一个数字对应于字母表中的每
个字母，并用数字代替字母。不需要太多想象力，你可能用数字1～26 来表示字母a～z。
“sourpuss”这个词，你会写成“18，14，20，17，15，20，18，18”。对于那些不知道代码
的人，这看起来像一个无意义的数字串。但对于你和你的朋友，它代表一个词。
这就是计算机表示字符串的方式。每个字符都被翻译成一个数字，整个字符串作为（二
进制）数字序列存储在计算机存储器中。只要计算机的编码/解码过程一致，用什么数字表
示任何给定字符并不重要。在计算的早期，不同的设计者和制造商使用不同的编码。你可
第5 章  序列：字符串、列表和文件
以想象，人们在不同系统之间传输数据时，有多头痛。
请考虑一种情况，如果PC 和Macintosh 计算机各自使用自己的编码，会有什么结果。
如果在PC上键入学期论文并将它另存为文本文件，论文中的字符将表示为特定的数字序列。
然后，如果文件被读入你的老师的Macintosh 计算机，数字在屏幕上显示时，与你键入的字
符不同。结果会乱七八糟！
为了避免这种问题，今天的计算机系统使用工业标准编码。一个重要的标准名为ASCII
（美国信息交换标准代码）。ASCII 用数字0～127 来表示通常（美国）计算机键盘上有的字
符以及被称为控制代码的某些特殊值，用于协调信息的发送和接收。例如，大写字母A～Z
由值65～90 表示，小写字母的代码为97～122。 
ASCII 编码的一个问题，顾名思义，就是它是以美国为中心的。它没有许多其他语言需
要的符号。国际标准组织已经开发了扩展ASCII 编码来纠正这种情况。大多数现代系统正
在向Unicode 转移，这是一个更大的标准，旨在包括几乎所有书面语言的字符。Python 字符
串支持Unicode 标准，因此，只要你的操作系统有适当的字体来显示字符，就可以处理来自
任何语言的字符。
Python 提供了几个内置函数，允许我们在字符和字符串中表示它们的数字值之间来回切
换。ord 函数返回单字符串的数字（“ordinal”）编码，而chr 相反。下面是一些交互的例子： 
如果仔细阅读，你可能会注意到这些结果与我上面提到的字符的ASCII 编码一致。按
照设计，Unicode 使用的相应代码与ASCII 最初定义127 个字符的相同。但Unicode 还包括
更多的异国字符。例如，希腊字母pi 是字符960，欧元的符号是字符8364。 
在计算机存储器中如何存储字符的谜题中，还有一个部分。正如你从第3 章了解的，
底层CPU 处理固定大小的内存。最小可寻址段通常为8 位，称为存储器字节。单个字节可
以存储28 = 256 个不同的值。这足以代表每个可能的ASCII 字符（事实上，ASCII 只是一个
7 位的代码）。但是单个字节远远不足以存储所有10 万个可能的Unicode 字符。为了解决这
个问题，Unicode 标准定义了将Unicode 字符打包成字节序列的各种编码方案。最常见的编
码称为UTF-8。UTF-8 是一种可变长度编码方案，用单个字节存储ASCII 子集中的字符，
但可能需要最多四个字节来表示一些更为深奥的字符。这意味着长度为10 个字符的字符串
最终将以10～40 个字节的序列存储在内存中，具体取决于字符串中使用的实际字符。然而，
作为拉丁字母（通常的西方字符）的经验法则，估计字符平均需要大约一个字节的存储是
5.4.2  编写编码器 
让我们回到传纸条的例子。利用Python 的ord 和chr 函数，我们可以编写一些简单的程
序，将消息转换为数字序列的过程自动化，再转换回来。用于编码消息的算法很简单：
5.5  字符串方法 
从用户处获得消息很容易，一个input 就行了。 
实现循环需要更多工作。我们需要针对消息的每个字符做一些事情。回想一下，for 循
环遍历一系列对象。由于字符串是一种序列，我们可以用for 循环遍历消息的所有字符： 
最后，我们需要将每个字符转换为数字。最简单的方法是对消息中的每个字符采用
Unicode 数字（由ord 提供）。 
下面是编码消息的最终程序：
我们可以用程序来编码重要的消息，像这样：
关于这个结果，有一个问题要注意：即使空格字符也有相应的Unicode 编码。它由值32 表示。 
5.5  字符串方法 
5.5.1  编写解码器 
既然我们有了一个程序将消息转换为数字序列，那么如果我们的朋友在另一端有一个
第5 章  序列：字符串、列表和文件
类似的程序，将数字转回为可读的消息，那就好了。让我们来解决这个问题。我们的解码
器程序将提示用户输入一系列Unicode 数字，然后打印出带有相应字符的文本消息。这个程
序给我们带来了几个挑战，我们将一起解决这些问题。
解码器程序的总体轮廓看起来与编码器程序非常类似。一个结构上的变化是解码版本
将在字符串中收集消息的字符，并在程序结束时打印出整条消息。为此，我们需要用一个
累积器变量，即我们在第3 章的阶乘程序中看到的模式。下面是解码算法： 
在循环之前，累加器变量消息被初始化为空字符串，即不包含字符的字符串（""）。每
次通过循环，来自输入的数字被转换为适当的字符，并附加到之前构造的消息末尾。
算法看起来很简单，但即使第一步也向我们提出一个问题：如何得到要解码的数字序
列？我们甚至不知道会有多少数字。为了解决这个问题，我们将依靠更多的字符串操作。
首先，我们利用输入将整个数字序列读入为单个字符串。其次，我们将大字符串拆分为一
系列较小的字符串，每个字符串代表一个数字。最后，我们可以遍历更小的字符串列表，将每
个字符串转换为一个数字，并使用该数字来产生相应的Unicode 字符。下面是完整的算法： 
这看起来很复杂，但Python 提供了一些函数，正是我们需要的。 
你可能已经注意到，我一直在谈论字符串对象。记得在前一章开始，对象有数据和操作（它
们“知道一些事情”并“做一些事情”）。由于是对象，除了我们前面使用的通用序列操作之外，
字符串还有一些内置的方法。我们将使用其中一些能力来解决我们的解码器问题。
对于解码器，我们将使用split 方法。此方法将字符串拆分为子串列表。默认情况下，
它会在遇到空格时拆分字符串。下面是一个例子：
当然，调用split 操作按惯例使用点符号，即调用对象的一个方法。在结果中，你可以
看到split 如何将原始字符串"Hello, string methods!"转换为"Hello,"、"string"和"methods!"三个
顺便说一下，通过提供要拆分的字符作为参数，split 可以在空格之外的其他地方拆分
字符串。例如，如果有一个逗号分隔的数字串，我们可以按逗号拆分：
如果希望不用eval 而从用户获取多个输入，这非常有用。例如，我们可以获取单个输
5.5  字符串方法 
入字符串中的一个点的x 和y 值，使用split 方法将其转换为列表，然后索引得到的列表，
获取单个字符串部分，像下面这样：
当然，我们仍然需要将这些字符串转换为相应的数字。回想一下第3 章，我们可以用
类型转换函数int 和float 将字符串转换为适当的数字类型。在这个例子中，我们使用float
并将这一切合并成两行代码：
回到解码器，我们可以使用类似的技术。由于我们的程序应该接受编码器程序产生的
相同格式，即一系列具有空格的Unicode 数字，所以默认版本的split 工作得很好： 
同样，结果不是数字列表，而是字符串列表。只是碰巧这些字符串只包含数字，“可以”
解释为数字。在这个例子中，这些字符串是int 字面量，因此我们将int 函数应用于每一个
字符串，将其转换为数字。
使用split 和int，我们可以编写解码器程序： 
稍微研究下这个程序，你应该能够了解它是如何完成它的任务的。程序的核心是循环： 
split 方法生成（子）字符串的列表，numStr 接受列表中的每个连续字符串。我将循环变
第5 章  序列：字符串、列表和文件
量称为numStr，强调它的值是一个数字串，表示一些数字。每次通过循环，下一个子字符串
被转换为一个数字。此数字通过chr 转换为相应的Unicode 字符，并附加到累积器message 的
末尾。循环完成时，inString 中的每个数字都得到处理，message 包含了解码的文本。 
下面是该程序执行的示例：
5.5.2  更多字符串方法 
现在我们有两个程序，可以编码和解码消息，即Unicode 值的序列。由于Python 的字
符串数据类型以及内置的序列操作和字符串方法的强大，这些程序变得相当简单。
要编写操作文本数据的程序，Python 是很好的语言。表5.3 列出了一些其他有用的字符
串方法。了解这些操作的好方法是交互地尝试。
只有第一个字符大写的s 的副本 
在给定宽度的字段中居中的s 的副本 
计算s 中sub 的出现次数 
找到sub 出现在s 中的第一个位置 
将列表连接到字符串中，使用s 作为分隔符 
类似center，但s 是左对齐 
所有字符小写的s 的副本 
删除前导空格的副本
使用newsub 替换s 中的所有出现的oldsub 
类似find，但返回最右边的位置 
类似center，但s 是右对齐 
删除尾部空格的s 的副本 
将s 分割成子字符串列表 
s 的每个单词的第一个字符大写的副本 
所有字符都转换为大写的s 的副本 
5.6  列表也有方法 
我应该指出，许多这些方法，如split，可以接受其他一些参数，从而定制它们的操作。
Python 还有一些其他标准库文本处理，这里没有介绍。你可以参考在线文档或Python 参考
文档，了解更多信息。
5.6  列表也有方法 
在上一节中，我们看到了一些操纵字符串对象的方法。像字符串一样，列表也是对象，
并且带有自己的一组“额外”操作。由于本章主要涉及文本处理，因此我们将在后面章节
中详细讨论各种列表方法。但是，我希望在这里介绍一个重要的列表方法，只是为了让你
append 方法可以在列表末尾添加一项。这通常用于每次一项地构建列表。下面是一段
代码，创建了前100 个自然数的平方的列表： 
在这个例子中，我们从空列表（[]）开始，每个从1～100 的数字计算平方并附加到列
表中。循环完成时，squares 将是列表[1,4,9，……，10000]。这实际上就是累积器模式在发
挥作用，这次与我们的累积值是一个列表。
使用append 方法，我们可以回头看看小解码器程序的替代方法。之前的程序使用字
符串变量作为解码输出消息的累积器。语句message = message + chr(codeNum)本质上创
建了到目前为止的完整的message 副本，并在一端再加一个字符。我们建立消息时，不
断重复复制一个越来越长的字符串，只是为了在末尾添加一个新的字符。在旧版本的
Python 中，字符串连接可能是一个缓慢的操作，而程序员经常使用其他技术来累积一个
避免不断重复复制消息的一种方法是使用列表。消息可以作为字符列表来累积，其中
每个新字符附加到已有列表的末尾。记住，列表是可变的，所以在列表的末尾添加将“当
第5 章  序列：字符串、列表和文件
场”改变列表，而不必将已有内容复制到一个新的对象中
①。一旦我们累积了列表中的所有
字符，就可以用join 操作将这些字符一下子连接成一个字符串。 
下面是使用这种方法的解码器：
在这段代码中，我们将字符附加到名为chars 的列表中，从而收集字符。最终消息是通
过用空字符串作为分隔符将这些字符连接在一起获得的。因此，原始字符连接在一起，之
间没有任何额外的空格。
字符串连接和append/join 技术在现代Python 中是相当高效的，它们之间的选择在很大
程度上是一个品味的问题。列表技术更灵活一些，因为如果需要的话，连接方法可以容易
地在连接项之间使用特殊分隔符（如制表符、逗号或空格）来构建字符串。
5.7  从编码到加密 
我们已经了解了计算机如何将字符串表示为一种编码问题。字符串中的每个字符由一
个数字表示，该数字作为二进制表示存储在计算机中。你应该意识到，这个代码根本没有
什么真正的秘密。事实上，我们只是简单地使用字符到数字的行业标准映射。任何有一点
计算机科学知识的人都能轻易破解我们的代码。
为了保密或秘密传输而对信息进行编码的过程称为“加密”。加密方法的研究是一个日
益重要的数学和计算机科学子领域，称为“密码学”。例如，如果你在互联网上购物，重要
的是你的个人信息（如你的姓名和信用卡号码）采用安全的编码来传输，防止网络上潜在
我们的简单编码/解码程序使用非常弱的加密形式，称为“替换密码”。原始消息的每个
字符（称为“明文”）被来自“密码字母表”的相应符号（在我们的例子中是数字）替换。
①实际上，如果Python 没有空间放置新的项，列表确实需要在幕后重新复制，但这是罕见的情况。
5.8  输入/输出作为字符串操作 
生成的代码称为“密文”。
即使我们的密码不是基于著名的Unicode 编码，仍然很容易发现原始消息。由于每个字
母总是由相同的符号编码，因此解码器可以使用关于各种字母频率的统计信息和一些简单
的试错法测试来发现原始消息。这种简单的加密方法可能对小学的纸条传递已足够，但是
显然不能完成在全球网络上确保通信的任务。
加密的现代方法是先将消息转换为数字，就像我们的编码程序，然后采用复杂的数学
算法将这些数字转换为其他数字。通常，变换基本上是将消息与一些特殊值组合，这称为
“密钥”。为了解密消息，接收方需要具有适当的密钥，以便反转编码，恢复原始消息。
加密方法有“私钥”和“公钥”两种风格。在私钥（也称为“共享密钥”）系统中，相
同的密钥用于加密和解密消息。希望通信的各方需要知道密钥，但它必须对外界保密。这
是人们在考虑密码时通常考虑到的系统。
在公钥系统中，存在用于加密和解密的不同但相关的密钥。知道加密密钥不允许你解
密消息或发现解密密钥。在公钥系统中，加密密钥可以公开获得，而解密密钥保持私有。
任何人都可以用公钥安全地发送消息进行加密。只有持有解密密钥的一方才能够解密。例
如，安全网站可以向Web 浏览器发送其公共密钥，浏览器可以用它对信用卡信息进行编码，
再在因特网上发送。然后只有请求信息的公司才能够用正确的私钥来解密和读取它。
5.8  输入/输出作为字符串操作 
有些程序，即使我们认为主要不是进行文本操作，但也经常需要使用字符串操作。
例如，考虑一个进行财务分析的程序。某些信息（如日期）必须以字符串形式输入。在
进行一些数字处理之后，分析的结果通常是一个格式良好的报告，包括用于标记和解释
数字、图表、表格和图形的文本信息。我们需要字符串操作来处理这些基本的输入和输
5.8.1  示例应用程序：日期转换 
作为一个具体的例子，让我们将月份缩写程序扩展成日期转换。用户将输入一个日期，
例如“05/24/2020”，程序将显示日期为“May 24, 2020”。下面是该程序的算法： 
我们可以用讨论过的字符串操作，在代码中直接实现算法的前两行：
这里我得到了一个字符串的日期，并以斜杠分隔。然后利用同时赋值，将三个字符串
的列表“分拆”到变量monthStr、dayStr 和yearStr 中。 
第5 章  序列：字符串、列表和文件
接下来是将monthStr 转换为适当的数字（再次使用int），然后用该值查找正确的月份
名称。下面是代码：
回忆一下，使用索引表达式int(monthStr)-1 是因为列表索引从0 开始。 
程序的最后一步是以新格式拼出日期：
注意我如何使用连接实现紧跟日期的逗号。
下面是完整的程序：
运行时，输出如下所示：
虽然这个例子没有展示，但我们常常也需要将数字转成字符串。在Python 中，大多数
数据类型可以用str 函数转换为字符串。下面是几个简单的例子： 
特别注意最后一个例子。通过将值转换为字符串，我们可以用字符串连接在句子的结
尾处放置句点。如果我们不首先将值转换为字符串，Python 会将“+”解释为数字运算并产
生错误，因为“.”不是数字。 
我们现在有了一套完整的操作，用于在各种Python 数据类型之间转换值。表5.4 总结
了这四种Python 类型转换函数。 
5.8  输入/输出作为字符串操作 
将expr 转换为浮点值 
将expr 转换为整数值 
返回expr 的字符串表示形式 
将字符串作为表达式求值
将数字转换为字符串有一个常见原因，即字符串操作可用于控制值的打印方式。例如，
执行日期计算的程序必须将月、日和年作为数字操作。对于格式化的输出，这些数字将被
5.8.2  字符串格式化 
如你所见，基本的字符串操作可以用来构建格式正确的输出。这种技术对于简单的格
式化是有用的，但是通过较小字符串的切片和连接来构建复杂的输出可能是无趣的。Python
提供了一个强大的字符串格式化操作，让事情更容易。
让我们从一个简单的例子开始。下面是第3 章中的零钱计数程序的运行： 
注意，最终值是以只有一个小数位的小数形式给出的。这看起来有点怪，因为我们期
望输出是1.50 美元。 
可以通过更改程序的最后一行来解决这个问题，如下所示：
现在程序打印以下消息：
让我们试着解释一下其中的含义。format 方法是内置的Python 字符串方法。想法是用
字符串作为一种模板，值作为参数提供，插入到该模板中，从而形成一个新的字符串。所
以字符串格式化的形式为：
模板字符串中的花括号（{}）标记出“插槽”，提供的值将插入该位置。花括号中的信
息指示插槽中的值以及值应如何格式化。Python 格式化操作符非常灵活。我们将在这里介
绍一些基础知识。如果你希望了解所有的细节，可以参考Python 文档。在本书中，插槽说
明总是具有以下形式：
第5 章  序列：字符串、列表和文件
索引告诉哪个参数被插入到插槽中
①。像Python 中的惯例一样，索引从0 开始。在上面
的例子中，有一个插槽，索引0 用于表示第一个（也是唯一的）参数插入该插槽。 
冒号后的描述部分指定值插入插槽时该值的外观。再次回到示例，格式说明符为0.2f。
此说明符的格式为<宽度>.<精度><类型>。宽度指明值应占用多少“空间”。如果值小于指
定的宽度，则用额外的字符填充（空格是默认值）。如果值需要的空间比分配的更多，它会
占据显示该值所需的空间。所以在这里放置一个0 基本上是说“使用你需要的空间”。精度
②，这告诉Python 将值舍入到两个小数位。最后，类型字符f 表示该值应显示为定点数。
这意味着，将始终显示指定的小数位数，即使它们为0。 
对格式说明符的完整描述相当难理解，但你可以通过查看几个例子较好地掌握它。最
简单的模板字符串只是指定在哪里插入参数。
通常，我们想要控制一个数学值的宽度和精度。
请注意，对于正常（非定点）浮点数，精度指明要打印的有效数字的个数。对于定点（由指
定符末尾的f 表示），精度表示小数位数。在最后一个示例中，相同的数字以两种不同的格式打印
出来。这说明，如果打印一个浮点数的足够数字，你几乎总是会发现“惊喜”。计算机不能将3.14
准确表示为一个浮点数。它可以表示的最接近的值稍大于3.14。如果没有给出明确的精度，Python
会把数字打印到几个小数位。如果打印许多数字，稍多出来的数量就会显示出来。一般来说，Python
只显示一个接近的、舍入的浮点型。使用显式格式化可以查看到完整结果，直到最后一位。
你可能会注意到，默认情况下，数值是右对齐的。这有助于在列中排列数字。另一方
面，字符串在其字段中是左对齐的。通过在格式说明符的开头包含显式调整字符，你可以
更改默认行为。对于左、右和中心对齐，所需的字符分别为<、>和^。 
①在Python 3.1 中，插槽描述的索引部分是可选的。省略索引时，参数仅以从左到右的方式填充到插槽中。
5.9  文件处理 
5.8.3  更好的零钱计数器 
让我们用一个示例程序结束格式化的讨论。考虑到你对浮点数的了解，你可能对用它
们表示货币有点不安。
假设你正在为一家银行编写一个计算机系统。你的客户得知收费是“非常接近107.56
美元”的金额，恐怕不会太高兴。他们希望知道银行正在精确记录他们的钱。即使给定值
中的误差量非常小，如果进行大量计算，小误差也可能复杂化，而且导致的误差可能累积
为真实的金额。这不是令人满意的经营方式。
更好的方法是确保程序用确切的值来表示钱。我们可以用美分来记录货币，并用int 来
存储它。然后我们可以在输出步骤中将它转换为美元和美分。假设我们处理正数，如果total
代表以分为单位的值，那么我们可以通过整数除法total // 100 得到美元数，通过total % 100
得到美分数。这两个都是整数计算，因此会给出确切的结果。下面是更新的程序：
我已经把最后的打印语句分成两行。通常一个语句在行末结束，但有时将较长的语句分成较
小的部分更好。因为这行在打印函数的中间断开，Python 知道，语句在完成最后一个闭括号之前
没有结束。在这个例子中，将语句跨两行，而不是很长的一行，这是可以的，而且更好。
print 语句中的字符串格式化包含两个插槽，一个用于美元，是int，另一个用于美分。
美分插槽说明了格式说明符的另一种变化。美分的值用格式说明符“0>2”打印。前面的调
整字符0 告诉Python 用0 来填充字段（如果必要），而不是空格。这确保10 美元5 美分这
样的值打印为10.05 美元，而不是10.5 美元。 
5.9  文件处理 
本章开始时，我说字处理是字符串数据类型的应用程序。所有字处理程序都有一个关
第5 章  序列：字符串、列表和文件
键特征，即能够保存和读取文档，作为磁盘上的文件。在本节中，我们来看一下文件的输
入和输出。结果表明，这只是另一种形式的字符串处理。
5.9.1  多行字符串 
在概念上，文件是存储在辅助存储器（通常在磁盘驱动器上）的数据序列。文件可以包
含任何数据类型，但最简单的文件是包含文本的文件。文本文件的优点是可以被人阅读和理
解，并且它们可以容易地使用通用文本编辑器（诸如IDLE）和字处理程序来创建和编辑。在
Python 中，文本文件可以非常灵活，因为它很容易在字符串和其他类型之间来回转换。 
你可以将文本文件看成一个（可能很长的）字符串，恰好存储在磁盘上。当然，典型
的文件通常包含多于一行的文本。特殊字符或字符序列用于标记每行的结尾。对于行结束
标记有许多约定。Python 为我们处理这些不同的约定，只要使用常规换行符（\n）来表示换
让我们来看一个具体的例子。假设你在文本编辑器中键入以下行：
如果存储到文件，你会得到以下字符序列：
请注意，在得到的文件/字符串中，空行变为一个换行符。 
顺便说一下，这真的没有什么不同，就像我们将换行字符嵌入到输出字符串，用一个
打印语句生成多行输出一样。下面是上面例子的交互式打印：
记住，如果只是在shell 中对一个包含换行符的字符串求值，将再次得到嵌入换行符的
只有当打印字符串时，特殊字符才会影响字符串的显示方式。
5.9.2  文件处理 
文件处理的确切细节在编程语言之间有很大不同，但实际上所有语言都共享某些
底层的文件操作概念。首先，我们需要一些方法将磁盘上的文件与程序中的对象相关
联。这个过程称为“打开”文件。一旦文件被打开，其内容即可通过相关联的文件对
5.9  文件处理 
其次，我们需要一组可以操作文件对象的操作。这至少包括允许我们从文件中读取信
息并将新信息写入文件的操作。通常，文本文件的读取和写入操作类似于基于文本的交互
式输入和输出的操作。
最后，当我们完成文件操作，它会被“关闭”。关闭文件确保所有必需的记录工作都已
完成，从而保持磁盘上的文件和文件对象之间的一致。例如，如果将信息写入文件对象，
则在文件关闭之前，更改可能不会显示在磁盘版本上。
这种打开和关闭文件的思想，与字处理程序这样的应用程序中处理文件的方式密切相
关。但是，概念不完全相同。当你在Microsoft Word 这样的程序中打开文件时，该文件实际
上是从磁盘读取并存储到RAM 中。用编程术语来说，打开文件以进行读取，然后通过文件
读取操作将文件的内容读入内存。此时，文件被关闭（也是在编程意义上）。当你“编辑文
件”时，真正改变的是内存中的数据，而不是文件本身。这些更改不会显示在磁盘上的文
件中，除非你通知应用程序“保存”。
保存文件还涉及多步骤过程。首先，磁盘上的原始文件被重新打开，这一次用允许它
存储信息的模式：磁盘上的文件被打开以进行写入。这样做实际上会擦除文件的旧内容。
然后用文件写入操作将内存中版本的当前内容复制到磁盘上的新文件中。从你的角度来看，
你似乎编辑了已有文件。从程序的角度来看，你实际上打开了一个文件，读取它的内容到
内存，关闭文件，创建一个新文件（具有相同的名称），将内存中的（修改的）内容写入新
文件，并关闭这个新文件。
在Python 中使用文本文件很容易。第一步是创建一个与磁盘上的文件相对应的文件对
象。这是用open 函数完成的。通常，文件对象立即分配给变量，如下所示： 
这里的name 是一个字符串，它提供了磁盘上文件的名称。mode 参数是字符串“r”或
“w”，这取决于我们打算从文件中读取还是写入文件。 
例如，要打开一个名为“numbers.dat”的文件进行读取，可以使用如下语句： 
现在我们可以利用文件对象infile 从磁盘读取numbers.dat 的内容。 
Python 提供了三个相关操作从文件中读取信息： 
<file>.read()将文件的全部剩余内容作为单个（可能是大的、多行的）字符串返回。 
<file>.readline()返回文件的下一行。即所有文本，直到并包括下一个换行符。 
<file>.readlines()返回文件中剩余行的列表。每个列表项都是一行，包括结尾处的换行符。 
下面是用read 操作将文件内容打印到屏幕上的示例程序： 
第5 章  序列：字符串、列表和文件
程序首先提示用户输入文件名，然后打开文件以便读取变量infile。你可以使用任意名
称作为变量，我使用infile 强调该文件正在用于输入。然后将文件的全部内容读取为一个大
字符串并存储在变量data 中。打印data 从而显示内容。 
readline 操作可用于从文件读取下一行。对readline 的连续调用从文件中获取连续的行。
这类似于输入，它以交互方式读取字符，直到用户按下<Enter>键。每个对输入的调用从用
户获取另一行。但要记住一件事，readline 返回的字符串总是以换行符结束，而input 会丢
作为一个快速示例，这段代码打印出文件的前五行：
请注意，利用切片去掉行尾的换行符。由于print 自动跳转到下一行（即它输出一个换
行符），打印在末尾带有显式换行符时，将在文件行之间多加一个空行输出。或者，你可以
打印整行，但告诉print 不添加自己的换行符。 
循环遍历文件全部内容的一种方法，是使用readlines 读取所有文件，然后循环遍历结
当然，这种方法的潜在缺点是文件可能非常大，并且一次将其读入列表可能占用太多
幸运的是，有一种简单的替代方法。Python 将文件本身视为一系列行。所以循环遍历
文件的行可以直接如下进行：
这是一种特别方便的方法，每次处理文件的一行。
打开用于写入的文件，让该文件准备好接收数据。如果给定名称的文件不存在，就
会创建一个新文件。注意：如果存在给定名称的文件，Python 将删除它并创建一个新的
空文件。写入文件时，应确保不要破坏你以后需要的任何文件！下面是打开文件用作输
将信息写入文本文件最简单的方法是用已经熟悉的print 函数。要打印到文件，只需要
添加一个指定文件的额外关键字参数：
这个行为与正常打印完全相同，只是结果被发送到输出文件而不是显示在屏幕上。
5.9  文件处理 
5.9.3  示例程序：批处理用户名 
为了看看这些部分是如何组合在一起的，我们重写用户名生成程序。以前的版本通过
让用户输入姓名来交互地创建用户名。如果为大量用户设置账户，则该过程可能不会以交
互方式完成，而是以“批处理”方式进行。在批处理时，程序输入和输出通过文件完成。
我们的新程序设计用于处理一个包含名称的文件。输入文件的每一行将包含一个新用
户的名字和姓氏，用一个或多个空格分隔。该程序产生一个输出文件，其中包含每个生成
这个程序中有一些值得注意的事情。我同时打开两个文件，一个用于输入（infile），一
个用于输出（outfile）。一个程序同时操作几个文件并不奇怪。另外，当创建用户名时，我
使用字符串方法lower。请注意，该方法应用于连接产生的字符串。这确保用户名全部是小
写，即使输入名称大小写混合。
5.9.4  文件对话框（可选） 
使用文件操作程序经常出现一个问题，即决定如何指定要使用的文件。如果数据文件
与你的程序位于同一目录（文件夹），那么只需键入正确的文件名称。没有其他信息，Python
将在“当前”目录中查找文件。然而，有时很难知道文件的完整名称是什么。大多数现代
第5 章  序列：字符串、列表和文件
操作系统使用具有类似<name>.<type>形式的文件名，其中type 部分是描述文件包含什么类
型数据的短扩展名（三个或四个字母）。例如，我们的用户名可能存储在名为“users.txt”的
文件中，其中“.txt”扩展名表示文本文件。困难是，一些操作系统（如Windows 和macOS）
默认情况下只显示在点之前的名称的部分，所以很难找出完整的文件名。
当文件存在于除当前目录之外的某处时，情况更加困难。文件处理程序可能用于辅助
存储器中任何位置存储的文件。为了找到这些远程文件，我们必须指定完整路径在用户的
计算机系统中定位文件。路径的确切形式因系统而异。在Windows 系统上，带有路径的完
整文件名可能如下所示：
这不仅需要打很多字，而且大多数用户甚至可能不知道如何找出其系统上任何给定文
件的完整路径+文件名。 
这个问题的解决方案是允许用户可视地浏览文件系统，并导航到特定的目录/文件。向
用户请求打开或保存文件名是许多应用程序的常见任务，底层操作系统通常提供一种标准
的、熟悉的方式来执行此操作。通常的技术包括对话框（用于用户交互的特殊窗口），它允
许用户使用鼠标在文件系统中点击并且选择或键入文件的名称。幸运的是，包含在（大多
数）标准Python 安装中的tkinter GUI 库提供了一些简单易用的函数，用于创建用于获取文
要询问用户打开文件的名称，可以使用askopenfilename 函数。它在tkinter.filedialog 模
块中。在程序的顶部，需要导入该函数：
在导入中使用点符号，是因为tkinter 是由多个模块组成的包。在这个例子中，我们从
tkinter 中指定filedialog 模块。而不是从这个模块导入一切，我指定了在这里使用的一个函
数。调用askopenfilename 将弹出一个系统对应的文件对话框。 
例如，要获取用户名文件的名称，我们可以使用一行代码，如下所示：
在Windows 中执行此行的结果如图5.2 所示。该对话框允许用户键入文件的名称或
简单地用鼠标选择它。当用户单击“打开”按钮时，文件的完整路径名称将作为字符串
返回并保存到变量infileName 中。如果用户单击“取消”按钮，该函数将简单地返回一
个空字符串。在第7 章中，你将了解如何测试结果值，并根据用户选择的按钮采取不同
Python 的tkinter 提供了一个类似的函数asksaveasfilename，用于保存文件。它的用法非
asksaveasfilename 的示例对话框如图5.3 所示。当然，你可以使用导入同时导入这两个
5.10  小结 
这两个函数还有许多可选参数，让程序可以定制得到的对话框，例如改变标题或建议
默认文件名。如果你对这些细节感兴趣，可以参考Python 文档。 
   图5.2 来自askopenfilename 的文件对话框
图5.3 来自asksaveasfilename 的文件对话框 
本章介绍了Python 字符串、列表和文件对象的重要元素。下面是要点的小结。 
字符串是字符序列。字符串文字可以用单引号或双引号分隔。
  可以用内置的序列操作来处理字符串和列表：连接（+）、重复（*）、索引（[]），
切片（[:]）和长度（len()）。可以用for 循环遍历字符串的字符、列表中的项或文
将数字信息转换为字符串信息的一种方法是用字符串或列表作为查找表。
列表比字符串更通用。
字符串总是字符序列，而列表可以包含任何类型的值。
列表是可变的，这意味着可以通过赋新值来修改列表中的项。
  字符串在计算机中表示为数字代码。ASCII 和Unicode 是用于指定字符和底层代码
之间的对应关系的兼容标准。Python 提供ord 和chr 函数，用于在Unicode 代码和
字符之间进行转换。
  Python 字符串和列表对象包括许多有用的内置方法，用于字符串和列表处理。 
将数据编码以保持私密的过程称为加密。有私钥和公钥两种不同类型的加密系统。 
  程序输入和输出通常涉及字符串处理。Python 提供了许多运算符在数字和字符
串之间来回转换。字符串格式化方法（format）对于生成格式良好的输出特别
文本文件是存储在辅助存储器中的多行字符串。可以打开文本文件进行读取或写
入。打开进行写入时，文件的原有内容将被删除。Python 提供了read()、readline()
和readlines()三种文件读取方法。也可以用for 循环遍历文件的行。用print 函数将
数据写入文件。处理完成后，应关闭文件。
第5 章  序列：字符串、列表和文件
5.11  练习 
1．Python 字符串字面量总是用双引号括起来。 
2．字符串s 的最后一个字符在位置len(s)−1。 
3．一个字符串总是包含一行文本。 
4．在Python 中，"4" + "5"是"45"。 
5．Python 列表是可变的，但字符串不是。 
6．ASCII 是使用数字代码表示字符的标准。 
7．split 方法将一个字符串拆分为一个子字符串列表，而join 则相反。 
8．替换加密是保持敏感信息安全的好方法。 
9．可以用add 方法在列表末尾添加一项。 
10．将文件与程序中的对象相关联的过程称为“读取”该文件。 
1．访问字符串中的单个字符称为
项与s[0:-1]相同。 
a．s [-1] 
c．s [：len(s)-1]  
函数给出了字符的Unicode 值。 
项不能用于将数字字符串转换为数字。
5．包括（几乎）所有书面语言的字符的、ASCII 的后继标准是
b．ASCII ++   
c．Unicode  
字符串方法将字符串的所有字符转换为大写。
a．capitalize  
b．capwords  
c．uppercase 
7．format 方法中填充的字符串“插槽”标记为
不是Python 中的文件读取方法。 
b．readline   
c．readall 
d．readlines 
9．使用文件进行输入和输出的程序的术语是
a．面向文件的  b．多行  
5.11  练习 
10．在读取或写入文件之前，必须创建文件对象
b．create  
d．Folder 
1．给定初始化语句： 
写出以下每个字符串表达式求值的结果。
a．"The Knights who say, " + s2
b．3 * s1 + 2 * s2
d．s1[1:3]
e．s1[2] + s2[:2]
f．s1 + s2[-1]
g．s1.upper()
h．s2.upper().ljust(4) * 3
2．给定与上一个问题相同的初始化语句，写出一个Python 表达式，可以通过对s1 和
s2 执行字符串操作构造以下每个结果。 
b．"ni!spamni!"
c．"Spam Ni! Spam Ni! Spam Ni!"
d．"spam"
e．["sp","m"]
3．显示以下每个程序片段产生的输出： 
a．for ch in "aardvark":
b．for w in "Now is the winter of our discontent...".split():
c．for w in "Mississippi".split("i"):
d．msg = ""
e．msg = ""
第5 章  序列：字符串、列表和文件
4．写出以下每个字符串格式化操作产生的字符串。如果操作不合法，请解释原因。 
a．"Looks like {1} and {0} for breakfast".format("eggs", "spam")
b．"There is {0} {1} {2} {3}".format(1,"spam", 4, "you")
c．"Hello {0}".format("Susan", "Computewell")
d．"{0:0.2f} {0:0.2f}".format(2.3, 2.3468)
e．"{7.5f} {7.5f}".format(2.3, 2.3468)
f．"Time left {0:02}:{1:05.2f}".format(1, 37.374)
g．"{1:3}".format("14")
5．解释为什么公钥加密比私人（共享）密钥加密更有利于保护因特网上的通信。 
1．字符串格式化可以用来简化dateconvert2.py 程序（该程序在本章示例代码中，可下
载获得）。用字符串格式化方法重写该程序。
2．某个CS 教授给出了5 分测验，等级为5-A、4-B、3-C、2-D、1-F、0-F。编写一个
程序，接受测验分数作为输入，并打印出相应的等级。
3．某个CS 教授给出100 分的考试，分数等级为90～100：A、80～89：B、70～79：
C、60～69：D、<60：F。编写一个程序，接受考试成绩作为输入，并打印出相应的等级。 
4．首字母缩略词是一个单词，是从短语中的单词取第一个字母形成的。例如，RAM
是“random access memory”的缩写。编写一个程序，允许用户键入一个短语，然后输出
该短语的首字母缩略词。注意：首字母缩略词应该全部为大写，即使短语中的单词没有
5．数字命理学家声称能够基于名字的“数值”来确定一个人的性格特征。名字的值的
确定方法是名字中字母的值之和，其中“a”为1、“b”为2、“c”为3，直到“z”为26。
例如，名字“Zelle”具有的值为26 + 5 + 12 + 12 + 5 = 60（顺便说一下，这恰好是一个非常
吉利的数字）。编写一个程序，计算输入的单个名字的数值。
6．扩展前一个问题的解决方案，允许计算完整的名字，如“John Marvin Zelle”或“John 
Jacob Jingleheimer Smith”。总值就是所有名字的数值之和。 
7．凯撒密码是一种简单的替换密码，其思路是将明文消息的每个字母在字母表中移
动固定数字（称为密钥）。例如，如果键值为2，则单词“Sourpuss”将被编码为“Uqwtrwuu”。
原始消息可以通过使用密钥的负值“重新编码”来恢复。编写一个可以编码和解码凯撒
密码的程序。对程序的输入将是明文的字符串和密钥的值。输出将是一个编码消息，其
中原始消息中的每个字符都将被替换为Unicode 字符集中后移密钥个字符。例如，如果
ch 是字符串中的字符，key 是要移位的量，则替换ch 的字符可以计算为chr（ord（ch）
8．上一个练习有一个问题，它不处理“超出字母表末端”的情况。真正的凯撒密码以
循环方式移动，其中“z”之后的下一个字符是“a”。修改上一个问题的解决方案，让它循
环。你可以假定输入只包含字母和空格。（提示：创建一个包含字母表所有字符的字符串，
并使用此字符串中的位置作为代码。你不必将“z”转换成“a”，只需确保在字母表字符串
中对整个字符序列中使用循环移位。）
5.11  练习 
9．编写一个程序，计算用户输入的句子中的单词数。 
10．编写一个程序，计算用户输入的句子中的平均单词长度。 
11．编写第1 章中的chaos.py 程序的改进版本，允许用户输入两个初始值和迭代次数，
然后打印一个格式很好的表格，显示这些值随时间的变化情况。例如，如果初始值为0.25
和0.26（10 次迭代），表格可能如下所示： 
12．编写第2 章中的futval.py 程序的改进版本。程序将提示用户投资金额、年化利率
和投资年数。然后程序将输出一个格式正确的表，以年为单位跟踪投资的价值。输出可能
13．重做所有以前的编程问题，让它们采用批处理（使用文本文件进行输入和输出）。 
14．单词计数。UNIX/Linux 系统上有一个通用实用程序，名为“wc”。该程序分析一
个文件以确定其中包含的行数、单词数和字符数。编写你自己的wc 版本。程序应接受文件
名作为输入，然后打印三个数字，显示文件的行数、单词数和字符数。
15．编写一个程序来绘制学生考试成绩的水平柱状图。你的程序应该从文件获取输入。
文件的第一行包含文件中学生数量的计数，后续每行包含学生的姓氏，后跟一个0～100 范
围内的分数。你的程序应为每个学生绘制一个水平柱形，其中柱形的长度表示学生的分数。
柱形应该对齐左边缘排列。（提示：使用学生的人数来确定窗口的大小及其坐标。加分需求：
在柱形左边标注学生姓名。）
16．编写一个程序来绘制测验分数直方图。程序应从文件读取数据。该文件的每一行
第5 章  序列：字符串、列表和文件
包含一个在0～10 范围内的数字。程序必须计算每个分数的出现次数，然后为每个可能分
数（0～10）绘制具有柱形的垂直柱形图，其高度对应于该分数。例如，如果15 个学生得
到8，那么8 的柱的高度应该是15。（提示：使用一个列表来存储每个可能得分的计数。）
直方图的示例如下。
了解程序员为什么将程序分成多组合作的函数。
  能够在Python 中定义新的函数。 
  理解Python 中函数调用和参数传递的细节。 
利用函数来编程，减少代码重复并增加程序的模块性。
6.1  函数的功能 
我们之前编写的程序只包含一个函数，通常称为main。我们还使用了预先编写的函数
和方法，包括内置的Python 函数（如print、abs）、来自Python 标准库的函数和方法（如
math.sqrt）以及来自graphics 模块的方法（如myPoint.getX()）。函数是构建复杂程序的重要
工具。本章介绍如何设计自己的函数，让程序更容易编写和理解。
在第4 章中，我们研究了终值问题的图形解决方案。回想一下，这个程序利用graphics
库来绘制显示投资增长的柱形图。下面是之前的程序：
第6 章  定义函数
这当然是一个可行的程序，但是在程序风格方面有点啰嗦，确实应该解决。注意，
这个程序在两个不同的地方绘制柱形。初始柱形在循环之前绘制，而随后的柱形在循环
两个地方有类似的代码，这有一些问题。显然，一个问题是不得不写两次代码。另一
个更微妙的问题是代码必须在两个不同的地方维护。如果我们决定改变柱形的颜色或其他
方面，就必须确保这些变化在两个地方发生。未能保持代码的相关部分同步是程序维护中
函数可用于减少代码重复，并使程序更易于理解和维护。在修正终值程序之前，我们
来看看函数必须提供什么。
6.2  函数的非正式讨论 
你可以将函数想象成一个“子程序”：程序里面的一个小程序。函数的基本思想是写一
个语句序列，并给这个序列取一个名字，然后可以通过引用函数名称，在程序中的任何位
置执行这些指令。
创建函数的程序部分称为“函数定义”。当函数随后在程序中使用时，我们称该定义被
“调用”。单个函数定义可以在程序的许多不同位置被调用。
让我们举个具体的例子。假设你希望编写一个程序，打印“Happy Birthday”的歌词。
标准歌词看起来像这样：
我们将在交互式Python 环境中展示这个例子。你可以启动Python 并自己尝试一下。 
这个问题的一个简单方法是使用四个print 语句。下面的交互式会话创建了一个程序，
对Fred 唱“Happy Birthday”。 
6.2  函数的非正式讨论 
我们可以运行这个程序，得到歌词：
显然，这个程序中有一些重复的代码。对于这样一个简单的程序，这不是大问题，但
即使在这里也有点烦人，要不断键入同一行内容。让我们引入一个函数，打印第一行、第
二行和第四行歌词。
我们定义了一个名为happy 的新函数。下面的例子说明了它的作用： 
调用happy 命令会使Python 打印一行歌词。 
现在我们可以用happy 为Fred 重写歌词。我们把新版本称为singFred。 
这个版本打的字要少得多，感谢happy 命令。让我们试着打印给Fred 的歌词，只是为
了确保它能工作。
到现在为止还挺好。现在假设今天也是Lucy 的生日，我们希望为Fred 唱一首歌，接下
来为Lucy 再唱一首。我们已经得到了Fred 的歌词，可以为Lucy 也准备一个。 
现在我们可以写一个主程序，唱给Fred 和Lucy： 
两个函数调用之间的print 在输出的歌词之间留出空行。下面是最终产品的效果： 
第6 章  定义函数
现在，这似乎肯定能工作，我们已通过定义happy 函数消除了一些重复。然而，还是感
觉有点不对。我们有singFred 和singLucy 两个函数，它们几乎相同。按照这种方法，为Elmer
添加歌词需要我们创建一个singElmer 函数，看起来就像为Fred 和Lucy 的那样。我们能对
歌词的增长做点什么吗？
请注意，singFred 和singLucy 之间的唯一区别是第三个print 语句结束时的名称。除了
这一个变化的部分以外，这些歌词完全相同。我们可以通过使用“参数”，将这两个函数合
并在一起。让我们写一个名为sing 的通用函数： 
此函数利用名为person 的参数。参数是在调用函数时初始化的变量。我们可以用sing
函数为Fred 或Lucy 打印歌词。只需要在调用函数时提供名称作为参数： 
让我们用一个程序结束，这个程序对所有三个过生日的人唱歌：
下面是作为模块文件的完整程序：
6.3  带有函数的终值程序 
6.3  带有函数的终值程序 
既然你已经了解了定义函数如何有助于解决代码重复问题，让我们回到终值的图。记
住，问题是图中的柱形在程序中的两个不同的地方绘制。循环之前的代码如下：
而循环中的代码如下：
让我们尝试将这两段代码合并成一个函数，在屏幕上绘制柱形。
为了画柱形，我们需要一些信息。具体来说，我们需要知道柱形的年份、柱形的高度
以及绘制柱形图的窗口。这三个值将作为函数的参数提供。下面是函数定义：
要使用该函数，只要为三个参数提供值。例如，如果win 是GraphWin，我们可以通过
调用drawBar 来绘制第0 年的柱形，本金为2000 美元，如下所示： 
利用drawBar 函数，下面是终值程序的最新版本： 
第6 章  定义函数
你可以看到drawBar 如何消除了重复的代码。如果我们希望改变图形中柱形的外观，只
需要在一个地方改变drawBar 的定义。如果你不明白这个例子的每一个细节，不要担心。关
于函数，你还有一些事情要了解。
6.4  函数和参数：令人兴奋的细节 
你可能对drawBar 函数的参数选择感到好奇。显然，绘制柱形的年份和柱形的高度是柱
形图的可变部分。但是为什么window 也是这个函数的参数呢？毕竟，我们将在同一个窗口
中绘制所有的柱形，它似乎没有改变。
使用window 参数的原因与函数定义中变量的“范围”有关。范围是指在程序中可以引
用给定变量的位置。记住，每个函数本身都是一个小子程序。在一个函数内部使用的变量
是该函数的“局部”变量，即使它们碰巧与另一个函数中的变量具有相同的名称。
函数要看到另一个函数中的变量，唯一方法是将该变量作为参数传入
①。由于GraphWin
（分配给变量win）是在main 内部创建的，因此不能在drawBar 中直接访问。但是，当drawBar
被调用时，drawBar 中的window 参数被赋值为win 的值。要理解这种情况，我们需要更详
细地了解函数调用的过程。
①技术上，可以在嵌套在另一个函数内的函数中引用变量，但是函数嵌套超出了本书讨论的范围。
6.4  函数和参数：令人兴奋的细节 
函数的name 必须是标识符，而formal-parameters（“形参”）是变量名（也是标识符）
的序列（可能为空）。形参与函数中使用的所有变量一样，只能在函数体中访问。在程序其
他地方，具有相同名称的变量与函数体内的形参和变量不同。
函数的调用是使用其名称后跟“实参”或“参数”的列表。
Python 遇到一个函数调用时，启动一个四步过程： 
第一步，调用程序在调用点暂停执行。
第二步，函数的形参获得由调用中的实参提供的值。
第三步，执行函数体。
第四步，控制返回到函数被调用之后的点。
回到Happy Birthday 的例子，让我们追踪唱两次歌词的过程。下面是main 函数体的一
Python 遇到sing("Fred")时，main 的执行暂停。在这里，Python 查找sing 的定义，并且
看到它具有单个形参person。形参被赋予实参的值，所以这就好像我们执行了下面的语句： 
这种情况的快照如图6.1 所示。注意，sing 里面的变量person 刚刚被初始化。 
图6.1  控制转移到sing 的图示 
在这里，Python 开始执行sing 的函数体。第一个语句是另一个函数调用，这次是happy。
Python 暂停执行sing 并将控制传递给被调用的函数。happy 的函数体包含一个print。这个
语句被执行，然后控制返回到它离开的地方。图6.2 展示了到目前为止执行的快照。 
图6.2  完成对happy 调用的快照 
执行以这种方式继续，Python 又绕路去了两次happy，完成了sing 的执行。当Python
到达sing 的末尾时，控制就返回到main，并在函数调用之后紧接着继续。图6.3 显示了此
时我们的位置。注意，sing 中的person 变量已经消失了。函数完成时，会回收局部函数变
第6 章  定义函数
量占用的内存。局部变量不保留从一个函数执行到下一个函数执行的任何值。
图6.3  完成对sing 调用的快照 
下一个要执行的语句是main 中的空白print 语句。这将在输出中生成空行。然后Python
遇到另一个对sing 的调用。如前所述，控制转移到函数定义。这次形参是“Lucy”。图6.4
展示了第二次开始执行时的情况。
图6.4  第二次调用sing 的快照 
现在我们快进到最后。针对Lucy 执行sing 的函数体（通过happy 的三次绕路执行），
并且在函数调用的点之后控制返回到main。现在我们已经到达代码片段的底部，如图6.5
所示。main 中这三句话导致sing 执行了两次、happy 执行了六次。总共产生了9 行输出。 
图6.5  完成第二次对sing 的调用 
希望你明白了函数调用的工作原理。这个例子没有提到的一点是使用多个参数。通
常，当函数定义具有多个参数时，实参按位置与形参匹配。第一个实参分配给第一个形
参，第二个实参分配给第二个形参，以此类推。可以利用关键字参数修改此行为，这些
参数通过名称匹配（如调用print 中的end=""）。然而，在所有示例函数中，我们将依赖
作为示例，再看看终值程序中drawBar 函数的使用。下面是绘制初始柱形的调用： 
当Python 将控制转移到drawBar 时，这些参数与函数标题中的形参匹配： 
实际效果就像函数体以三个赋值语句开头：
调用函数时，必须始终小心，将实参的顺序写正确，以符合函数定义。
6.5  返回值的函数 
6.5  返回值的函数 
你已经看到，参数传递提供了一种初始化函数中变量的机制。从某种意义上说，参数
是函数的输入。我们可以调用一个函数多次，并通过更改输入参数获得不同的结果。通常
我们还希望从函数中获取信息。事实上，函数的基本思想和词汇是从数学中借用的，其中
函数被认为是输入变量和输出变量之间的关系。例如，数学家可以定义函数f，该函数计算
其输入的平方。数学上我们会写这样的东西：
这表明f 是一个函数，它对单个变量（这里称为x）进行操作，并产生一个值，即x 的
与Python 函数一样，数学家使用括号表示法来表示函数的应用。例如，f(5) = 25 表示
当f 作用于5 时，结果为25。我们将说“f 作用于5 等于25”。数学函数不限于单个参数。
例如，我们可以定义一个函数，该函数利用毕达哥拉斯定理，根据给定的直角边长度，产
生直角三角形的斜边的长度。假定我们称之为函数h： 
根据这个定义，你应该能够验证h(3, 4) = 5。 
到目前为止，我们一直在利用例子讨论Python 函数的细节，其中函数被用作新的命令，
被调用来执行命令。但在数学上，函数调用实际上是一个产生结果的表达式。我们可以轻
松地扩展我们的Python 函数观点，以符合这个思想。事实上，你已经看到了许多这种类型
的函数的例子。例如，考虑从math 库调用sqrt 函数： 
这里b*b-4*a*c 的值是math.sqrt 函数的实参。由于函数调用发生在赋值语句的右侧，
这意味着它是一个表达式。math.sqrt 函数生成一个值，然后将该值赋给变量discRt。技术上，
我们说sqrt 返回其参数的平方根。 
编写返回值的函数非常容易。下面是一个函数的Python 实现，返回其参数的平方： 
你看到这个函数定义与上面的数学版本（f(x)）非常相似吗？Python 函数的主体由一个
return 语句组成。当Python 遇到return 时，它立即退出当前函数，并将控制返回到函数被调
用之后的点。此外，return 语句中提供的值作为表达式结果发送回调用者。本质上，这只是
为前面提到的四步函数调用过程添加了一个小细节：函数的返回值用作表达式的结果。
效果就是，我们可以在代码中任何可以合法使用表达式的地方使用square 函数。下面
是一些交互示例：
第6 章  定义函数
让我们用square 函数来写另一个函数，找到两点之间的距离。给定两个点（x1, y1）和
（x2, y2），它们之间的距离是
。下面是一个Python 函数，计算两个Point
对象之间的距离：
利用distance 函数，我们可以增强第4 章中的交互式三角形程序计算三角形的周长。下
面是完整的程序：
6.5  返回值的函数 
你可以看到一行中三次调用distance，以计算三角形的周长。在这里用一个函数节省了
相当多的冗长编码。返回值的函数非常有用、灵活，因为它们可以组合在这样的表达式中。 
顺便说一下，程序中函数定义的顺序并不重要。例如，如果让main 函数在顶部定义，
同样能工作。我们只要确保在程序实际尝试运行函数之前定义函数。因为直到模块的最后
一行才会发生main()的调用，所以所有的函数在程序实际开始运行之前已被定义。 
作为另一个例子，我们回到Happy Birthday 程序。在最初的版本中，我们使用了几个包
含print 语句的函数。我们可以不让辅助函数执行打印，而是简单地让它们返回值（在这个
例子中是字符串），然后由main 打印。请考虑这个版本的程序： 
注意，所有的打印都在一个地方（main 函数中）进行，而happy 和verseFor 只负责创
建和返回适当的字符串。利用函数返回值的魔力，我们已经精简了程序，让整个句子建立
在单个字符串表达式中。
应确保仔细查看并理解这行代码，它真正地展示了带返回值的函数的力量和美丽。
除了更优雅之外，这个版本的程序也比原来的更灵活，因为打印不再分布在多个函数
中。例如，我们可以轻松地修改程序，将结果写入文件而不是屏幕。我们要做的是打开一
个文件进行写入，并在print 语句中添加一个“file=”参数。不需要修改其他函数。下面是
通常，让函数返回值，而不是将信息打印到屏幕上，几乎总是更好（更灵活）。这样，
调用者可以选择是打印信息还是将它用于其他用途。
有时一个函数需要返回多个值。这可以通过在return 语句中简单地列出多个表达式来完
成。作为一个不太聪明的例子，下面是一个计算两个数字的和与差的函数：
如你所见，这个return 传递回两个值。调用这个函数时，我们将它放在一个同时赋值中： 
第6 章  定义函数
与参数一样，从函数返回多个值时，它们根据位置赋给变量。在这个例子中，s 将获得
return 列出的第一个值（sum），d 将获得第二个值（diff）。 
这差不多就是关于Python 中返回值的函数要知道的一切。有一点要提示你。从技术上
讲，Python 中的所有函数都返回一个值，而不管函数实际上是否包含return 语句。没有return
的函数总是返回一个特殊对象，表示为None。这个对象通常用作变量的一种默认值，如果
它当前没有指向任何有用的对象。新的（和不那么新的）程序员常犯一个错误，即写一个
应该返回值的函数，但忘记在结尾包括return 语句。 
假设我们忘记在distance 函数的结尾包括return 语句： 
用这个版本的distance 运行修订的三角形程序，会产生以下Python 错误消息： 
这里的问题是，这个版本的distance 不返回一个数字，它总是返回None。没有为None（它
是特殊类型NoneType）定义加法，所以Python 抱怨。如果你的返回值的函数产生了奇怪的错
误信息涉及None，或者程序在输出中打印出一个神秘的“None”，应检查是否漏了return 语句。 
6.6  修改参数的函数 
返回值是从函数发送信息到调用函数的程序部分的主要方式。在某些情况下，函数还
可以通过更改函数参数来与调用程序通信。理解何时以及如何实现这一点，需要掌握Python
如何赋值的一些微妙细节，以及这对函数调用中使用的实参和形参之间关系的影响。
我们从一个简单的例子开始。假设你正在编写一个管理银行账户或投资的程序。一个
必须执行的常见任务是在账户上累积利息（就像我们在终值程序中所做的那样）。我们可以
考虑编写一个函数，自动将利息添加到账户余额。下面是第一次尝试这样的函数：
该函数的目的是将账户的余额设置为已按照利息金额更新的值。
让我们通过编写一个非常小的测试程序来测试我们的函数：
6.6  修改参数的函数 
你认为这个程序将打印什么？我们的目的是amount 应该添加%5，给出的结果是1050。
下面是实际发生的情况：
如你所见，amount 没变！出了什么错？ 
事实上，没有出错。如果你仔细考虑我们已经讨论的函数和参数，就会看到，这正是
我们应该期待的结果。让我们跟踪这个例子的执行，看看会发生什么。test 函数的前两行创
建了名为amount 和rate 的两个局部变量，它们分别具有初始值1000 和0.05。 
接下来，控制转移到addInterest 函数。形参balance 和rate 被赋为来自实参amount 和rate 的
值。记住，即使名称rate 出现在两个函数中，它们也是两个单独的变量。addInterest 开始执行的
情况如图6.6 所示。注意，参数的赋值导致addInterest 中的变量balance 和rate 引用了实参的“值”。 
图6.6  控制转移到addInterest 
执行addInterest 的第一行会创建一个新变量newBalance。现在是关键的一步。addInterest
中的下一个语句为balance 赋值，让它具有与newBalance 相同的值。结果如图6.7 所示。注
意，balance 现在指的是与newBalance 相同的值，但这对test 函数中的amount 没有影响。 
图6.7  balance 的赋值 
第6 章  定义函数
此时，addInterest 的执行已完成，控制返回到test。addInterest 中的局部变量（包括参
数）消失，但测试函数中的amount 和rate 仍分别指初始值1000 和0.05。当然，程序打印
的amount 是1000。 
综上所述，函数的形参只接收实参的“值”。该函数不能访问保存实参的变量。因此，
为形参分配新值对包含实参的变量没有影响。用编程语言的术语，Python“按值”传递所有
一些编程语言（如C++和Ada）允许变量本身作为参数发送到函数。这种机制称为“按
引用”传递参数。当变量按引用传递时，向形参分配新值实际上会更改调用程序中的参数
因为Python 不允许按引用传递参数，所以一个明显的替代方法是更改我们的addInterest
函数，让它返回newBalance。然后，该值可用于更新test 函数中的amount。下面是一个能
工作的版本（addinterest2.py）： 
你应该很容易地跟踪这个程序的执行，看看我们如何得到这个输出：
现在假设不是查看单个账户，而是编写一个处理许多银行账户的程序。我们可以将账
户余额存储在Python 列表中。有一个addInterest 函数将累积的利息添加到列表中的所有余
额是很好的。如果balance 是账户余额列表，我们可以使用一行代码更新列表中的第一个数
量（索引为0），如下所示： 
记住，这是因为列表是可变的。这行代码实质上在说，“将列表的第0 个位置的值乘以
(1 + rate)，并将结果存回到列表的第0 个位置。”当然，非常相似的一行代码将更新列表中
下一个位置的余额，我们只要用1 替换0： 
更新列表中所有余额的更一般方法，是使用循环遍历位置0，1，……，长度−1。请考
虑addinterest3.py： 
6.6  修改参数的函数 
请花一点时间研究这个程序。test 函数开始将amounts 设置为四个值的列表。然后
addInterest 函数被调用，amounts 作为第一个参数。在函数调用之后，打印出amounts 的值。
你预期会看到什么？运行程序，看看会发生了什么：
这不是很有趣吗？在这个示例中，函数似乎更改了amounts 变量的值。但我刚才告诉你，
Python 传递参数的值，所以变量本身（amounts）不能被函数改变。那么这里发生了什么？ 
test 的前两行创建了变量的amounts 和rates，然后控制转移到addInterest 函数。此时的
情况如图6.8 所示。 
图6.8  将列表参数传给addInterest 
请注意，变量amounts 的值现在是一个列表对象，它本身包含四个int 值。这个列表对
象被传递给addInterest，因此也是balances 的值。 
接下来，addInterest 执行。循环遍历范围0，1，……，长度−1 中的每个索引，并更新
balances 中的项。结果如图6.9 所示。 
图6.9  在addInterest 中修改的列表 
第6 章  定义函数
你会注意到，在图中我留下了原来的值（1000，2200，800，360），只是放在边上。这
样做是为了强调值框中的数字没有改变。相反，发生的事情是创建了新值，并且列表中的
赋值导致它引用新值。当Python 执行垃圾收集时，原来的值将被清除。 
现在应该清楚了，为什么addInterest 程序的列表版本会产生它的答案。当addInterest
终止时，保存在amounts 中的列表已经包含了新余额，这就是打印的内容。这里的重点是变
量amounts 从未改变。与调用addInterest 之前相比，它仍然引用相同的列表。发生的事情是，
该列表的状态已更改，而这种更改在调用程序中可见。
现在你真的知道了关于Python 如何传递函数参数的一切。 参数始终通过值传递。但是，
如果实参是一个变量，其值是一个可变对象（如列表或图形对象），则对象状态的更改对调
用程序是可见的。这种情况是第4 章讨论的别名问题的另一个例子。 
6.7  函数和程序结构 
到目前为止，我们一直在讨论函数作为减少代码重复的机制，从而缩短和简化程序。
令人惊讶的是，即使函数实际上让程序更长，也会经常使用。使用函数的第二个原因是让
由于你设计的算法越来越复杂，因此理解程序也越来越难。人类很擅长一次跟踪八到
十件事情。如果面对一个几百行的算法，就算最好的程序员，也会在困惑中认输。
处理这种复杂性的一种方法是将算法分解成更小的子程序，每个子程序自身都有意义。
稍后在第9 章讨论程序设计时，我将更进一步讨论。现在，我们来看一个例子。让我们再
次回到终值问题。下面是之前的main 程序： 
6.7  函数和程序结构 
虽然我们已经通过使用drawBar 函数缩短了这个算法，但是它仍然很长，这使得通读它
有点困难。注释有助于解释事情，但（坦白说）这个函数太长了。使程序更可读的一种方
法是将一些细节移动到单独的函数中。例如，在中间有8 行，它们就是创建将绘制图表的
窗口。我们可以把这些步骤放到一个返回值的函数中：
顾名思义，该函数负责绘制初始窗口的所有细节。它是一个自包含的实体，执行这个
明确定义的任务。
利用新函数，main 算法看起来更简单： 
注意，我已经删除了注释，该算法的意图现在是清楚的。使用适当命名的函数，代码
变得几乎是自解释的。
下面是终值程序的最终版本：
第6 章  定义函数
虽然这个版本比以前的版本更长，但有经验的程序员会发现它更容易理解。随着你习
惯于阅读和写作函数，也将学会欣赏更加模块化代码的优雅。
函数是一种子程序。程序员使用函数来减少代码重复，并用于组织或模块化程序。
一旦定义了函数，它可以从程序中的许多不同位置被多次调用。参数允许函数具
有可更改的部分。函数定义中出现的参数称为形参，函数调用中出现的表达式称
对函数的调用启动一个四步过程：
第一步，调用程序暂停。
第二步，实参的值赋给形参。
第三步，执行函数体。
第四步，控制在调用程序中的函数调用之后立即返回。函数返回的值作为表达式结果。 
变量的作用域是程序可以引用它的区域。函数定义中的形参和其他变量是函数的
局部变量。局部变量与可在程序其他地方使用的同名变量不同。
  函数可以通过返回值将信息传递回调用者。在Python 中，函数可以返回多个值。
返回值的函数通常应该从表达式内部调用。没有显式返回值的函数会返回特殊对
  Python 按值传递参数。如果传递的值是可变对象，则对象所做的更改会对调用者
1．程序员很少定义自己的函数。 
2．函数只能在程序中的一个位置调用。 
3．信息可以通过参数传递到函数中。 
4．每个Python 函数都返回某些值。 
5．在Python 中，某些参数按引用传递。 
6．在Python 中，函数只能返回一个值。 
7．Python 函数永远不能修改参数。 
8．使用函数的一个原因是减少代码重复。 
9．函数中定义的变量是该函数的局部变量。 
10．如果定义新的函数使程序更长，那么，这是一个坏主意。 
1．程序中使用函数的部分称为
2．Python 函数定义的开头是
b．define 
c．function 
3．函数可以将输出发送回程序，使用
a．return  
c．assignment d．SASE 
4．正式且实际的参数匹配是按
项“不是”函数调用过程中的一个步骤。
a．调用程序挂起 
b．形参被赋予实参的值 
c．函数的主体执行 
d．控制返回到调用函数之前的点 
6．在Python 中，实际的参数被
项不是使用函数的原因。
第6 章  定义函数
a．减少代码重复 
b．使程序更模块化 
c．使程序更自解释 
d．展示智力优势 
8．如果一个函数返回一个值，它通常应该在
9．没有return 语句的函数返回
10．函数可以修改实参的值，如果它是
c．按引用传递的 d．变量 
1．用你自己的话来描述在程序中定义函数的两个动机。 
2．我们一直将计算机程序看成是指令序列，即计算机有条不紊地执行一个指令，然后
移动到下一个指令。包含函数的程序是否适合这个模型？请解释你的答案。
3．参数是定义函数的一个重要概念。 
a．参数的目的是什么？ 
b．形参和实参之间有什么区别？ 
c．参数与普通变量在哪些方面类似，哪些方面不同？  
4．函数可以被认为是其他程序中的微型（子）程序。与任何其他程序一样，我们可以
将函数看成具有输入和输出，与main 程序通信。 
a．程序如何提供“输入”到一个函数？ 
b．函数如何为程序提供“输出”？ 
5．考虑下面这个非常简单的函数： 
a．这个函数做什么？ 
b．说明程序如何使用此函数打印y3 的值，假设y 是一个变量。 
c．下面是使用这个函数的程序的一个片段： 
result = cube（3） 
print（answer，result） 
这个片段的输出是4 27。解释为什么输出不是27 27，虽然cube 似乎将answer
的值改成了27。 
1．编写一个程序来打印歌曲“Old MacDonald”的歌词。你的程序应该打印五种不同
动物的歌词，类似于下面的例子。
2．写一个程序来打印“The Ants Go Marching.”十段的歌词。下面给出几个例句。你
可以为每一节中的“little one”选择你自己的活动，但一定要选择一些押韵（或几乎押韵）
3．写出这些函数的定义： 
sphereArea(radius)返回具有给定半径的球体的表面积。 
sphereVolume(radius)返回具有给定半径的球体的体积。 
使用你的函数来解决第3 章中的编程练习1。 
4．写出以下两个函数的定义： 
sumN(n)返回前n 个自然数的和。 
sumNCubes(n)返回前n 个自然数的立方的总和。 
然后在提示用户输入n 的程序中使用这些函数，并打印出前n 个自然数的和与前n 个
自然数的立方之和。
5．第3 章的重做编程练习2。使用两个函数：一个计算比萨饼的面积，一个计算每平
6．编写一个函数，给定三边的长度作为参数，计算三角形的面积（参见第3 章编程练
习9）。使用你的函数来增强本章中的triangle2.py，让它也显示三角形的面积。 
7．编写一个函数来计算第n 个斐波纳契数。用你的函数来解决第3 章中的编程练习16。 
8．用返回下一个猜测的函数nextGuess(guess,x)解决第3 章中的编程练习17。 
9．用返回分数的字母等级的函数grade(score)完成第5 章的编程练习3。 
10．用函数acronym(phrase)完成第5 章的编程练习4，该函数返回字符串短语的
11．编写并测试一个函数，满足以下规格说明。 
squareEach(nums) nums 是一个数字列表。修改列表，对每一项平方。 
12．编写并测试一个函数，满足以下规格说明。 
sumList(nums) nums 是一个数字列表。返回列表中数字的和。 
第6 章  定义函数
13．编写并测试一个函数，满足以下规格说明。 
toNumbers(strList) strList 是一个字符串列表，每个字符串表示一个数字。修
改列表，将每一项转换为数字。
14．使用前面三个问题中的函数来实现计算从文件读取的数字的平方和的程序。你的
程序应提示输入文件名，并打印出文件中值的平方和。（提示：使用readlines()。） 
15．编写并测试一个函数，满足以下规模说明。 
drawFace(center,size,win) center 是一个Point，size 是一个int，win 是
一个GraphWin。在win 中绘制一张给定尺寸的简单的脸。 
你的函数可以画一个简单的笑脸（或严峻的脸）。编写一个在单个窗口中绘制不同大小
的几张脸的程序，来演示该函数。
16．使用上一个练习中的drawFace 函数来编写照片匿名程序。此程序允许用户加载
图像文件（例如PPM 或GIF），并在照片中已有的脸上绘制卡通脸。用户首先输入包含图像
的文件的名称。显示图像，并询问用户要遮挡多少脸。然后程序进入一个循环，供用户点
击每个脸的两个点：中心和脸边缘上的某处（以确定脸的大小）。然后程序应使用drawFace
函数在该位置绘制一个脸。
（提示：4.8.4 节描述了图形库中的图像处理方法。将图像居中显示在GraphWin 中，
窗口的大小与图像相同，并将图形绘制到此窗口中。你可以使用屏幕捕获工具程序保存生
17．写一个函数，满足以下规格说明。 
moveTo(shape, newCenter) shape 是一个支持getCenter 方法的图形对象，
newCenter 是一个点。移动形状，使newCenter 成为其中心。 
用你的函数编写一个绘制圆圈的程序，然后允许用户单击窗口10 次。每次用户点击时，
圆圈都会移动到用户点击的位置。
  利用Python 的if 语句来理解简单的判断编程模式及其实现。 
  利用Python 的if-else 语句来理解两路判断编程模式及其实现。 
  利用Python 的if-elif-else 语句来理解多路判断编程模式及其实现。 
  理解异常处理的思想，并能够编写简单异常处理代码，捕捉标准的Python 运行时错误。 
理解布尔表达式和布尔数据类型的概念。
能够阅读、编写和实现使用判断结构的算法，包括使用系列判断和嵌套判断结构
7.1  简单判断 
到目前为止，我们主要将计算机程序视为指令序列，一条接一条。序列是编程的一个
基本概念，但只用它不足以解决所有问题。常常有必要改变程序的顺序流程，以适应特定
情况的需要。这是通过特殊语句完成的，称为“控制结构”。在本章中，我们将学习“判断
结构”，它们是一些语句，允许程序针对不同情况执行不同指令序列，实际上允许程序“选
择”适当的动作过程。
7.1.1  示例：温度警告 
我们从让计算机做简单判断开始。作为一个简单的例子，我们回头看看第2 章中摄氏
温度转换为华氏温度的程序。回忆一下，这是Susan Computewell 写的，帮助她了解在欧洲
每天早晨该怎样穿衣服。下面是之前的程序：
第7 章  判断结构
就其本身而言，这是一个很好的程序，但我们希望增强它。Susan Computewell 不是喜
欢早起的人，即使有一个程序来转换温度，有时她也不太注意看结果。我们对程序的增强
会确保在温度极端时，打印出适当的警告，这样Susan 就会注意到。 
第一步是给出完整的增强规格说明。极端温度是指相当热或相当冷。假设任何超过90
华氏度的温度都应该发出热警告，而低于30 华氏度的温度则会发出冷警告。考虑到这个规
格说明，我们可以设计一个扩展的算法：
这个新设计在结束时有两个简单的“判断”。缩进表示只有满足上一行中列出的条件时
才应执行步骤。这里的意思是，判断引入了一个替代的控制流来通过程序。算法采取的确
切步骤取决于fahrenheit 的值。 
图7.1 是一张流程图，展示算法可能采取的路径。菱形框表示有条件的判断。 如果条
件为假，则控制传递到序列中的下一个语句（下面的语句）；如果条件成立，则控制权转移
到右侧框中的指令。这些指令完成后，控制会传递到下一个语句。
下面是新设计转换为Python 代码的样子： 
    print("It’s really hot out there. Be careful!") 
你可以看到Python 的if 语句用于实现判断。if 的形式非常类似于算法中的伪代码。 
body 只是在if 头部下缩进的一个或多个语句的序列。在convert2.py 中有两个if 语句，
两者在body 中都有一个语句。 
通过上面的例子，if 的语义应该清楚了。首先，对头部中的条件求值。如果条件为
真，则执行body 中的语句序列，然后控制传递到程序中的下一条语句；如果条件为假，
则跳过body 中的语句。图7.2 用流程图展示了if 的语义。注意，if 的body 是否执行取
决于条件。不论哪种情况，控制随后会传递到if 后的下一个语句。这是“一路”判断或
7.1  简单判断 
图7.1  带有警告的温度转换程序流程图
图7.2  简单if 语句的控制流 
7.1.2  形成简单条件 
有一点还没讨论：条件是怎样的？暂时，我们的程序将使用简单条件，它比较两个表
达式的值：<expr> <relop> <expr>。这里<relop>是“关系运算符”的缩写。这只是“小于”
或“等于”这类数学概念的特别名称。Python 中有六个关系运算符，如表7.1 所列。 
Python 中的关系运算符 
特别要注意用“==”表示相等。由于Python 使用“=”符号来表示赋值语句，因此对
于相等概念，需要使用不同的符号。Python 程序中常见的错误是在条件中使用“=”，而实
际需要使用的是“==”。 
条件可以比较数字或字符串。比较字符串时，排序是按“字典序”。基本上，这意味着
根据底层的Unicode 值以字母顺序放置字符串。因此，所有大写拉丁字母都在小写字母之前
（例如，“Bbbb”在“aaaa”之前，因为“B”在“a”之前）。 
我应该提到，条件实际上是一种表达式，称为布尔表达式，为纪念乔治·布尔，一位
第7 章  判断结构
19 世纪英国数学家。对一个布尔表达式求值，会产生值true（条件成立）或false（不成立）。
某些语言（如C ++和旧版本的Python）就用整数1 和0 来表示这些值。其他语言（如Java
和现代Python）有布尔表达式的专用数据类型。 
在Python 中，布尔表达式类型为bool，布尔值true 和false 由字面量True 和False 表示。
下面是一些交互示例：
7.1.3  示例：条件程序执行 
在第1 章，我提到过有几种不同的方式来运行Python 程序。一些Python 模块文件被设
计为直接运行。这些通常被称为“程序”或“脚本”。其他Python 模块主要设计为让其他程
序导入和使用，这些通常被称为“库”。有时我们希望创建一种混合模块，它既可以作为独
立程序使用，也可以作为可以由其他程序导入的库使用。
到目前为止，我们的大多数程序在底部有一行来调用main 函数。 
如你所知，这实际上启动了程序的运行。这些程序适合直接运行。在窗口环境中，
你可以通过点击（或双击）图标来运行该文件。或者键入类似python <myfile> .py 这样的
由于Python 在导入过程中对模块中的行求值，所以当前的程序在导入到交互式Python
会话或另一个Python 程序时也会运行。一般来说，不要让模块在导入时运行。以交互方式
测试程序时，通常的方法是首先导入模块，然后在每次运行它时调用它的main（或一些其
如果程序设计为既可以导入（不运行）又可以直接运行，则对底部的main 的调用必须
是有条件的。一个简单的判断应该就能搞定：
我们只需要找到合适的条件。
无论何时导入模块，Python 都会在该模块内部创建一个特殊的变量__name__，并为其
分配一个表示模块名称的字符串。下面是一个示例交互，显示math 库的情况： 
你可以看到，在导入后，math 模块中的__name__变量赋为字符串'math'。 
但是，如果直接运行Python 代码（不导入），Python 会将__name__的值设置为'__main__'。
7.2  两路判断 
要看到这个效果，只需要启动一个Python shell 并查看该值。 
’_ _main_ _’  
因此，如果模块被导入，那个模块中的代码将看到一个名为__name__的变量，其值是
模块的名称。如果文件直接运行，代码将看到该名称的值为'__main__'。模块可以通过检查
此变量来确定如何使用它。
综上所述，我们可以改变程序的最后一行，像这样：
if _ _name_ _ == ’_ _main_ _’:  
这保证在直接调用程序时自动运行main，但如果导入模块，就不会运行。几乎在每个
Python 程序的底部，都会看到类似这样的一行代码。 
7.2  两路判断 
既然我们利用判断，有办法在程序中选择性地执行某些语句，就可以回头看看第3 章
的二次方程求解程序。下面是之前的程序：
如注释中所述，如果给出没有实根的二次方程的系数时，该程序会崩溃。这段代码的
问题是当b2 − 4ac 小于0 时，程序试图取负数的平方根。由于负数没有实根，所以math 库
报告错误。下面有一个例子：
第7 章  判断结构
可以用一个判断来检查这种情况，并确保程序不会崩溃。下面是第一次尝试：
这个版本首先计算判别式（b2 − 4ac）的值，再检查并确保它不是负数。然后程序继续
取平方根并计算解。如果discrim 为负数，该程序永远不会尝试调用math.sqrt。 
不幸的是，这个更新版本并不是一个完整的解决方案。你看到当方程没有实根时会发
生什么？根据简单if 的语义，当b * b - 4 * a * c 小于零时，程序将简单地跳过计算并转到下
一条语句。由于没有下一条语句，程序就会退出。下面是交互式会话的示例：
这几乎比以前的版本更差，因为它不给用户任何迹象表明什么错误，只是让程序中止。
更好的程序将打印一条消息，告诉用户他们指定的方程没有实数解。我们可以通过在程序
结束时添加另一个简单的判断来实现这一点。
这当然会解决我们的问题，但这个解决方案感觉不对。我们已经编写了两个判断的序
列，但两个结果是互斥的。如果discrim> = 0 为真，则discrim <0 肯定为假，反之亦然。程
序中有两个条件，但实际上只有一个判断。根据discrim 的值，程序应该打印没有实数根，
或者应该计算并显示根。这是一个两路判断的例子。图7.3 说明了情况。 
在Python 中，可以通过在if 子句后加上else 子句来实现两路判断。结果称为if-else 语句。 
7.2  两路判断 
图7.3  二次方程求解程序是一个两路判断 
当Python 解释器遇到这种结构时，它首先对条件求值。如果条件为真，则执行if 下的
语句；如果条件为假，则执行else 下的语句。在任何情况下，控制随后都转到if-else 之后
在二次方程求解程序中使用两路判断，得到了更优雅的解决方案：
这个程序很好地解决了问题。下面是两次运行新程序的示例会话：
第7 章  判断结构
7.3  多路判断 
最新版本的二次方程求解程序肯定改进很大，但它仍然有一些奇怪的地方。下面是另
这在技术上是正确的，给定的系数产生一个方程，有相等的根为−1。但是，输出可能
会使某些用户感到困惑。它看起来像程序错误地打印了两次相同的数字。也许该程序应该
给出更多信息，以避免混乱。
当discrim 为0 时，发生等根的情况。在这种情况下，discRoot 也为0，并且两个根的值为
−b。如果希望捕捉这种特殊情况，程序实际上需要一个三路判断。下面是设计的快速草稿： 
该算法的一种编码方法是用两个if-else 语句。if 或else 子句的主体可以包含任何合法的
Python 语句，包括其他if 或if-else 语句。将一个复合语句放入另一个复合语句称为“嵌套”。
下面是用嵌套来实现三路判断的代码片段：
仔细观察这段代码，会看到有三种可能的路径。代码序列由discrim 的值确定。该解决
方案的流程图如图7.4 所示。你可以看到顶层结构只是一个if-else。（将虚线框视为一个大
语句。）虚线框包含第二个if-else，嵌套在顶级判断的else 部分中。 
我们又有了一个有效的解决方案，但实现让人感觉不太好。我们用两个两路判断巧妙
地实现了一个三路判断。得到的代码不反映原始问题的真正三路判断。设想一下，如果我
们需要像这样做一个五路判断。
7.3  多路判断 
图7.4  使用嵌套if-else 的二次求解器的三路判断 
if-else 结构将嵌套四层，Python 代码会一直写到屏幕的右边。 
在Python 中编写多路判断还有另一种方法，它保留了嵌套结构的语义，但看起来更舒
服。这就是将一个else 和一个if 组合成一个称为elif 的子句（发音为“ell-if”）。 
这个格式用于分隔任意数量的互斥代码块。Python 将依次对每个条件求值，寻找第一
个为真的条件。如果找到真条件，就执行在该条件下缩进的语句，并且控制转到整个
if-elif-else 之后的下一语句。 
如果没有条件为真，则执行else 下的语句。else 子句是可选的，如果省略，则可能没有
缩进语句块被执行。
在我们的二次方程求解程序中，用if-elif-else 表示三路判断得到了一个完成得很好的程序： 
第7 章  判断结构
7.4  异常处理 
我们的二次方程求解程序使用判断结构，避免了对负数取平方根和运行时产生错误。
在许多程序中，这是一种常见的模式：使用判断来防止罕见但可能的错误。
在二次方程求解程序的例子中，我们在调用sqrt 函数之前检查了数据。有时函数本身
会检查可能的错误，并返回一个特殊的值来表示操作失败。例如，另一个平方根运算可能
返回负数（如−1）来表示错误。因为平方根函数应该总是返回非负根，所以该值可以作为
信号，表示已经发生了错误。程序将用判断检查操作的结果：
有时程序充满了检查特殊情况的判断，导致处理一般情况的主要算法似乎快要找不到
了。编程语言设计者提出了“异常处理”的机制，帮助解决这种设计问题。异常处理机制
让程序员可以编写一些代码，捕获和处理程序运行时出现的错误。具有异常处理的程序不
会显式地检查算法中的每个步骤是否成功，本质上它是说，“做这些步骤，如果任何问题出
现，以这种方式处理它。”
我们不打算在这里讨论Python 异常处理机制的所有细节，但我想给出一个具体的例子，
这样你可以看到异常处理的工作原理和使用它的程序。在Python 中，异常处理是通过类似
于判断的特殊控制结构完成的。我们从一个具体的例子开始，然后看看一般的方法。
下面是一个二次方程求解程序的版本，它使用Python 的异常机制来捕获math.sqrt 函数
7.4  异常处理 
注意，这基本上是二次方程求解程序的第一个版本，并在核心程序外面加上了
try...except。try 语句的一般形式为： 
当Python 遇到try 语句时，它尝试执行其中的语句。如果这些语句执行没有错误，控制
随后转到try ... except 后的下一个语句；如果在其中某处发生错误，Python 会查找具有匹配
错误类型的except 子句。如果找到合适的except，则执行处理程序代码。 
原来没有异常处理的程序产生以下错误：
这条错误消息的最后一行说明了产生错误的类型，即ValueError。程序的更新版本提供
了一个except 子句来捕获ValueError。下面是它执行的样子： 
没有崩溃，异常处理程序捕获错误，并打印一条消息，说明方程没有实数根。
有趣的是，我们的新程序还捕获用户输入无效值导致的错误。 让我们再次运行程序，
这次输入“x”作为第一个输入。下面是运行示例： 
看到这里发生了什么吗？Python 执行float("x")时，引发了一个ValueError，因为"x"不
能转换为浮点数。这导致程序退出try 并跳转到该错误的except 子句。当然，最后的消息在
这里看起来有点奇怪。下面是程序的最后一个版本，检查发生什么样的错误：
第7 章  判断结构
多个except 类似于elif。如果发生错误，Python 将依次尝试每个except，查找与错误类
型匹配的错误。在这个例子底部的空except，行为就像一个else，如果前面的except 错误类
型都不匹配，它将作为默认行为。如果底部没有默认值，并且没有任何except 类型匹配错
误，程序将崩溃，Python 会报告错误。 
请注意我是如何处理两种不同ValueErrors 的。异常实际上是一种对象。如果在except
子句中，在错误类型后跟上as <variable>，Python 会将该变量赋值为实际的异常对象。在这
个例子中，我将异常转换成一个字符串，检查该消息，看看是什么导致了ValueError。请注
意，这段文本正是在未捕获错误时，Python 打印出来的内容（即ValueError: math domain 
error）。如果异常不是ValueError，这个程序只打印一般的道歉。作为挑战，你也许希望看
看是否能找到导致道歉的错误输入。
可以看到，try ... except 语句让我们可以编写防御式程序。同样利用这种技术，可以观
察Python 打印的错误消息，设计except 子句来捕获并处理它们。是否需要这么麻烦，取决
于你正在编写的程序类型。在刚开始编程时，你可能不太担心错误的输入。但专业品质的
软件应该采取所有可行的办法，防止用户得到意外的结果。
7.5  设计研究：三者最大 
既然判断可以改变程序的控制流，那么我们的算法就从单调的、逐步的、严格的顺序
处理中解放出来。这是福，也是祸。好的一面是，我们可以开发更复杂的算法，就像我们
对二次方程求解程序所做的那样。不好的是，设计这些更复杂的算法要困难得多。在本节
中，我们将介绍一个更困难的判断问题的设计，从而展示设计过程中的一些挑战和乐趣。
假设我们需要一个算法，找出三个数中最大的一个。这个算法可能是一个更大的问题
的一部分，例如确定等级或计算税额，但我们对最终的细节不感兴趣，只关心问题的关键。
也就是说，计算机如何确定用户的三个输入中哪一个最大？下面是简单的程序大纲：
7.5  设计研究：三者最大 
请注意，我用eval 来获取三个数，这是一种猛糙快的方式。当然，在产品代码中（让
其他用户使用的程序），通常应该避免eval。在这里问题不大，因为我们只关心开发和测试
现在我们只需要填充缺少的部分。在阅读下面的分析之前，你可能希望自己尝试解决
7.5.1  策略1：比较每个值和所有其他值 
显然，这个程序向我们提出了一个判断问题。我们需要一系列语句，将maxval 的值设
置为三个输入x1、x2 和x3 中的最大值。一眼看上去，这像是一个三路判断，我们需要执
行以下任务之一：
似乎我们只需要在每行前面加上适当的条件，让它只在正确的情况下执行。
让我们考虑第一种可能性：x1 是最大的。为了确定x1 确实是最大的，我们只需要检查
它至少与另外两个一样大。下面是第一次尝试：
你首先需要关注，这个语句的语法是否正确。条件x1> = x2> = x3 与上面显示的条件的
模板不匹配。大多数计算机语言不接受它作为一个有效的表达式。事实证明，Python 允许
这种复合条件，它的行为完全就像数学关系x1≥x2≥x3。也就是说，当x1 至少与x2 一样
大且x2 至少与x3 一样大时，条件为真。所以很幸运，Python 对这个条件没有问题。 
每次写判断时，你应该问自己两个重要的问题。首先，当条件为真时，你是否绝对确
定判断后执行语句是正确的操作？ 在这种情况下，条件清楚地表明x1 至少与x2 和x3 一
样大，因此将其值赋给maxval 应该是正确的。始终要特别注意边界值，注意我们的条件包
括等于和大于。我们应该说服自己这是正确的。假设x1、x2 和x3 都相同，这个条件将返
回true。这没关系，因为我们选择什么都不重要。第一个至少与其他一样大，因此最大。 
第二个问题与第一个问题相反。我们是否确定当x1 最大时，在所有情况下这个条件都
是真的？不幸的是，我们的结论不符合这个测试。假设值是5、2 和4。显然，x1 是最大的，
但条件返回false，因为关系5≥2≥4 不成立。我们需要修复这个问题。 
我们要确保x1 是最大的，但我们不关心x2 和x3 的相对顺序。我们真正需要的是两个
单独的测试，以确定x1> = x2 且x1> = x3。Python 允许我们测试这样的多个条件，只要用
and 关键字将它们组合起来。我们将在第8 章讨论and 的确切语义。直觉上，以下条件似乎
是我们要寻找的：
要完成该程序，我们只需要为其他可能性执行类似的测试：
第7 章  判断结构
总结一下，我们的算法基本上是检查每个可能的值和所有其他值，以确定它是否最大。 
只有三个值的结果相当简单，但如果我们试图找到五个值中最大的，这个解决方案怎
样？这样我们需要四个布尔表达式，每个由四个条件组成。复杂的表达式是由于每个判断
都是独立的，在后续测试中忽略了来自前面测试的信息。要明白我的意思，请回顾一下简
单的三者最大的代码。假设第一个判断发现x1 大于x2，但不大于x3。此时，我们知道x3
肯定是最大值。不幸的是，我们的代码忽略了这一点，Python 会继续对下一个表达式求值，
发现它是false，最后执行else。 
7.5.2  策略2：判断树 
要避免先前算法的冗余测试，一种方式是使用“判断树”的方法。假设我们从一个简
单的测试x1 >= x2 开始。这使得x1 或x2 中的一个退出最大值的竞争。如果条件为真，我
们只需要看看x1 和x3 哪个更大。如果初始条件为假，则结果归结为x2 和x3 之间的选择。
如你所见，第一个判断“分支”成两种可能性，每种又是另一个判断，因此称为“判断树”。
图7.5 用流程图展示了这种情况。这个流程图很容易转换成嵌套的if-else 语句。 
图7.5  三者最大问题的判断树方法的流程图 
这种方法的优势是效率。无论三个值的顺序如何，该算法都将进行两次比较，并将正
7.5  设计研究：三者最大 
确的值分配给maxval。然而，这种方法的结构比第一种更复杂，如果我们用三个以上的值
来尝试这个设计，会遭受类似的复杂性爆炸。作为一项挑战，你可能希望尝试能否设计一
个判断树，找到四个值中的最大值。（你需要if-elses 嵌套三层，导致八个赋值语句。） 
7.5.3  策略3：顺序处理 
到目前为止，我们设计了两种非常不同的算法，但没有一种看起来特别优雅。也许还
有第三种方式。设计算法时，一个好的起点是问自己，如果要求你做这项工作，你将如何
解决问题。要找到三个数中最大的，你可能对要采取
的步骤没有很好的直觉。只要看看数字，就知道哪个
是最大的。但是，如果交给你一本书，其中包含几百
个数字，又没有特定的顺序呢？你将如何找到这个集
合中最大的数字？
面对更大的问题时，大多数人会制定一个简单的
策略。扫描数字，直到找到一个大的，用手指指向它。
继续扫描，如果找到一个大于指向的数字，手指移动
到新的数字。到达列表的末尾时，手指将指向最大值。
简而言之，这个策略让我们按顺序浏览列表，记录到
目前为止最大的数字。
计算机没有手指，但我们可以使用变量来记录最大
值。事实上，最简单的方法是用maxval 来完成这项工
作。这样，到了最后，maxval 将自动包含列表中的最大
值。描述三者最大问题策略的流程图如图7.6 所示。 
下面是对应的Python 代码： 
显然，顺序方法是三种算法中最好的。代码本身很简单，只包含两个简单的判断，并
且顺序处理比以前算法中使用的嵌套更容易理解。此外，这个思路能很好地扩展到更大的
问题。例如，添加第四项只需要一个语句：
最后一个解决方案可以扩展到更大的问题，这不奇怪，我们通过明确考虑如何解决更
复杂的问题而发明了该算法。事实上，你可以看到代码是非常重复的。我们可以轻松地编
写一个程序，允许用户将我们的算法折叠成一个循环，找到n 个数字中最大的。不必使用
图7.6  三者最大问题的顺序方法的流程图 
第7 章  判断结构
x1、x2、x3 等单独的变量，我们可以每次取得一个值，并不断重复使用单个变量x。每次
比较最新的x 和maxval 的当前值，看它是否更大。 
这段代码利用嵌套在循环中的判断来完成工作。在循环的每次迭代中，maxval 包含到
目前为止看到的最大值。
7.5.4  策略4：使用Python 
在结束这个问题之前，我确实应该指出，这些努力追求的算法开发都没有必要。Python
实际上有一个内置的函数max，它返回最大的参数。下面是我们程序的最简单版本： 
当然，这个版本不需要开发任何算法，这让练习的意图彻底失败了！有时候Python 太
容易让我们舒服了。
7.5.5  一些经验 
三者最大问题不是什么惊天动地的问题，但解决这个问题的尝试展示了算法和程序设
计中的一些重要思想。
  存在多种方法实现方式。任何有价值的计算问题，都有多种解决方法。虽然这可
能看起来很明显，但许多新程序员没有真正把这一点放在心上。这对你意味着什
么？不要急于编写进入脑海的第一个想法。想想你的设计，问自己是否存在更好
的方法来处理这个问题。写下代码后，再问自己是否可能有更好的方法。你的第
一个任务是找到一个正确的算法。之后，力求清晰、简单、高效、可扩展和优雅。
好的算法和程序就像逻辑的诗，阅读和维护它们让人赏心悦目。
  变成计算机。特别是对于新程序员来说，制定算法的最好方法之一是简单地问自
己如何解决问题。虽然存在其他一些用于设计良好算法的技术（见第13 章），但
是直接的方法通常简单、清楚、有效。
  通用性好。我们通过考虑更通用的n 个数的最大值问题，得到三者最大问题的最
佳解决方案。考虑更通用的问题可以导致对于某些特殊情况的更好的解决方案，
这很常见。不要害怕后退一步去思考总体的问题。同样，在设计程序时，应始
终注意使程序更有用。如果n 者最大的程序和三者最大一样容易，你可以写出
更通用的程序，因为它更有可能在其他情况下有用。这样从编程工作中获得的
  不要重新发明轮子。我们的第四个解决方案是使用Python 的max 函数。你可能认
为这是作弊，但这个例子说明了一个重要问题。很多非常聪明的程序员已经设计
了无数的好算法和程序。如果你希望解决的问题似乎是许多其他人肯定会遇到的
问题，你可以开始先弄清楚问题是否已经被解决了。由于你正在学习编程，从头
开始设计是很好的经验。然而，真正的专家程序员知道什么时候借用。
本章阐述了做出判断的基本控制结构。下面是要点。
判断结构是允许程序针对不同情况执行不同指令序列的控制结构。
  判断在Python 中用if 语句实现。简单的判断是用一个简单的if 来实现的。两路判
断通常使用if-else。多路判断用if-elif-else 实现。 
  判断基于条件的求值，条件是简单的布尔表达式。布尔表达式结果为true 或false。
Python 有专门的bool 数据类型，其字面量为True 和False。条件的构成利用了关
系运算符<、<=、！=、==、>和>=。 
  一些编程语言提供了异常处理机制，让程序更具“防御性”。Python 提供了用于异
常处理的try-except 语句。 
结合判断的算法可能变得相当复杂，因为判断结构是嵌套的。通常有许多解决方
案是可能的，应仔细考虑，得到正确、有效和可理解的程序。
1．一个简单的判断可以用一个if 语句来实现。 
2．在Python 条件中，“=”被写成“/=”。 
3．字符串利用字典顺序进行比较。 
4．用if-elif 语句实现两路判断。 
第7 章  判断结构
5．math.sqrt 函数无法计算负数的平方根。 
6．单个try 语句可以捕获多种错误。 
7．多路判断必须通过嵌套多个if-else 语句来处理。 
8．对于涉及判断结构的问题，通常只有一个正确的解决方案。 
9．在Python 中允许条件x <= y <= z。 
10．输入验证意味着在需要输入时提示用户。 
1．控制其他语句的执行的语句称为
2．在Python 中实现多路判断的最佳结构是
b．if-else  
c．if-elif-else 
3．求值为true 或false 的表达式称为
4．当程序直接运行（未导入）时，__name__的值为
a．script  
c．__main__ 
5．bool 类型的字面量是        。 
b．True,False  
c．true,false  
6．在另一个判断内部做出判断是
7．在Python 中，判断的body 表示为
8．一个判断导致另一组判断，这些判断又导致另一组判断，依此下去，这样的结构称
为判断        。
9．用math.sqrt 取负值的平方根产生
a．ValueError  
10．多项选择问题最类似于        。 
d．异常处理程序 
1．用你自己的话解释以下模式。 
2．用try/except 处理异常与用普通判断结构（if 的变体）处理异常有什么异同？ 
3．下面是一个（愚蠢的）判断结构： 
a, b, c = eval(input(’Enter three numbers: ’)) 
print("It’s a late parrot!") 
显示以下每种可能输入产生的输出：
a．3, 4, 5 
b．3, 3, 3 
c．5, 4, 3 
d．3, 5, 2 
e．5, 4, 7 
f．3, 3, 2 
1．许多公司对每周超出40 小时以上的工作时间支付150%的工资。编写程序输入工作
小时数和小时工资，并计算一周的总工资。
2．某位CS 教授给出了5 分的小测验，评分等级为5-A，4-B，3-C，2-D，1-E，0-F。
编写一个程序，接受测验得分作为输入，并使用判断结构来计算相应的等级。
3．某位CS 教授给出了100 分的考试，分级为90～100：A，80～89：B，70～79：C，
60～69：D，<60：F。编写一个程序，将考试分数作为输入，并使用判断结构来计算相应的
4．某所大学根据学生拿到的学分对学生分年级。小于7 学分的学生是大一新生。至少
有7 个学分才是大二，16 分以上是大三，26 分以上是大四。编写一个程序，根据获得的学
5．身体质量指数（BMI）的计算公式是人的体重（以磅计）乘以720，再除以人的身
高（以英寸计）的平方。BMI 在19～25 范围内（包括边界值）被认为是健康的。编写一个
程序，计算人的BMI，并打印一条消息，告诉他们是在健康范围之上、之中还是之下。 
6．Podunksville 的超速罚单政策是50 美元加上超速部分每mph（一英里每小时）5 美
元，如果超过90mph 再追加罚款200 美元。编写一个程序，接受速度限制和计时速度，并
打印一条消息，表明速度合法，或者在速度非法时，打印罚款。
7．一个保姆每小时收费2.50 美元直到晚上9:00，然后一小时降到1.75 美元（孩子们
在床上）。编写一个程序，接受以小时和分钟为单位的开始时间和结束时间，并计算总的保
姆账单。可以假设开始和结束时间在一个24 小时内。不足1 小时的应该适当地按比例分配。 
第7 章  判断结构
8．如果一个人至少30 岁，并且成为美国公民至少9 年，就有资格成为美国参议员。
作为美国众议员，年限分别是25 岁和7 年。编写一个程序，接受一个人的年龄和公民年数
作为输入，并输出他的参议院和众议院资格。
9．计算1982～2048 年的复活节的计算公式如下：令a = year%19, b = year%4, c = year%7, 
d = (19a + 24)%30, e = (2b +4c +6d + 5)%7。复活节的日期是3 月22 日+ d + e（可能在4 月）。
写一个程序，输入年份，验证它在适当的范围，然后打印出那一年复活节的日期。
10．除1954 年、1981 年、2049 年和2076 年以外，上一个问题中复活节的公式适用于
1900～2099 年。对于这四年，它产生的日期晚了一个星期。修改上述程序，让它适用于1900～
2099 的所有年份。 
11．某年是闰年，如果它可以被4 整除，除非它是世纪年份但不能被400 整除（1800
和1900 不是闰年，而1600 和2000 是。）编写一个程序，计算某年是否为闰年。 
12．编写一个程序，以月/日/年的形式接受日期，并输出日期是否有效。例如5/24/1962
是有效的，但9/31/2000 不是。（9 月只有30 天。） 
13．一年中的第几天通常从1～365（或366）。这个数字可以用整数算术，利用三个步
（a）dayNum = 31(month − 1) + day。
（b）如果月份是在二月份之后减去（4（month）+ 23）// 10。
（c）如果是闰年并在2 月29 日之后，加1。
编写一个程序，以月/日/年的形式接受一个日期，验证它是一个有效的日期（见上一个
问题），然后计算相应的天数。
14．做第4 章的编程练习7，但添加一个判断来处理直线不与圆相交的情况。 
15．做第4 章的编程练习8，但添加一个判断，以防止程序除以零，如果线是垂直的。 
16．射箭计分程序。编写一个绘制箭靶的程序（参见第4 章的程序练习2），并允许用
户点击五次以表示在目标处射击的箭头。采用五级评分，靶心（黄色）得9 分，后续每个
环减2 分，直到白色为1 分。该程序应输出每次点击的分数，并记录整个过程的动态总分。 
17．编写一个程序，用动画显示在窗口中弹跳的圆。基本思想是在窗口内部的某处启
动圆。用变量dx 和dy（都初始化为1）来控制圆的运动。采用大计数循环（例如10000
次迭代），每次循环利用dx 和dy 移动圆。当圆心的x 值过高（碰到边缘）时，将dx 更改
为−1。当它变得太低时，将dx 更改为1。对dy 使用类似的方法。 
注意：你的动画可能会运行得太快。你可以通过使用图形库的更新速率参数来减慢速
度。例如，下面的循环将被限制，以每秒30 次的速率执行： 
18．从上一章找一个最喜欢的编程问题，并根据需要添加判断和/或异常处理，让它真
正健壮（不会因任何输入而崩溃）。与朋友交流你的程序，比赛看看谁可以“攻破”对方的
  理解确定和不定循环的概念，以及它们用Python 的for 和while 语句的实现。 
  理解交互式循环和哨兵循环的编程模式，以及它们用Python 的while 语句的实现。 
  理解文件结束循环的编程模式，以及在Python 中实现这种循环的方法。 
能为涉及循环模式（包括嵌套循环结构）的问题设计和实现解决方案。
理解布尔代数的基本思想，并能分析和编写涉及布尔运算符的布尔表达式。
8.1  for 循环：快速回顾 
在第7 章，我们详细介绍了Python 的if 语句，以及它在实现一些编程模式时的应用，
如单路、两路和多路的判断。本章将详细介绍循环和布尔表达式，圆满完成我们的控制结
你已知道Python 的for 语句提供了一种循环。它允许我们遍历一系列值。 
循环索引变量var 依次取序列中的每个值，循环体中的语句针对每个值执行一次。 
假设我们要编写一个程序，计算用户输入的一系列数字的平均值。为了让程序通用，
它应该适用于任意大小的数字。你知道平均值是通过对数字求和并除以数字的个数来计算
的。我们不需要记录所有输入的数字,只需要一个不断增长的总和，以便最后计算平均值。 
这个问题描述应该会触发你的一些灵感。它让你希望用以前看过的一些设计模式。我
们正在处理一系列数字：它们将由某种形式的循环来处理。如果有n 个数字，循环应该执
行n 次，我们可以用计数的循环模式。我们还需要一个不断增长的总和，这需要一个循环
累积器。将两个想法结合在一起，我们可以为这个问题生成一个设计：
希望你看到集成在这个设计中的计数循环和累积器模式。我们几乎可以将该设计直接
转化为Python 实现： 