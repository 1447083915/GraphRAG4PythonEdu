3.1  数值数据类型 
计算机刚开发出来时，它们主要被视为数字处理器，现在这仍然是一个重要的应用。
如你所见，涉及数学公式的问题很容易转化为Python 程序。在本章中，我们将仔细观察一
些程序，它们的目的是执行数值计算。
计算机程序存储和操作的信息通常称为“数据”。不同种类的数据以不同的方式存储和
操作。请考虑这个计算零钱的程序：
下面是输出示例：
第3 章  数字计算
这个程序实际上操作两种不同的数字。用户输入的值（5，3，4，6）是整数，它们
没有任何小数部分。硬币的值（.25，.10，.05，.01）是分数的十进制表示。在计算机内
部，整数和具有小数部分的数字以不同的方式存储。从技术上讲，这是两种不同的“数
对象的数据类型决定了它可以具有的值以及可以对它执行的操作。整数用“integer”数
据类型（简写为“int”）表示。int 类型的值可以是正数或负数。可以具有小数部分的数字表
示为“floating-point（浮点）”（或“float”）值。那么我们如何判断一个数值是int 还是float
呢？不包含小数点的数值字面量生成一个int 值，但是具有小数点的字面量由float 表示（即
使小数部分为0）。 
Python 提供了一个特殊函数，名为type，它告诉我们任何值的数据类型（或“class”）。
下面是与Python 解释器的交互，显示int 和float 字面量之间的区别： 
你可能希望知道，为什么有两种不同的数据类型。一个原因涉及程序风格。表示计数
的值不能为小数，例如，我们不能有3.12 个季度。使用int 值告诉读者程序的值不能是一个
分数。另一个原因涉及各种操作的效率。对于int，执行计算机运算的基础算法更简单，因
此可以更快，而float 值所需的算法更通用。当然，在现代处理器上，浮点运算的硬件实现
是高度优化的，可能与int 运算一样快。 
int 和float 之间的另一个区别是，float 类型只能表示对实数的近似。我们会看到，存储
值的精度（或准确度）存在限制。由于浮点值不精确，而int 总是精确的，所以一般的经验
法则应该是：如果不需要小数值，就用int。 
值的数据类型决定了可以使用的操作。如你所见，Python 支持对数值的一般数学运算。
表3.1 总结了这些操作。实际上，这个表有些误导。由于这两种类型具有不同的底层表示，
所以它们各自具有不同的一组操作。例如，我只列出了一个加法操作，但请记住，对float
值执行加法时，计算机硬件执行浮点加法，而对int 值，计算机执行整数加法。Python 基于
操作数选择合适的底层操作（int 或float）。 
3.1  数值数据类型 
Python 内置的数值操作 
请考虑以下Python 交互： 
在大多数情况下，对float 的操作产生float，对int 的操作产生int。大多数时候，我们
甚至不必担心正在执行什么类型的操作。例如，整数加法与浮点加法产生的结果几乎相同，
我们可以相信Python 会做正确的事情。 
然而，在除法时，事情就比较有趣了。如表所列，Python（版本3.0）提供了两种不同
的运算符。通常的符号（/）用于“常规”除法，双斜线（//）用于表示整数除法。找到它们
之间差异的最佳方法就是试一下。
第3 章  数字计算
请注意，“/”操作符总是返回一个浮点数。常规除法通常产生分数结果，即使操作数可
能是int。Python 通过返回一个浮点数来满足这个要求。10/3 的结果最后有一个5，你是否
感到惊讶？请记住，浮点值总是近似值。该值与Python 将3 1
3 表示为浮点数时得到的近似
要获得返回整数结果的除法，可以使用整数除法运算“//”。整数除法总是产生一个整
数。 把整数除法看作gozinta（进入或整除）。表达式10 // 3 得到3，因为3 进入 10 共计3
次（余数为1）。虽然整数除法的结果总是一个整数，但结果的数据类型取决于操作数的数
据类型。浮点整数整除浮点数得到一个浮点数，它的分数分量为0。最后两个交互展示了余
数运算%。请再次注意，结果的数据类型取决于操作数的类型。 
由于数学背景不同，你可能没用过整数除法或余数运算。要记住的是，这两个操作是
密切相关的。整数除法告诉你一个数字进入另一个数字的次数，剩余部分告诉你剩下多少。
数学上你可以写为a = (a//b)(b) + (a%b)。 
作为示例应用程序，假设我们以美分来计算零钱（而不是美元）。如果我有383 美分，
那么我可以通过计算383 // 100 = 3 找到完整美元的数量，剩余的零钱是383%100 = 83。因
此，我肯定共有3 美元和83 美分的零钱。 
顺便说一句，虽然Python（版本3.0）将常规除法和整数除法作为两个独立的运算符，
但是许多其他计算机语言（和早期的Python 版本）只是使用“/”来表示这两种情况。当操
作数是整数时，“/”表示整数除法，当它们是浮点数时，它表示常规除法。这是一个常见的
错误来源。例如，在我们的温度转换程序中，公式9/5 * celsius + 32 不会计算正确的结果，
因为9/5 将使用整数除法计算为1。在这些语言中，你需要小心地将此表达式编写为9.0 / 5.0 
* celsius + 32，以便使用正确的除法形式，从而得到分数结果。
3.2  类型转换和舍入 
在某些情况下，值可能需要从一种数据类型转换为另一种数据类型。你已知道，int 和
int 组合（通常）产生一个int，float 和float 组合创建另一个float。但是如果我们写一个混合
int 和float 的表达式会发生什么呢？例如，在下列赋值语句之后，x 的值应该是什么： 
如果这是浮点乘法，则结果应为浮点值10.0。如果执行整型乘法，结果就是10。在继
续读下去获得答案之前，请花一点时间考虑：你认为Python 应该怎样处理这种情况。 
为了理解表达式5.0 * 2，Python 必须将5.0 转换为5 并执行int 操作，或将2 转换为2.0
并执行浮点操作。一般来说，将float 转换为int 是一个危险的步骤，因为一些信息（小数部
分）会丢失。另一方面，int 可以安全地转换为浮点，只需添加一个小数部分0。因此，在
“混合类型表达式”中，Python 会自动将int 转换为浮点数，并执行浮点运算以产生浮点数
3.2  类型转换和舍入 
有时我们可能希望自己执行类型转换。这称为显式类型转换。Python 为这些场合提供
了内置函数int 和float。以下一些交互示例说明了它们的行为： 
如你所见，转换为int 就是丢弃浮点值的小数部分，该值将被截断，而不是舍入。如果
你希望一个四舍五入的结果，假设值为正，可以在使用int()之前加上0.5。对数字进行四舍
五入的更一般方法是使用内置的round 函数，它将数字四舍五入到最接近的整数值。 
请注意，像这样调用round 会产生一个int 值。因此，对round 的简单调用是将float 转
换为int 的另一种方法。 
如果要将浮点值舍入为另一个浮点值，则可以通过提供第二个参数来指定在小数点后
的数字位数。下面的交互处理π 的值： 
请注意，当我们将π近似舍入到两位或三位小数时，我们得到一个浮点数，其显示值
看起来像一个完全舍入的结果。记住，浮点值是近似。真正得到的是一个非常接近我们要
求的值。实际存储的值类似于3.140000000000000124345……，最接近的可表示的浮点值为
3.14。幸运的是，Python 是聪明的，知道我们可能不希望看到所有这些数字，所以它显示了
舍入的形式。这意味着如果你编写一个程序，将一个值四舍五入到两位小数，并打印出来，
就会看到两位小数，与你期望的一样。在第5 章中，我们将看到如何更好地控制打印数字
的显示方式，那时如果你希望，就能查看所有的数字。
类型转换函数int 和float 也可以用于将数字字符串转换为数字。 
作为替代eval 从用户获取数字数据的另一种方法，这特别有用。例如，下面是本章开
第3 章  数字计算
始时零钱计数程序的一个改进版本：
在input 语句中使用int 而不是eval，可以确保用户只能输入有效的整数。任何非法（非
int）输入将导致程序崩溃和错误消息，从而避免代码注入攻击的风险（在第2.5.2 节讨论）。
另一个好处是，这个版本的程序强调输入应该是整数。
使用数字类型转换代替eval 的唯一缺点是，它不支持同时输入（在单个输入中获取多
个值），如下例所示：
这个代价很小，换来了额外的安全性。在第5 章，你将学习如何克服这个限制。作为
一种良好的实践，你应该尽可能使用适当的类型转换函数代替eval。 
3.3  使用math 库 
除表3.1 中列出的操作之外，Python 还在一个特殊的math“库”中提供了许多其他有
用的数学函数。库就是一个模块，包含了一些有用定义。我们的下一个程序展示了使用这
个库来计算二次方程的根。
二次方程的形式为ax2 + bx + c = 0。这样的方程有两个解，由求根公式给出： 
让我们编写一个程序，找到二次方程的解。程序的输入将是系数a、b 和c 的值，输出
3.3  使用math 库 
是由求根公式给出的两个值。下面是完成这项工作的程序：
该程序使用了math 库模块的平方根函数sqrt。在程序的顶部，import math 告诉Python
我们正在使用math 模块。导入模块让程序中定义的任何内容都可用。要计算
用math.sqrt(x)。这个特殊的点符号告诉Python，使用“生存”在math 模块中的sqrt 函数。
在二次方程程序中，我们用下面的代码行来计算
下面是程序运行的情况：
只要我们要解的二次方程有实数解，这个程序就很好。但是，一些输入会导致程序崩
溃。下面是另一个运行示例：
第3 章  数字计算
这里的问题是b2 − 4ac < 0，sqrt 函数无法计算负数的平方根。Python 打印“math domain 
error”。这告诉我们，负数不在sqrt 函数的定义域中。现在，我们没有工具来解决这个问题，
所以我们只需要假设用户会给我们可解的方程。
实际上，quadratic.py 不需要使用math 库。我们可以用乘方**来取平方根。（你知道怎
么做吗？）使用math.sqrt 更高效一些，而且它让我展示使用math 库。一般来说，如果你的
程序需要一个通用的数学函数，首先要看看math 库。表3.2 显示了math 库中提供的一些其
一些math 库函数 
x 的自然对数（以e 为底） 
x 的常用对数（以10 为底） 
最小的>=x 的整数 
最大的<=x 的整数 
3.4  累积结果：阶乘 
假设你有一个根汁饮料样品包，含有6 种不同的根汁饮料。以不同的顺序喝各种口味
可能会影响它们的味道。如果你希望尝试一切可能，有多少不同的顺序？结果答案是一个
大得惊人的数字，720。你知道这个数字怎么来的吗？720 是6 的“阶乘”。 
在数学中，阶乘通常用感叹号（!）表示，整数n 的阶乘定义为n! = n(n – 1)(n – 2)……
(1)。这恰好是n 项的不同排列的数量。给定6 个项，我们计算6! = (6)(5)(4)(3)(2)(1) = 720
让我们编写一个程序，来计算用户输入数字的阶乘。程序的基本结构遵循“输入、处
理、输出”模式：
输入要计算阶乘的数，n 
计算n 的阶乘，fact 
3.4  累积结果：阶乘 
显然，这里棘手的是第二步。
实际如何计算阶乘？让我们手工尝试一下，以便得到处理的思路。在计算6 的阶乘时，
我们首先计算6(5) = 30。然后我们取该结果并做另一个乘法：30(4) = 120。这个结果乘以3：
120(3) = 360。这个结果乘以2：360(2) = 720。根据定义，最后我们将这个结果乘以1，但不
会改变最终值720。 
现在让我们考虑更一般的算法。这里实际上发生了什么？我们正在做重复乘法，在做
的过程中，我们记下得到的乘积。这是一种非常常见的算法模式，称为“累积器”。我们一
步一步得到（或累积）最终的值。为了在程序中实现这一点，我们使用“累积器变量”和
循环结构。一般模式如下：
初始化累积器变量 
循环直到得到最终结果 
更新累积器变量的值 
意识到这是解决阶乘问题的模式，我们只需要填写细节。我们将累积阶乘。让我们把
它保存在一个名为fact 的变量中。每次通过循环，我们需要用fact 乘以因子序列n、(n – 
1)、……、1 中的一个。看起来我们应该用一个for 循环，迭代这个因子序列。例如，要计
算6 的阶乘，我们需要像这样工作的循环： 
请花一分钟跟踪这个循环的执行，并说服自己它有效。当循环体首次执行时，fact 的值
为1，因子为6。因此，fact 的新值为1 * 6 = 6。下一次通过循环，因子将为5，fact 更新为
6 * 5 = 30。该模式对后续每个因子继续，直到累积得到最终结果720。 
循环之前对fact 赋初始值1，是循环开始所必需的。每次通过循环体（包括第一个），
fact 的当前值用于计算下一个值。初始化确保fact 在第一次迭代时有一个值。每次使用累积
器模式时，应确保包含正确的初始化。忘记这一点是新程序员的一个常见错误。
当然，我们还有很多其他的方法来编写这个循环。正如你从数学课上了解到的，乘法
是可交换和结合的，所以执行乘法的顺序并不重要。我们可以很容易地走另一个方向。你
可能还会注意到，在因子列表中包含1 是不必要的，因为乘以1 不会更改结果。下面是另
一个版本，计算出相同的结果：
不幸的是，这两个循环都不能解决原来的问题。我们手工编码了因子列表来计算6 的
阶乘。我们真正希望的是，一个可以计算任何给定输入n 的阶乘的程序。我们需要某种方
法，从n 的值生成适当的因子序列。 
好在用Python 的range 函数，这很容易做到。回想一下，range(n)产生一个数字序列，
从0 开始，增长到n，但不包括n。range 有一些其他调用方式，可用于产生不同的序列。利
用两个参数，range(start，n)产生一个以值start 开始的序列，增长到n，但不包括n。第三个
版本的range(start，n，step)类似于双参数版本，但它使用step 作为数字之间的增量。下面
第3 章  数字计算
给定输入值n，我们有几种不同的range 命令，能产生适当的因子列表，用于计算n 的
阶乘。为了从最小到最大生成它们（我们的第二种循环），我们可以使用range(2，n + 1)。
注意，我使用n + 1 作为第二个参数，因为范围将上升到n + 1，但不包括此值。我们需要加
1 来确保n 本身被包括，作为最后一个因子。 
另一种可能是使用三参数版本的range 和负数步长，产生另一个方向（我们的第一种循
环）的因子，导致倒计数：range(n，1，−1)。这个循环产生一个列表，从n 开始并向下计数
（step 为−1）到1，但不包括1。 
下面是一种可能的阶乘程序版本：
当然，写这个程序还有很多其他方法。我已经提到改变因子的顺序。另一种可能是将
fact 初始化为n，然后使用从n−1 开始的因子（只要n> 0）。你可以尝试这样一些变化，看
看你最喜欢哪一个。
3.5  计算机算术的局限性 
有时我们会联想到，用“!”表示阶乘是因为该函数增长非常快。例如，下面是用我们
的程序求100 的阶乘： 
这是一个相当大的数字！
尽管最新版本的Python 对此计算没有困难，但是旧版本的Python（以及其他语言的现
代版本，例如C ++和Java）不会如此。例如，下面是使用Java 编写的类似程序的几次运行： 
3.5  计算机算术的局限性 
这看起来不错。我们知道6! = 720。快速检查也确认12! = 479001600。遗憾的是，事实
证明，13! = 6227020800。看起来Java 程序给出了不正确的答案！ 
这里发生了什么？到目前为止，我们已经讨论了数值数据类型作为熟悉数字的表示，
例如整数和小数（分数）。然而，重要的是要记住，数字的计算机表示（实际数据类型）并
不总是表现得像它们所代表的数字那样。
在第1 章中你了解到，计算机的CPU 可以执行非常基本的操作，如两个数字相加或相
乘，还记得吗？更准确地说，CPU 可以对计算机的数字的内部表示执行基本操作。这个Java
程序的问题是它使用计算机的底层int 数据类型来表示整数，并依赖于计算机对int 的乘法
运算。不幸的是，这些机器int 不完全像数学整数。有无穷多个整数，但int 的范围是有限
的。在计算机内部，int 以固定大小的二进制表示存储。为了理解这一切，我们需要了解硬件
层面发生了什么。
计算机存储器由电“开关”组成，每个开关可以处于两种可能状态之一，即开或关。
每个开关表示一个二进制数字的信息，称为“位”。一位可以编码两种可能性，通常用数字
0（关闭）和1（打开）表示。位序列可以用于表示更多的可能性。用两位，我们可以表示
三位允许我们通过对四个两位模式中的每一个添加0 或1，来表示八个不同的值： 
你可以看到这里的模式。每增加一位让不同模式的数量加倍。通常，n 位可以表示2n
特定计算机用来表示int 的位数取决于CPU 的设计。现在，典型的PC 使用32 或64 位。
对于32 位CPU，这意味着有232 个可能的值。这些值以0 为中心，表示正整数和负整数的
范围。现在232/2 = 231。因此，可以在32 位int 值中表示的整数范围是−231 到231 − 1。在上
限−1 的原因是考虑在范围的上半部分中的0 的表示。 
第3 章  数字计算
有了这个知识，让我们试着理解Java 阶乘例子中发生的事情。如果Java 程序依赖于32
位int 表示，它可以存储的最大数字是多少？Python 可以给我们一个快速的答案： 
注意，这个值（约21 亿）在12!（约4.8 亿）和13！（约62 亿）之间。这意味着Java
程序可以很好地计算到12 的阶乘，但是之后，表示“溢出”，结果是垃圾。现在你知道了
为什么简单的Java 程序不能计算13!。当然，这给我们留下了另一个谜题。为什么现代Python
程序似乎能很好地用大整数计算？
首先，你可能认为Python 使用浮点数据类型来绕过int 的大小限制。然而，事实证明，
浮点数并没有真正解决这个问题。下面是使用浮点数的修改后的阶乘程序的示例运行：
虽然这个程序运行很好，但切换到浮点数后，我们不再能得到确切的答案。
非常大（或非常小）的浮点值使用“指数”的方式打印，称为“科学记数法”。结束时
的e + 32 表示结果等于2.6525285981219103 * 1032。你可以把+32 作为一个标记，表示小数
点的位置。在这个例子中，它必须向右移动32 个位置以获取实际值。但是，小数点右边只
有16 位数字，因此我们已经“丢失”了最后16 位数字。 
使用浮点数，我们可以表示比32 位int 更大的“范围”的值，但“精度”仍然是固定
的。事实上，计算机将浮点数保存为一对固定长度（二进制）整数。一个整数称为“尾数”，
表示值中的数字串，第二个称为“指数”，记录整数部分结束和小数部分开始的位置（“二
进制小数点”在哪里）。回忆一下，我告诉过你浮点是近似值。现在你可以看到原因。因为
底层数字是二进制的，所以只有涉及2 的幂的分数可以被精确地表示。任何其他分数产生
无限重复的尾数。（就像1/3 产生无限重复的十进制，因为3 不是10 的幂）。当无限长的尾
数被截断到固定长度以进行存储时，结果是近似的。用于尾数的位数决定了近似值的精确
程度，但绕不过它们是近似的事实。
幸运的是，Python 对于大的、精确的值有一个更好的解决方案。Python 的int 不是固定
的大小，而是扩展到适应任何值。唯一的限制是计算机可用的内存量。当值很小时，Python
就用计算机的底层int 表示和操作。当值变大时，Python 会自动转换为使用更多位的表示。
当然，为了对更大的数字执行操作，Python 必须将操作分解为计算机硬件能够处理的更小
的单元，类似于你手工计算长除法的方式。这些操作不会那么有效（它们需要更多的步骤），
但是它们允许Python 的int 增长到任意大小。这就是为什么我们的简单阶乘程序可以计算一
些大的结果。这是一个非常酷的Python 特性。 
本章介绍了一些有关进行数值计算的程序的重要细节。下面是一些关键概念的快速摘要。 
  计算机表示特定类型的信息的方式称为数据类型。对象的数据类型决定了它可以
具有的值和它支持的操作。
  Python 有几种不同的数据类型来表示数值，包括int 和float。 
  整数通常使用int 数据类型表示，小数值使用float 表示。所有Python 数字数据类
型都支持标准的内置数学运算：加法（+）、减法（−）、乘法（*）、除法（/），
整除（//），取余（%）和绝对值（abs(x)）。 
  Python 在某些情况下，自动将数字从一种数据类型转换为另一种。例如，在涉及int
和float 的混合类型表达式中，Python 先将int 转换为float，然后使用浮点运算。 
  程序还可以使用函数float()、int()和round()将一个数据类型显式转换为另一个数据
类型。通常应该使用类型转换函数代替eval 来处理用户的数字输入。 
  其他数学函数在math 库中定义。要使用这些功能，程序必须首先导入该库。 
数值结果通常通过计算值序列的和或积来计算。循环累积器编程模式对于这种计
  int 和float 在底层计算机上都使用固定长度的位序列表示。这让这些表示有某些限
制。在32 位的机器上，硬件int 必须在−231～231−1 中。浮点数的精度有限，不能
精确地表示大多数数字。
  Python 的int 数据类型可以用于存储任意大小的整数。如果int 值对于底层硬件int
太大，就会自动转换为更长的表示。涉及这些长int 的计算比只使用短int 的计算
1．由计算机存储和操作的信息称为数据。 
2．由于浮点数是非常准确的，所以通常应该使用它们，而不是int。 
3．像加法和减法这样的操作在math 库中定义。 
4．n 项的可能排列的数目等于n！。 
5．sqrt 函数计算数字的喷射（squirt）。 
6．float 数据类型与实数的数学概念相同。 
7．计算机使用二进制表示数字。 
8．硬件float 可以表示比硬件int 更大范围的值。 
9．在获取数字作为用户输入时，类型转换函数（如float）是eval 的安全替代。 
10．在Python 中，4 + 5 产生与4.0 + 5.0 相同的结果类型。 
项不是内置的Python 数据类型。 
第3 章  数字计算
c．rational  
d．string 
项不是内置操作。
d．sqrt() 
3．为了使用math 库中的函数，程序必须包括    。 
d．import 语句 
5．用于存储π的值，最合适的数据类型是    。 
c．irrational 
d．string 
6．可以使用5 位比特表示的不同值的数量是    。 
7．在包含int 和float 的混合类型表达式中，Python 会进行的转换是
a．浮点数到整数 
b．整数到字符串 
c．浮点数和整数到字符串 
d．整数到浮点数 
项不是Python 类型转换函数。 
9．用于计算阶乘的模式是
b．输入、处理、输出 
10．在现代Python 中，int 值大于底层硬件int 时，会    。 
b．转换为float 
d．使用更多的内存 
1．显示每个表达式求值的结果。确保该值以正确的形式表示其类型（int 或float）。如
果表达式是非法的，请解释为什么。
a．4.0 / 10.0 + 3.5 * 2
b．10 % 4 + 6 / 2 
b．abs(4 - 20 // 3) ** 3 
d．sqrt(4.5 - 5.0) + 7 * 3 
e．3 * 10 // 3 + 10 % 3
f．3 ** 3
2．将以下每个数学表达式转换为等效的Python 表达式。你可以假定math 库已导入（通
过import math）。 
a．(3 + 4)(5) 
3．显示将由以下每个range 表达式生成的数字序列。 
a．range(5)  
b．range(3, 10)
c．range(4, 13, 3) 
d．range(15, 5, -2)
e．range(5, 3)
4．显示以下每个程序片段产生的输出。 
a．for i in range(1, 11): 
b．for i in [1,3,5,7,9]:
d．ans = 0
5．如果使用负数作为round 函数中的第二个参数，你认为会发生什么？例如，
round(314.159265，−1)的结果应该是什么？请解释答案的理由。在你写下答案后，请参阅
Python 文档或尝试一些例子，看看Python 在这种情况下实际上做了什么。 
6．当整数除法或余数运算的操作数为负数时，你认为会发生什么？考虑以下每种情
况并尝试预测结果。然后在Python 中试试。（提示：回顾一下神奇的公式a = (a//b)(b) + 
a．−10 // 3 
b．−10 % 3 
c．10 // −3 
d．10 % −3 
e．−10 // −3 
1．编写一个程序，利用球体的半径作为输入，计算体积和表面积。以下是一些可能有
V = 4/3πr3 
A = 4πr2 
2．给定圆形比萨饼的直径和价格，编写一个程序，计算每平方英寸的成本。面积公式
为A = πr2。 
3．编写一个程序，该程序基于分子中的氢、碳和氧原子的数量计算碳水化合物的分子
量（以克/摩尔计）。程序应提示用户输入氢原子的数量、碳原子的数量和氧原子的数量。然
后程序基于这些单独的原子量打印所有原子的总组合分子量。
第3 章  数字计算
质量（克/摩尔） 
例如，水（H2O）的分子量为2（1.00794）+ 15.9994 = 18.01528。 
4．编写一个程序，根据闪光和雷声之间的时间差来确定雷击的距离。声速约为1100
英尺/秒，1 英里为5280 英尺。 
5．Konditorei 咖啡店售卖咖啡，每磅10.50 美元加上运费。每份订单的运费为每磅0.86
美元 +固定成本1.50 美元。编写计算订单费用的程序。 
6．使用坐标（x1，y1）和（x2，y2）指定平面中的两个点。编写一个程序，计算通过
用户输入的两个（非垂直）点的直线的斜率。
7．编写一个程序，接受两点（见上一个问题），并确定它们之间的距离。 
8．格里高利闰余是从1 月1 日到前一个新月的天数。此值用于确定复活节的日期。它
由下列公式计算（使用整型算术）：
编写程序，提示用户输入4 位数年份，然后输出闰余的值。 
9．使用以下公式编写程序以计算三角形的面积，其三边的长度为a、b 和c： 
10．编写程序，确定梯子斜靠在房子上时，达到给定高度所需的长度。梯子的高度和
角度作为输入。计算长度使用公式为：
注意：角度必须以弧度表示。提示输入以度为单位的角度，并使用以下公式进行转换： 
radians = π
11．编程计算前n 个自然数的和，其中n 的值由用户提供。 
12．编程计算前n 个自然数的立方和，其中n 的值由用户提供。 
13．编程对用户输入的一系列数字求和。 程序应该首先提示用户有多少数字要求和，
然后依次提示用户输入每个数字，并在输入所有数字后打印出总和。（提示：在循环体中使
14．编程计算用户输入的一系列数字的平均值。与前面的问题一样，程序会首先询问
用户有多少个数字。注意：平均值应该始终为float，即使用户输入都是int。 
15．编写程序，通过对这个级数的项进行求和来求近似的π 值：4/1 – 4/3 + 4/5 – 4/7 + 4/9 
− 4/11 +……程序应该提示用户输入n，要求和的项数，然后输出该级数的前n 个项的和。
让你的程序从math.pi 的值中减去近似值，看看它的准确性。 
16．斐波那契序列是数字序列，其中每个连续数字是前两个数字的和。经典的斐波那
契序列开始于1，1，2，3，5，8，13，……。编写计算第n 个斐波纳契数的程序，其中n
是用户输入的值。例如，如果n = 6，则结果为8。 
17．你已经看到math 库包含了一个计算数字平方根的函数。在本练习中，你将编写自
己的算法来计算平方根。解决这个问题的一种方法是使用猜测和检查。你首先猜测平方根
可能是什么，然后看看你的猜测是多么接近。你可以使用此信息进行另一个猜测，并继续
猜测，直到找到平方根（或其近似）。一个特别好的猜测方法是使用牛顿法。假设x 是我们
希望的根，guess 是当前猜测的答案。猜测可以通过使用计算下一个猜测来改进：
编程实现牛顿方法。程序应提示用户找到值的平方根（x）和改进猜测的次数。从猜测
值x / 2 开始，你的程序应该循环指定的次数，应用牛顿的方法，并报告猜测的最终值。你
还应该从math.sqrt(x)的值中减去你的估计值，以显示它的接近程度。 
理解对象的概念以及如何用它们来简化编程。
  熟悉graphics 库中可用的各种对象。 
能够在程序中创建对象并调用适当的方法来进行图形计算。
了解计算机图形学的基本概念，特别是坐标系统和坐标变换的作用。
了解如何在图形编程语境中使用基于鼠标和基于文本的输入。
  能够使用graphics 库编写简单的交互式图形程序。 
到目前为止，我们一直在使用Python 内置的数字和字符串数据类型来编写程序。我们
看到，每个数据类型可以表示一组特定的值，并且每个数据类型都有一组相关的操作。基
本上，我们将数据视为一些被动实体，通过主动操作来控制和组合它们。这是一种传统的
看待计算的视角。然而，为了构建复杂的系统，采用更丰富的视角来看待数据和操作之间
的关系是有帮助的。
大多数现代计算机程序是用“面向对象”（OO）方法构建的。面向对象不容易定义。它
包含了许多设计和实现软件的原则，我们将在本书的整个过程中反复提到。本章通过一些
计算机图形提供了对象概念的基本介绍。
图形编程很有乐趣，并提供了一种极好的方式来学习对象。在此过程中，你还将学习
计算机图形学的一些原理，它们是许多现代计算机应用程序的基础。你熟悉的大多数应用
程序可能有一个所谓的“图形用户界面”（GUI），提供了诸如窗口、图标（代表性图片）、
按钮和菜单等可视元素。
交互式图形编程可以非常复杂，有一些教科书整本书都在讲复杂的图形和图形界面。
工业级的GUI 应用程序通常使用专用的图形编程框架来开发。Python 自带的标准GUI 模块
名为Tkinter。Tkinter 是最易用的GUI 框架之一，Python 是开发真实世界GUI 的极好语言。
然而，在你的编程生涯中，此时学习任何GUI 框架的复杂细节都将是一个挑战，而且这样
做不会对达成本章的主要目标有所帮助。本章的主要目标是向你介绍对象和计算机图形学
为了让这些基本概念更容易学习，我们将使用专门为本教材编写的图形库（graphics.py）。
4.3  简单图形编程 
这个库是Tkinter 的一层包装，让它更适合新程序员。它是作为一个Python 模块文件免费提
①，欢迎你使用它，只要你认为合适。最终，你可能希望研究该库本身的代码，作为学
习如何直接用Tkinter 编程的垫脚石。 
4.2  对象的目标 
面向对象开发的基本思想，是将一个复杂的系统视为一些较简单“对象”的交互。这
里使用的“对象”一词有特定的技术意义。OO 编程的一部分挑战是弄清楚词汇表。你可以
将OO 对象视为一种结合数据和操作的主动数据类型。简单来说，对象“知道一些事情”（它
们包含数据），并且可以“做一些事情”（它们有操作）。对象通过彼此发送消息来交互。消
息就是请求，让对象执行它的一个操作。
请考虑一个简单的例子。假设我们希望为学院或大学开发数据处理系统。我们需要记
录相当多的信息。首先，必须记录入学的学生。每个学生都可以在程序中表示为一个对象。
学生对象将包含一些特定数据，如姓名、ID 号、所选的课程、校园地址、家庭地址、GPA
等。每个学生对象也能够响应某些请求。例如，要发送邮件，我们需要为每个学生打印一
个地址。此任务可能由printCampusAddress 操作处理。如果向一个特定的学生对象发送
printCampusAddress 消息，它就打印出自己的地址。要打印出所有的地址，程序将循环遍历
学生对象的集合，并依次发送printCampusAddress 消息。 
对象可以引用其他对象。在我们的示例中，学院中的每门课程也可能由一个对象表示。
课程对象将知道一些信息，如教师是谁、课程中有哪些学生、先决条件是什么以及课程的
时间地点。一个操作的例子可能是addStudent，它导致学生在课程中注册。正在注册的学生
将由适当的学生对象表示。教师将是另一种对象，房间也是，甚至时间也是。你可以看到
这些想法如何不断细化，从而得到一个相当复杂的大学信息结构模型。
作为一名新程序员，你可能还没有准备好处理大学信息系统。现在，我们将在一些简
单的图形编程的语境中研究对象。
4.3  简单图形编程 
为了在本章（以及本书的其余部分）中运行图形程序和示例，你需要graphics.py 的拷
贝，它与补充材料一起提供。使用graphics 库很简单，只要将graphics.py 文件的拷贝与图
形程序放在同一文件夹中。或者，你可以将它放在存储其他Python 库的系统目录中，以便
能够在系统的任何文件夹中使用它。
graphics 库让我们可以轻松地体验交互方式图形，编写简单的图形程序。在做的过程中，
你将学习面向对象编程和计算机图形学的原理，可以在更复杂的图形编程环境中应用。graphics
模块的细节将在后面的部分探讨。在这里，我们将专注于基本实战介绍，让你有点感觉。
①graphics 模块可从本书的支持网站获得。 
第4 章  对象和图形
像往常一样，开始学习新概念的最好方法是尝试一些例子。第一步是导入graphics 模块。
假设你已将graphics.py 放置在适当的位置，可以将graphics 的命令导入到交互式Python 会
话中。如果你在使用IDLE，可能必须首先将IDLE“指向”保存graphics.py 的文件夹。实
现这一点的简单方法，是从该文件夹加载并运行一个原有的程序。然后你应该能够将
graphics 导入shell 窗口： 
如果这个导入失败，就意味着Python 找不到graphics 模块。应确保文件放在正确的文
件夹中，然后重试。
接下来，我们需要在屏幕上创建一个地方来显示图形。这个地方是一个“图形窗口”，
即GraphWin，它由graphics 模块提供： 
注意，使用点符号来调用位于graphics 库中的GraphWin 函数。这类似于用math.sqrt(x)
从math 库模块中调用平方根函数。GraphWin()函数在屏幕上创建一个新窗口。该窗口的标
题是“Graphics Window”。GraphWin 可能遮住你的Python shell 窗口，因此你可能要调整大
小或移动shell，让两个窗口完全可见。图4.1 展示了一个屏幕视图的样子。 
图4.1 带有Python shell 和GraphWin 的屏幕截图 
GraphWin 是一个对象，我们将它赋给变量win。我们现在可以通过这个变量来操作窗
口对象。例如，我们用完窗口后，可以销毁它。这可以通过发出close 命令来做到： 
4.3  简单图形编程 
键入此命令将导致窗口从屏幕中消失。
注意，我们再次使用了点表示法，但现在使用它时，在点的左侧用了变量名称，而不
是模块名称。回想一下，win 早先被赋为GraphWin 类型的对象。GraphWin 对象可以做的事
情之一是关闭自己。你可以将该命令视为调用与这个窗口相关联的close 操作。结果是窗口
顺便说一句，我应该在这里提到，像这样交互式尝试图形命令，在一些环境中可能很
棘手。如果你在IDE 中使用shell（如IDLE），则有可能在你的特定平台上图形窗口表现为
无响应。例如，当你将鼠标悬停在窗口上时，可能会看到“忙”光标，你可能无法拖动窗
口来定位它。在某些情况下，你的图形窗口可能完全隐藏在IDE 下面，你必须去搜索它。
这些故障是由于IDE 和图形窗口都努力控制你的交互。尽管你在玩交互式图形时可能遇到
困难，但请放心，使用graphics 库的程序在大多数标准环境中应该运行良好。它们肯定能在
Windows、macOS 和Linux 下工作。 
我们将使用来自graphics 库的许多命令，每次我们使用一个命令就不得不键入
“graphics”符号，这很无趣。Python 的另一种导入方式有所帮助： 
from 语句允许你从库模块加载特定的定义。你可以列出要导入定义的名称，也可以使
用星号（如上）导入模块中定义的所有内容。导入的命令可直接使用，而无需使用模块名
称前缀。完成这个导入后，我们可以更简单地创建GraphWin： 
接下来所有的graphics 示例将假设整个graphics 模块已用from 导入。 
让我们动手尝试绘制一些图形。图形窗口实际上是一些小点的集合，这些小点称为“像
素”（“图像元素”的缩写）。通过控制每个像素的颜色，我们控制窗口中显示的内容。默认
情况下，GraphWin 的高度为200 像素，宽度为200 像素。这意味着GraphWin 中有4 万像
素。通过为每个单独的像素分配颜色来绘制图像将是一个艰巨的挑战。作为替代，我们将
依赖一个图形对象库。每种类型的对象都记录自己的信息，并知道如何将自己绘制到
GraphWin 中。 
图形模块中最简单的对象是Point（点）。在几何中，点是空间中的位置。通过参考坐标
系来定位点。我们的图形对象Point 是类似的，它可以表示GraphWin 中的一个位置。我们通
过提供x 和y 坐标（x, y）来定义一个点。x 值表示点的水平位置，y 值表示点的垂直位置。 
传统上，图形程序员将点(0, 0)定位在窗口的左上角。因此，x 值从左到右增加，y 值从
上到下增加。在默认的200×200 GraphWin 中，右下角坐标为(199, 199)。绘制点将设置
GraphWin 中对应像素的颜色。绘图的默认颜色为黑色。 
下面是一个与Python 交互的示例，展示了Point 的用法： 
第4 章  对象和图形
第一行创建了一个位于（50, 60）的Point。创建Point 后，它的坐标值可以通过getX
和getY 操作来访问。与所有函数调用一样，在尝试使用操作时，应确保将括号放在末尾。
用draw 操作将点绘制到窗口中。这个例子创建了两个不同的Point 对象（p 和p2），并绘制
到GraphWin 对象中，其名为win。图4.2 展示了生成的图形输出。 
除了点，graphics 库还包含了一些命令，用于绘制线段、圆、矩形、椭圆、多边形和文
本。这些对象中的每一个都以类似的方式创建和绘制。下面的示例交互将各种形状绘制到
GraphWin 中： 
请尝试弄清楚其中每个语句所做的事。如果你照样输入它们，最终的结果如图4.3 所示。 
图4.2 绘制两个点的图形窗口
图4.3 graphics 模块的各种形状 
4.4  使用图形对象 
以上交互中的一些示例可能看起来有点奇怪。为了真正理解graphics 模块，我们需要采
取面向对象的视角。记住，对象让数据与操作相结合。要求对象执行它的一个操作，就执
4.4  使用图形对象 
行了计算。为了使用对象，你需要知道如何创建它们以及如何请求操作。
在上面的交互示例中，我们处理了GraphWin、Point、Circle、Oval、Line、Text 和Rectangle
等几种不同类型的对象。这些是“类”的示例。每个对象都是某个类的“实例”，类描述了
实例将具有的属性。
借用一个生物学的隐喻，如果我们说Fido 是一只狗，实际上是说，Fido 是所有狗构成
的大类中的一个特定个体。用OO 术语来说，Fido 是狗类的一个实例。因为Fido 是这个类
的一个实例，我们有某些预期。Fido 有四条腿，一条尾巴，冷而湿润的鼻子，会吠叫。如
果Rex 是狗，我们预期它会有类似的属性，即使Fido 和Rex 可能在具体细节上不同，如大
同样的想法对我们的计算对象也成立。我们可以创建两个单独的Point 实例，例如p 和
p2。 每个点都有x 和y 值，它们都支持相同的操作集，如getX 和draw。这些属性成立，
因为对象是Point。然而，不同的实例可以在特定细节（诸如它们的坐标值）上变化。 
要创建一个类的新实例，我们使用一个特殊操作，称为“构造函数”。对构造函数的调
用是一个表达式，它创建了一个全新的对象。一般形式如下：
这里<class-name>是我们要创建一个新实例的类的名称，例如Circle 或Point。括号中的
表达式是初始化对象所需的任何参数。参数的数量和类型取决于该类。Point 需要两个数字
值，而GraphWin 可以不使用任何参数。通常，在赋值语句的右侧使用构造函数，生成的对
象立即赋给左侧的变量，然后用它来操作该对象。
举一个具体的例子，让我们来看看创建一个图形点时会发生什么。下面是来自上面的
交互示例的构造函数语句：
Point 类的构造函数需要两个参数，给出新点的x 和y 坐标。这些值作为“实例变量”
存储在对象内。在这种情况下，Python 创建一个Point 的实例，其x 值为50，y 值为60。然
后将生成的点赋给变量p。 
结果的概念图如图4.4 所示。注意，在该图以及类
似的图中，仅示出最突出的细节。点还包含其他信息，
如它们的颜色以及它们绘制在哪个窗口（如果有的话）。
在创建点时，大多数信息设置为默认值。
为了让对象执行操作，我们向对象发送一条消息。
对象响应的消息集称为对象的“方法”。你可以将方法
看作是存在于对象中的函数。使用点表示法来调用方法。
参数的数量和类型由所用的方法决定。一些方法根本不需要参数。你可以在上面的交
互示例中找到许多方法调用的例子。
作为无参数方法的示例，请考虑下面两个表达式：
图4.4 变量p 指的是一个新的Point 
第4 章  对象和图形
getX 和getY 方法分别返回点的x 和y 值。这些方法有时被称为“取值方法”，因为它
们允许我们从对象的实例变量访问信息。
其他方法改变了对象的实例变量的值，因此改变了对象的“状态”。所有图形对象都有
一个move 方法。下面是规格说明： 
move(dx,dy)：让对象在x 方向上移动dx 单位，在y 方向上移动dy 单位。 
要将点p 移动到右边10 个单位，我们可以用下列语句： 
这改变了p 的x 实例变量，添加了10 个单位。如果该点当前在GraphWin 中绘制，则
move 将负责擦除旧图像并在新位置绘制。改变对象状态的方法有时称为“设值方法”。 
move 方法必须提供两个简单的数字参数，指示沿每个维度移动对象的距离。一些方法
需要的参数本身也是复杂对象。例如，将Circle 绘制到GraphWin 中涉及两个对象。让我们
来看一个命令序列：
第一行创建一个圆，其中心位于Point(100, 100)，半径为30。请注意，我们使用Point 构造
函数为Circle 构造函数创建了第一个参数的位置。第二行创建一个GraphWin。你看到第三行发
生了什么吗？这是对Circle 对象的请求，用于将自己绘制到GraphWin 对象中。该语句的可视
效果就是GraphWin 中的一个圆，中心在(100, 100)，半径为30。在幕后，发生了更多事情。 
记住，draw 方法存在于circ 对象内部。使用来自实例变量的关于圆的中心和半径的信
息，draw 方法向GraphWin 发出适当的低级绘图命令序列（一系列方法调用）。Point、Circle
和GraphWin 对象之间的交互的概念图如图4.5 所示。幸运的是，我们通常不必担心这些细
节，它们都由图形对象来处理。我们只是创建对象、调用适当的方法，让它们完成工作。
这就是面向对象编程的力量。
图4.5 绘制圆的对象交互 
4.4  使用图形对象 
在使用对象时，需要记住一点微妙的“领悟”。两个不同的变量指的对象可能完全相同，
通过一个变量对对象所做的更改也会对另一个变量可见。例如，假设我们试图写一段绘制
笑脸的代码。我们希望创建两个相距20 个单位的眼睛。下面是画眼睛的代码序列： 
基本思想是创建左眼，然后将其复制到右眼，再移动20 个单位。 
这不行。这里的问题是只创建了一个Circle 对象。赋值rightEye = leftEye 只是让rightEye
指向与leftEye 完全相同的圆。图4.6 展示了这种情况。在最后一行代码中移动圆时，rightEye
和leftEye 都在它右边的新位置引用它。这种情况下，两个变量引用同一个对象称为“别名”，
它有时会产生意想不到的结果。
图4.6 变量leftEye 和rightEye 是别名 
这个问题的一个解决方案是为每只眼睛创建一个单独的圆：
这肯定行，但它很麻烦。我们不得为双眼写重复的代码。虽然用“剪切”和“粘贴”
的方法很容易做到，但它不是很优雅。如果我们决定改变眼睛的外观，我们必须确保在两
个地方进行更改。
graphics 库提供了更好的解决方案，所有图形对象都支持复制对象的clone 方法。利用
clone，我们可以挽救原来的方法： 
有策略地使用clone 可以让一些图形任务更容易。 
第4 章  对象和图形
4.5  绘制终值 
在对如何使用graphics 的对象有了一些概念之后，我们就可以尝试一些真正的图形编
程。图形的最重要的用途之一是提供数据的可视表示。人们说一张图值一千字，它几乎肯
定比一千个数字更好。任何操作数字数据的程序都可以通过输出一点图形来改进。还记得
第2 章中计算十年投资终值的程序吗？让我们试着创建一个图形汇总。 
使用图形编程需要仔细规划。在规划时，你可能需要铅笔和纸张，绘制一些图表并勾
画一些计算草图。像往常一样，我们首先考虑程序要做什么的规格说明。
原来的程序futval.py 有投资金额和年利率两个输入。利用这些输入，该程序用公式
principal = principal * (1 + apr) 计算逐年的本金变化，共10 年。然后打印出本金的最终值。
在图形版本中，输出将是十年的条形图，其中连续条形的高度表示连续几年中本金的值。
让我们用一个具体的例子来说明。假设我们以10%的利率投资2000 美元。表4.1 展示
了十年期间投资的增长情况。我们的程序将在条形图中显示此信息。图4.7 以图形方式显示
了相同的数据。该图形包含十一个柱形，第一个柱形显示本金的原始值。为了引用方便，
让我们根据累计利息的年数对这些柱形进行编号，从0 到10。 
以10%利率计算的2000 美元增长的情况 
下面是程序的大致设计：
从用户处获取principal 和apr 
创建一个GraphWin 
在窗口的左侧绘制刻度标签 
在位置0 处绘制柱形，高度对应principal 
对接下来的1 到10 年 
计算principal = principal * (1 + apr) 
绘制该年的柱形，高度对应principal 
等待用户按下回车键。 
4.5  绘制终值 
最后一步产生的暂停对于保持图形窗口显示是必要的，这样我们就可以解读结果。没
有这样的暂停，程序将结束，GraphWin 会消失。 
虽然这个设计为我们的算法提供了粗线条的描
述，但有一些非常重要的细节被掩藏了。我们必须
确定图形窗口将有多大，以及如何定位出现在此窗
口中的对象。例如，“绘制第五年的柱形，对应高度
为3221.02 美元”是什么意思？ 
让我们从GraphWin 的大小开始。回想一下，
窗口的大小是根据每个维度中的像素数量给出的。
计算机屏幕也以像素为单位度量。屏幕的像素数或
分辨率由你用的计算机中的显示器和显卡决定。最
近在个人计算机上可能遇到的最低分辨率屏幕是所
谓的扩展VGA 屏幕，是1024 像素×768 像素。大多
数屏幕相当大。我们默认的200 像素×200 像素窗口可能看起来有点小。我们让GraphWin
的大小为320 像素×240 像素，这使它大约占1/8 的小屏幕大小。 
鉴于这种分析，我们可以让设计具体一点。设计的第三行现在应该是：
创建一个320 像素×240 像素的GraphWin，标题为“Investment Growth Chart” 
你可能希望知道如何将它转换为Python 代码。你已经看到GraphWin 构造函数允许一
个可选参数指定窗口的标题。你还可以提供width 和height 参数来控制窗口的大小。因此，
创建输出窗口的命令将是：
接下来我们讨论沿着窗口左侧边缘显示标签的问题。为了简化问题，我们假设图形的
刻度最大总是10000 美元，带有五个标签“0.0K”到“10.0K”，如示例窗口所示。问题是如
何绘制标签？我们需要一些Text 对象。创建Text 时，我们指定锚点（文本居中的点）以及
用作标签的字符串。
标签字符串很容易。最长的标签是五个字符，标签应该都在列的右侧排列，因此较短
字符串的左侧将用空格填充。选择标签的位置需要一点计算和试错。通过一些交互尝试，
水平方向上长度为5 的字符串，将中心放在从左边缘开始20 个像素的位置，这样看起来很
好。在边缘只留下一点空白。
在垂直方向，有超过200 像素。简单的刻度将是用100 像素代表5000 美元。这意味着我
们的五个标签应该间隔50 像素。用200 像素表示范围0～10000，留下240 % 200 = 40 像素，
分开来作为顶部和底部边距。我们可能希望在顶部多留一点边距，以容纳超过10000 美元的值。
通过一个小的实验表明，将“0.0K”标签放在离底部10 像素（位置230），看起来挺好。 
细化我们的算法，包括这些细节，“在窗口的左侧绘制刻度标签”这一步变成一系列步骤： 
在(20, 230)绘制标签" 0.0K" 
在(20, 180)绘制标签" 2.5K" 
在(20, 130)绘制标签" 5.0K" 
在(20, 80)绘制标签" 7.5K" 
在(20, 30)绘制标签"10.0K" 
图4.7 柱状图显示在10%利率时 
2000 美元的增长 
第4 章  对象和图形
最初设计中的下一步需要绘制对应于本金初始值的柱形。很容易看到这个柱形的左下
角应该在哪里。0.0 美元的值垂直位置在像素230 处，标签的中心距离左边缘20 像素。再
加上20 个像素就是标签的右边缘。因此，第0 个柱形的左下角应该在位置（40，230）。 
现在我们只需要弄清楚柱形的对角（右上角）应该在哪里，就可以绘制一个合适的矩
形。在垂直方向上，柱形的高度由本金的值确定。在绘制刻度时，我们决定100 像素等于
5000 美元。这意味着我们有100 / 5000 = 0.02 像素对应1 美元。这告诉我们，例如，2000
美元的本金应该产生高度2000(.02)= 40 像素的柱形。一般来说，右上角的y 位置将由230 − 
(principal)(0.02)给出。（记住，230 是0 点，y 坐标向上增加。） 
柱形应该有多宽？该窗口宽320 像素，但40 个像素被左边的标签占据。这让我们有280
像素画11 个柱形：280÷11 = 25.4545。我们给每个柱形25 像素，这会在右边留出一点边距。
因此，我们的第一个柱形的右边缘将在位置40 + 25 = 65 像素处。 
我们现在可以将绘制第一个柱形的细节填充到算法中：
从(40, 230) 至 (65, 230 - principal * 0.02)绘制一个矩形 
此时，我们已经做出了完成这个问题需要的所有主要决定和计算，剩下的就是将这些
细节渗透到算法的其余部分。图4.8 展示了带有我们选择的一些尺寸的窗口一般布局。 
图4.8 图像元素在终值柱形图中的位置 
让我们弄清楚每个柱形的左下角在哪里。我们选择的柱形宽度是25，因此每一个连续
年份的柱形将从上一年右边25 像素开始。我们可以使用变量year 代表年份数，计算左下角
的x 坐标为(year)(25) + 40。（+ 40 为标签留下左边缘的空间。）当然，这个点的y 坐标仍然
是230（图的底部）。 
要找到柱形的右上角，我们将左下角的x 值加上25（柱形的宽度）。右上角的y 值通过
（更新的）本金值来确定，像我们确定第一个柱形一样。下面是细化的算法：
对于year 从1 增长10: 
计算principal = principal * (1 + apr) 
计算xll = 25 * year + 40 
计算height = principal * 0.02 
从(xll, 230) 至 (xll+25, 230 - height)绘制一个矩形 
变量xll 表示x 左下角（x lower-left）：柱形左下角的x 值。 
4.5  绘制终值 
综上所述，得到详细的算法如下：
从用户处获取principal 和apr 
创建一个320x240 的GraphWin，标题为”Investment Growth Chart” 
在(20, 230)绘制标签" 0.0K" 
在(20, 180)绘制标签" 2.5K" 
在(20, 130)绘制标签" 5.0K" 
在(20, 80)绘制标签" 7.5K" 
在(20, 30)绘制标签"10.0K" 
从(40, 230) 至 (65, 230 - principal * 0.02)绘制一个矩形 
对于year 从1 增长10: 
    计算principal = principal * (1 + apr) 
    计算xll = 25 * year + 40 
    计算height = principal * 0.02 
    从(xll, 230) 至 (xll+25, 230 - height)绘制一个矩形 
等待用户按下回车键。 
哇！工作量不小，但我们终于准备好将这个算法翻译成实际的Python 代码了。利用
graphics 库中的对象可以直接进行翻译。下面是程序： 
第4 章  对象和图形
如果仔细研究这个程序，就会看到，我添加了一些功能，让它更漂亮一些。所有图形
对象都支持更改颜色的方法。我将窗口的背景颜色设为白色：
我也改变了bar 对象的颜色。下面一行要求bar 将内部填充为绿色（因为它是钱，你
你还可以用setOutline 方法更改形状轮廓的颜色。在这种情况下，我选择让轮廓保持默
认的黑色，这样柱形能彼此分离。为了增强这种效果，以下代码让轮廓更宽（2 像素，而不
你可能还注意到在绘制标签时，对符号的节约使用。由于我们不更改标签，因此不必将它
们赋给变量。我们可以创建一个Text 对象，告诉它绘制自己，然后就完了。下面是一个例子： 
最后，请仔细看看循环中year 变量的使用： 
表达式range(1,11)产生1～10 的整数序列。循环索引变量year 在循环的连续迭代中遍
历该序列。因此，第一次迭代时year 是1，然后是2，然后是3，依此类推，最多到10。year
的值然后用于计算每个柱形左下角的合适位置：
我希望你开始掌握图形编程的窍门。这有点困难，但很容易上瘾。
4.6  选择坐标 
在设计终值图形程序的工作中，大部分的工作是确定控件放在屏幕上的精确坐标。大
多数图形编程问题需要某种“坐标变换”，将来自真实世界问题的值变成窗口坐标，映射到
计算机屏幕上。在我们的示例中，问题域要求x 值表示年份（0～10），y 值和表示货币金额
（0～10000 美元）。我们不得不将这些值转换，展现在320 像素×240 像素的窗口中。通过
一两个例子来看看这种转换如何发生，这很好，但它使得编程变得冗长乏味。
坐标变换是计算机图形学中一个完整的、深入研究过的组成部分。不需要太多的数学
知识就能看到，转换过程总是遵循相同的一般模式。任何遵循模式的事情都可以自动完成。
为了节省在坐标系之间来回显式转换的麻烦，graphics 库提供了一种简单的机制，替你完成。
创建GraphWin 时，可以用setCoords 方法为窗口指定坐标系。该方法需要分别指定左下角
和右上角的坐标的四个参数。然后可以用此坐标系将图形对象放在窗口中。
4.6  选择坐标 
举一个简单的例子，假设我们只是希望将窗口分成九个相等的正方形，像井字游戏那
样。用默认的200 像素×200 像素窗口也没有太多的麻烦，但需要一点算术。如果我们先在
两个维度上将窗口的坐标改为从0 到3，问题就简单了： 
这种方法的另一个好处在于，可以通过简单地改变创建窗口时使用的尺寸来改变窗口
的大小（例如win = GraphWin("Tic-Tac-Toe", 300, 300)）。因为该窗口使用相同的坐标（由于
setCoords），所以对象将适当地缩放到新的窗口大小。使用“原始的”窗口坐标，则需要改
变这些线的定义。
我们可以用这个想法来简化图形终值程序。基本上，我们希望图形窗口在x 维度上从0～
10（代表年），在y 维度上从0～10000（代表美元）。我们可以创建一个这样的窗口： 
然后为任何年份和本金的值创建一个柱形就简单了。每个柱形开始于给定年份，基线
为0，并且增长到下一年，高度等于本金。 
这个方案有一个小问题。你能发现我忘了什么吗？十一个柱形将填充整个窗口，我们
没有在边缘留下任何空间给标签或边距。这很容易修正，只要稍微扩展窗口的坐标。由于
柱形从0 开始，我们可以定位左侧的标签为−1。我们可以让坐标稍微超出图形所需的坐标，
从而在图形周围添加一些空白。通过一个小实验，这个窗口定义如下：
下面再次列出程序，它使用了替代坐标系：
第4 章  对象和图形
请注意，它如何消除了繁琐的坐标计算。此版本也让更改GraphWin 的大小变得容易。
将窗口大小更改为640 像素×480 像素会生成更大但正确绘制的柱形图。在原来的程序中，
必须重新进行所有计算以适应较大窗口中的新缩放因子。
显然，程序的第二个版本更容易开发和理解。进行图形编程时，应考虑选择一个坐标
系，这将使你的任务尽可能简单。
4.7  交互式图形 
图形界面可用于输入和输出。在GUI 环境中，用户通常通过点击按钮，从菜单中选择
菜单项，并在屏幕文本框中键入信息来与应用交互。这些应用程序使用一种称为“事件驱
动”编程的技术。基本上，程序在屏幕上绘制一组界面元素（通常称为“控件”），然后等
如果用户移动鼠标、单击按钮或在键盘上键入一个键，就会生成一个“事件”。基本上，
事件是一个对象，封装了刚刚发生的事情的数据。然后事件对象被发送到程序的适当部分，
进行处理。例如，点击按钮可能产生“按钮事件”。该事件将被传递到按钮处理代码，然后
这段代码将执行按钮对应的适当动作。
事件驱动编程对于新程序员可能有点棘手，因为在任意给定时刻很难弄清楚“谁负责”。
graphics 模块隐藏了底层事件处理机制，并提供了一些在GraphWin 中获取用户输入的简单
4.7  交互式图形 
4.7.1  获取鼠标点击 
我们可以通过GraphWin 类的getMouse 方法从用户获取图形信息。如果在GraphWin 上
调用getMouse，程序将暂停，并等待用户在图形窗口中某处单击鼠标。用户单击的位置作
为一个Point 返回给程序。下面是一段代码，报告十次连续鼠标点击的坐标： 
getMouse()返回的值是一个现成的Point。我们可以像使用任何其他Point 一样使用它，
使用getX 和getY 等取值方法，或draw 和move 等其他方法。 
下面是一个交互式程序的例子，允许用户通过点击图形窗口中的三个点来绘制一个三
角形。该示例完全是图形化的，使用Text 对象作为提示。不需要与Python 文本窗口进行交
互。如果你在Microsoft Windows 环境中编程，可以使用.pyw 扩展名命名此程序。然后在程
序运行时，甚至不会显示Python 的shell 窗口。 
点击三个点绘制三角形展示了graphics 模块的一些新功能。但是，没有三角形类，只有
一个一般类Polygon 可以用于任意封闭的多边形。Polygon 的构造函数接受任意数量的点，
第4 章  对象和图形
用线段按给定顺序连接点，并将最后一个点连接回第一个点，从而创建多边形。三角形就
是有三条边的多边形。一旦我们有了三个Point（p1，p2 和p3），就可以立即创建三角形： 
你还应该学习如何使用Text 对象来提供提示。在接近程序开始处创建并绘制了单个Text
要更改提示，我们不需要创建一个新的Text 对象，可以只改变显示的文本。这在接近
程序结束处用setText 方法实现： 
可以看到，GraphWin 的getMouse 方法提供了一种在面向图形的程序中与用户交互的简
4.7.2  处理文本输入 
在三角形示例中，所有输入都通过鼠标点击提供。通常我们将允许用户通过键盘与图
形窗口进行交互。GraphWin 对象提供了一个getKey()方法，其工作方式非常类似于getMouse
方法。这是一个简单的点击程序的扩展，允许用户在每个鼠标点击后键入一个按键，在窗
请注意循环体中发生了什么。首先，它等待鼠标单击，并将生成的点保存为变量p。然
后程序等待用户在键盘上键入一个键。 被按下的键作为字符串返回，并保存为变量key。
例如，如果用户按下键盘上的g，那么key 将是字符串“g”。点和字符串然后用于创建文本
对象（称为标签），被绘制到窗口中。
你应该尝试这个程序，感受getKey 方法的作用。特别是，查看键入一些比较奇怪的键
（如<Shift>、<Ctrl>或光标移动键）时返回的字符串。 
虽然getKey 方法肯定有用，但它并不是从用户获取任意字符串（例如数字或名称）的非常
实用的方法。幸运的是，图形库提供了一个Entry 对象，允许用户实际输入到GraphWin 中。 
Entry 对象在屏幕上绘制一个可以包含文本的框。它就像Text 对象一样理解setText 和
getText 方法，区别在于用户可以编辑Entry 的内容。下面是来自第2 章的温度转换程序的一
个版本，带有图形用户界面：
4.7  交互式图形 
运行时，会生成一个窗口，其中包含用于输入摄氏温度的输入框和用于执行转换的“按
钮”。按钮只是为了显示。程序实际上只是暂停，等待在窗口中的任何位置点击鼠标。图4.9
展示了程序启动时窗口的样子。
最初，输入框设置为包含值0.0。用户可以删除此值并键入另一个温度。程序暂停，直
到用户单击鼠标。注意，用户点击的点甚至没有保存，getMouse 方法仅用于暂停程序，直
到用户有机会在输入框中输入值。
然后程序用3 个步骤处理输入。首先，输入框中的文本被转换为数字（通过float）。然
后将此数字转换为华氏度。最后，结果数字显示在输出文本区域中。虽然fahrenheit 是一个
float 值，但setText 方法会自动将其转换为字符串，以便在输出文本框中显示。 
图4.10 展示了用户键入输入并点击鼠标后窗口的样子。请注意，转换后的温度显示在
输出区域，按钮上的标签已变更为“Quit”，表示再次单击将退出程序。使用graphics 库中
的一些选项，改变各种控件的颜色、大小和线宽，可以让这个示例变得更漂亮。该程序的
代码有意采用简洁的方式，只展示GUI 设计的基本要素。 
第4 章  对象和图形
     图4.9 图形温度转换器的初始屏幕
图4.10 用户输入后的图形温度转换器 
虽然基本工具getMouse、getKey 和Entry 没有提供一个完整的GUI 环境，但我们将在
后面的章节看到，这些简单的机制是如何支持令人惊讶的丰富交互的。
4.8  graphics 模块参考 
本章中的示例涉及了graphics 模块中的大多数元素。本节提供了graphics 中的对象和功
能的完整参考。由模块提供的对象和函数集有时称为“应用编程接口”或“API”。有经验
的程序员研究API 以了解新库。你也应该读一遍本小节，看看graphics 库提供了什么。 
以后，当你编写自己的图形程序时，可能会经常参考这个部分。
学习API 的最大障碍之一，就是熟悉所使用的各种数据类型。在阅读参考文档时，应
仔细注意各种方法的参数类型和返回值。例如，创建一个圆时，需要提供的第一个参数必
须是一个Point 对象（作为圆心），第二个参数必须是一个数字（半径）。使用不正确的类型
有时会立即得到错误消息，但另外一些时候，问题可能到后来才会突然出现，比如绘制对
象的时候。每个方法描述末尾的示例结合了Python 字面量，来说明参数的适当数据类型。 
4.8.1  GraphWin 对象 
GraphWin 对象表示屏幕上可绘制图形图像的窗口。程序可以定义任意数量的
GraphWins。GraphWin 包含以下方法。 
GraphWin(title, width, height) 构造一个新的图形窗口，用于在屏幕上绘图。参数是可选
的，默认标题为“Graphics Window”，默认大小为200 像素×200 像素。 
示例：win = GraphWin("Investment Growth", 640, 480) 
plot(x, y, color) 在窗口中(x, y)处绘制像素。颜色是可选的，黑色是默认值。 
示例：win.plot(35, 128, "blue") 
plotPixel(x, y, color) 在“原始”位置（x, y）处绘制像素，忽略setCoords 设置的任何坐
示例：win.plotPixel(35, 128, "blue") 
4.8  graphics 模块参考 
setBackground(color)将窗口背景设置为给定的颜色。默认背景颜色取决于系统。有关指
定颜色的信息，请参见第4.8.5 节。 
示例：win.setBackground("white") 
close() 关闭屏幕窗口。 
示例：win.close() 
getMouse() 暂停等待用户在窗口中单击鼠标，并用Point 对象返回鼠标单击的位置。 
示例：clickPoint = win.getMouse() 
checkMouse()与getMouse()类似，但不会暂停等待用户单击。返回鼠标点击的最后一个
点，如果自上次调用checkMouse 或getMouse 后未点击窗口，则返回None
①。这对于控制动
画循环特别有用（参见第8 章）。 
示例：clickPoint = win.checkMouse() 
注意：clickPoint 可能为None。 
getKey() 暂停等待用户在键盘上键入一个键，并返回一个表示被按下键的字符串。 
示例：keyString = win.getKey() 
checkKey()与getKey()类似，但不会暂停等待用户按下一个键。返回被按下的最后一个
键，如果从上一次调用checkKey 或getKey 后没有按下任何键，则返回""。这对于控制简单
的动画循环特别有用（参见第8 章）。 
示例：keyString = win.checkKey() 
注意：keyString 可能是空字符串""。 
setCoords(xll, yll, xur, yur)设置窗口的坐标系。左下角是（xll, yll），右上角是（xur, yur）。
当前绘制的对象被重绘，而后续的绘制将相对于新的坐标系统（除plotPixel 以外）。 
示例：win.setCoords(0，0，200，100) 
4.8.2  图形对象 
该模块提供了类Point、Line、Circle、Oval、Rectangle、Polygon 和Text 的可绘制对象。
最初创建的所有对象都有未填充的黑色轮廓。所有图形对象都支持以下通用的方法集。
setFill(color)将对象的内部设置为给定的颜色。 
示例：someObject.setFill("red") 
setOutline(color) 将对象的轮廓设置为给定的颜色。 
示例：someObject.setOutline("yellow") 
setWidth(pixels) 将对象的轮廓宽度设置为所需的像素数。（不适用于Point。） 
示例：someObject.setWidth(3) 
draw(aGraphWin) 将对象绘制到给定的GraphWin 中并返回绘制对象。 
示例：someObject.draw(someGraphWin) 
undraw() 从图形窗口中擦除对象。如果对象当前未绘制，则不采取任何操作。 
示例：someObject.undraw() 
move(dx,dy) 在x 方向上移动对象dx 单位，在y 方向上移动dy 单位。如果对象当前已
①None 是一个特殊的Python 对象，常用于表示一个变量没有值。我们在第6 章中讨论None。 
第4 章  对象和图形
绘制，则将图像调整到新位置。
示例：someObject.move(10，15.5) 
clone() 返回对象的副本。克隆始终以未绘制状态创建。除此之外，它们与被克隆的对
示例：objectCopy = someObject.clone() 
Point 方法 
Point(x,y) 构造具有给定坐标的点。 
示例：aPoint = Point(3.5, 8) 
getX() 返回点的x 坐标。 
示例：xValue = aPoint.getX() 
getY() 返回点的y 坐标。 
示例：yValue = aPoint.getY() 
Line(point1, point2) 构造从point1 到point2 的线段。 
示例：aLine = Line(Point(1,3), Point(7,4)) 
setArrow(endString) 设置线段的箭头状态。箭头可以在第一端点、最后端点或两个端点
上绘制。endString 的可能值为"first"、"last"、"both"和"none"。默认设置为"none"。 
示例：aLine.setArrow("both") 
getCenter() 返回线段中点的克隆。 
示例：midPoint = aLine.getCenter() 
getP1()、getP2() 返回线段的对应端点的克隆。 
示例：startPoint = aLine.getP1() 
Circle 方法 
Circle(centerPoint, radius)构造具有给定圆心和半径的圆。 
示例：a Circle = Circle(Point(3,4), 10.5) 
getCenter() 返回圆心的克隆。 
示例：centerPoint = aCircle.getCenter() 
getRadius() 返回圆的半径。 
示例：radius = aCircle.getRadius() 
getP1()，getP2()返回圆的边界框的对应角落的克隆。它们是围绕圆的正方形的对角点。 
示例：cornerPoint = aCircle.getP1() 
Rectangle 方法 
Rectangle(point1, point2) 构造一个对角点在point1 和point2 的矩形。 
示例：aRectangle = Rectangle(Point(1,3), Point(4,7)) 
getCenter() 返回矩形中心点的克隆。 
4.8  graphics 模块参考 
示例：centerPoint = aRectangle.getCenter() 
getP1()、getP2() 返回用于构造矩形的对应点的克隆。 
示例：cornerPoint = aRectangle.getP1() 
Oval(point1, point2) 在由point1 和point2 确定的边界框中构造一个椭圆。 
示例：anOval = Oval(Point(1,2), Point(3,4)) 
getCenter() 返回椭圆形中心点的克隆。 
示例：centerPoint = anOval.getCenter() 
getP1()、getP2() 返回用于构造椭圆的对应点的克隆。 
示例：cornerPoint = anOval.getP1() 
Polygon 方法 
Polygon(point1, point2, point3, ...) 构造一个以给定点为顶点的多边形。也接受单个参数，
示例：aPolygon = Polygon(Point(1,2), Point(3,4), Point(5,6)) 
示例：aPolygon = Polygon([Point(1,2), Point(3,4), Point(5,6)]) 
getPoints() 返回一个列表，包含用于构造多边形的点的克隆。 
示例：pointList = aPolygon.getPoints() 
Text(anchorPoint, textString) 构造一个文本对象，显示以anchorPoint 为中心的文本字符
串。文本水平显示。
示例：message = Text(Point(3,4), "Hello!") 
setText(string) 将对象的文本设置为字符串。 
示例：message.setText("Goodbye!") 
getText() 返回当前字符串。 
示例：msgString = message.getText() 
getAnchor() 返回锚点的克隆。 
示例：centerPoint = message.getAnchor() 
setFace(family) 将字体更改为给定的系列。可能的值是"helvetica"、"courier"、"times 
roman"和"arial"。 
示例：message.setFace("arial") 
setSize(point) 将字体大小更改为给定的点大小。从5 点到36 点是合法的。 
示例：message.setSize(18) 
setStyle(style) 将字体更改为给定的样式。可能的值有"normal"、"bold"、"italic"和"bold 
italic"。 
示例：message.setStyle("bold") 
setTextColor(color) 将文本的颜色设置为彩色。注意：setFill 有同样的效果。 
第4 章  对象和图形
示例：message.setTextColor("pink") 
4.8.3  Entry 对象 
Entry 类型的对象显示为一个文本输入框，可由程序的用户编辑。Entry 对象支持通用
的图形方法move()、draw(graphwin)、undraw()、setFill(color)和clone()。Entry 特有的方法
Entry(centerPoint, width) 构造具有给定中心点和宽度的Entry。宽度用可显示的文本字
示例：inputBox = Entry(Point(3,4), 5) 
getAnchor() 返回输入框居中点的克隆。 
示例：centerPoint = inputBox.getAnchor() 
getText() 返回当前在输入框中的文本字符串。 
示例：inputStr = inputBox.getText() 
setText(string) 将输入框中的文本设置为给定字符串。 
示例：inputBox.setText("32.0") 
setFace(family) 将字体更改为给定的系列。可能的值是"helvetica"、"courier"、"times 
roman"和"arial"。 
示例：inputBox.setFace("courier") 
setSize(point) 将字体大小更改为给定的点大小。从5 点到36 点是合法的。 
示例：inputBox.setSize(12) 
setStyle(style) 将字体更改为给定的样式。可能的值有"normal"、"bold"、"italic"和"bold 
italic"。 
示例：inputBox.setStyle("italic") 
setTextColor(color) 设置文本的颜色。 
示例：inputBox.setTextColor("green") 
4.8.4  显示图像 
graphics 模块还提供了在GraphWin 中显示和操作图像的最小支持。大多数平台至少支
持PPM 和GIF 图像。显示是使用Image 对象完成的。图像支持通用方法move(dx,dy)、
draw(graphwin)、undraw()和clone()。Image 特有的方法如下。 
Image(anchorPoint, filename) 利用给定文件的内容构造图像，以给定锚点为中心。也可
以使用width 和height 参数而不是filename 来调用。在这种情况下，将创建给定宽度和高度
（以像素为单位）的空白（透明）图像。
示例：flowerImage = Image(Point(100,100), "flower.gif") 
示例：blankImage = Image(320, 240) 
getAnchor() 返回图像居中点的克隆。 
示例：centerPoint = flowerImage.getAnchor() 
getWidth() 返回图像的宽度。 
4.8  graphics 模块参考 
示例：widthInPixels = flowerImage.getWidth() 
getHeight() 返回图像的高度。 
示例：heightInPixels = flowerImage.getHeight() 
getPixel(x, y) 返回位置（x，y）处的像素的RGB 值的列表[红，绿，蓝]。每个值都是0～
255 范围内的数字，表示相应RGB 颜色的强度。这些数字可以用color_rgb 函数转换为颜色
字符串（参见下一节）。注意，像素位置是相对于图像本身的，而不是绘制图像的窗口。图
像的左上角始终是像素（0,0）。 
示例：red，green，blue = flowerImage.getPixel(32,18) 
setPixel(x, y, color) 将位置（x,y）处的像素设置为给定颜色。 
注意：这是一个缓慢的操作。
示例：flowerImage.setPixel(32, 18, "blue") 
save(filename) 将图像保存为文件。所得文件的类型（如GIF 或PPM）由文件名的扩展
示例：flowerImage.save("mypic.ppm") 
4.8.5  生成颜色 
颜色由字符串表示。最常见的颜色，如"red"、"purple"、"green"、"cyan"等，应该直接
可用。许多颜色具有各种色调，例如"red1"、"red2"、"red3"、"red4"，这是越来越暗的红色。
关于完整列表，可在网络上查找X11 颜色名称。 
grahpics 模块还提供了一个函数，以数字方式混合你自己的颜色。函数color_rgb(red, 
green, blue)将返回一个表示颜色的字符串，该颜色是指定的红色、绿色和蓝色的强度的混合。
它们应该是在0～255 范围内的int。因此，color_rgb(255, 0, 0)是亮红色，而color_rgb(130, 0, 
130)是中等品红色。
示例：aCircle.setFill(color rgb(130, 0, 130))
4.8.6  控制显示更新（高级）
通常，每当任何图形对象的可见状态以某种方式改变时，GraphWin 的可视显示就会更
新。然而，在某些情况下，例如在一些交互式shell 中使用graphics 库时，可能需要强制窗
口更新以便看到改变。update()函数用于执行此操作。 
update() 导致所有挂起的图形操作得到执行，并显示结果。 
出于效率的原因，有时期望关闭每当一个对象改变时窗口所进行的自动更新。例
如，在动画中，你可能需要在显示动画的下一“帧”之前更改多个对象的外观。GraphWin
构造函数包括了一个名为autoflush 的特殊额外参数，用于控制这种自动更新。默认情
况下，创建窗口时，自动更新将打开。要关闭它，autoflush 参数应该设置为False，像
现在对win 中对象的更改只会在图形系统有一些空闲时间或者通过调用update()强制更
第4 章  对象和图形
update()方法还接受一个可选参数，指定可以进行更新的最大速率（每秒）。这对于以独
立于硬件的方式控制动画的速度是有用的。例如，将命令update(30)放置在循环的底部，确
保循环将每秒“回转”最多30 次。update 命令将每次插入一个适当的暂停，以保持相对恒
定的速率。当然，只在循环本身的执行少于1/30 秒时，速率调节才起作用。 
示例：1000 帧，每秒30 帧 
本章介绍了计算机图形学和基于对象的编程。下面是一些重要概念的摘要。
对象是结合了数据和操作的计算实体。对象知道一些信息，可以执行一些操作。
对象的数据存储在实例变量中，其操作称为方法。
每个对象都是某个类的实例。类确定对象将具有什么方法。通过调用构造函数方
对象的属性通过点符号访问。通常，通过调用对象的方法来执行对象的计算。取
值方法返回有关对象的实例变量的信息。设置方法更改实例变量的值。
  本书提供的graphics 模块提供了许多对图形编程有用的类。GraphWin 表示用于显
示图形的屏幕上的窗口的对象。Point、Line、Circle、Rectangle、Oval、Polygon
和Text等各种图形对象可以在GraphWin中绘制。用户可以通过单击鼠标或在Entry
框中输入，与GraphWin 进行交互。 
  图形编程中的一个重要考虑是选择适当的坐标系。graphics 库提供了自动化某些坐
  两个变量引用同一对象的情况称为别名。别名有时会导致意外的结果。在图形库
中使用克隆方法有助于防止这些情况出现。
4.10  练习 
1．利用graphics.py 可以在Python 的shell 窗口中绘制图形。 
2．传统上，图形窗口的左上角坐标为（0,0）。 
4.10  练习 
3．图形屏幕上的单个点称为像素。 
4．创建类的新实例的函数称为取值方法。 
5．实例变量用于在对象内存储数据。 
6．语句myShape.move(10,20)将myShape 移动到点（10,20）。 
7．如果两个变量引用同一个对象，就产生了别名。 
8．提供copy 方法是用于生成图形对象的副本。 
9．图形窗口的标题总是“Graphics Window”。 
10．graphics 库中，用于获取鼠标点击的方法是readMouse。 
1．返回对象的实例变量的值的方法称为
2．改变对象状态的方法称为
图形类最适合绘制一个正方形。
a．Square  
b．Polygon 
d．Rectangle 
命令会将win 的坐标设置变为左下角是（0,0），右上角是（10,10）。 
a．win.setCoords(Point(0,0), Point(10,10))
b．win.setCoords((0,0), (10,10))
c．win.setCoords(0, 0, 10, 10)
d．win.setCoords(Point(10,10), Point(0,0))
将创建从（2,3）到（4,5）的线段。 
a．Line(2, 3, 4, 5)
b．Line((2,3), (4,5))
c．Line(2, 4, 3, 5)
d．Line(Point(2,3), Point(4,5))
可以将图形对象shape 绘制到图形窗口win 中。 
a．win.draw(shape) 
b．win.show(shape)
c．shape.draw()
d．shape.draw(win)
计算点p1 和p2 之间的水平距离。 
a．abs(p1-p2)
b．p2.getX() - p1.getX()
c．abs(p1.getY() - p2.getY())
d．abs(p1.getX() - p2.getX())
可以用来在图形窗口中获取文本输入。
d．Keyboard 
9．围绕视觉元素和用户动作组织的用户界面被称为
b．application  
c．windower  
10．color_rgb(0,255,255)是
第4 章  对象和图形
1．选择一个有趣的现实世界对象的例子，通过列出它的数据（属性，它“知道什么”）
及方法（行为，它可以“做什么”），将它描述为一个编程对象。
2．用你自己的话描述graphics 模块的下列操作产生的每个对象，尽可能精确。务必描
述各种对象的大小、位置和外观等。如果需要，可以画草图。
a．Point(130,130)
b．c = Circle(Point(30,40),25)
c．r = Rectangle(Point(20,20), Point(40,40))
d．l = Line(Point(100,100), Point(100,200))
e．Oval(Point(50,50), Point(60,100))
f．shape = Polygon(Point(5,5), Point(10,10), Point(5,10), Point(10,5))
g．t = Text(Point(100,100), "Hello World!")
3．描述以下交互式图形程序运行时会发生什么： 
1．修改上一个讨论问题的程序，做到： 
a．使它绘制正方形而不是圆。 
4.10  练习 
b．每次连续点击在屏幕上绘制一个额外的方块（而不是移动已有的方块）。 
c．循环之后在窗口上打印消息“Click again to quit”，等待最后一次点击，然后关闭窗口。 
2．箭靶的中心圆为黄色，围绕着红色、蓝色、黑色和白色的同心环。每个环具有相同
的宽度，与黄色圆的半径相同。编写一个绘制这种箭靶的程序。（提示：稍后绘制的对象将
出现在先前绘制的对象的上面。）
3．编写一个绘制某种面孔的程序。 
4．编写一个用圣诞树和雪人绘制冬季场景的程序。 
5．编写一个程序，在屏幕上绘制5 个骰子，是一把顺子（1,2,3,4,5 或2,3,4,5,6）。 
6．修改图形终值程序，让输入（本金和APR）也用Entry 对象以图形方式完成。 
编写一个计算圆与水平线的交点的程序，并以文本和图形方式显示信息。
输入：圆的半径和线的y 截距。 
输出：在坐标为从（−10，−10）到（10,10）的窗口中，以(0, 0)为中心,以给定半径绘制
用给定的y 轴截取一根水平线穿过窗口。 
以红色绘制两个交点。
打印出交叉点的x 值。 
该程序允许用户绘制线段，然后显示关于线段的一些图形和文本信息。
输入：两次鼠标点击线段的终点。
输出：以青色绘制线段的中点。
打印线的长度和斜率。
dx = x2 – x1 
dy = y2 – y1 
此程序显示有关用户绘制的矩形的信息。
输入：两次鼠标点击作为矩形的对角。
输出：绘制矩形。
打印矩形的周长和面积。
公式：面积=（长度）（宽度） 
周长= 2（长度+宽度） 
10．三角形信息。 
与上一个问题相同，但三角形的顶点有三次点击。
公式：关于周长，可参阅线段问题中的长度。
第4 章  对象和图形
，其中a、b、c 是边长，
11．五次点击的房子。 
编写一个程序，允许用户通过五次鼠标点击，绘制一个简单的房子。前两次点击是房
子的矩形框架的对角。第三次点击指出矩形门的顶部边缘的中心。门的宽度应为房屋框架
宽度的1/5。门的边框应从顶部的转角延伸到框架的底部。第四次点击指出正方形窗口的中
心。窗口的宽度是门的一半。最后一次点击指出屋顶的顶点。屋顶的边缘将从顶点延伸到
房屋框架的顶部边缘的转角。
了解字符串数据类型以及如何在计算机中表示字符串。
熟悉通过内置函数和字符串方法对字符串执行的各种操作。
  理解序列和索引的基本概念，因为它们适用于Python 的字符串和列表。 
能够用字符串格式化来产生有吸引力的、富含信息的程序输出。
  了解在Python 中读取和写入文本文件的基本文件处理概念和技术。 
了解加密的基本概念。
理解和编写处理文本信息的程序。
5.1  字符串数据类型 
到目前为止，我们一直在讨论用于操作数字和图形的程序。但你知道，计算机对于存
储和操作文本信息也很重要。事实上，个人计算机最常见的用途之一就是文字处理。本章
关注文本应用程序，介绍一些关于文本如何存储在计算机上的重要思想。你可能不觉得基
于文字的应用程序令人兴奋，但你很快会看到，这里提到的基本思想几乎应用于所有计算
领域，也支撑着万维网。
文本在程序中由字符串数据类型表示。你可以将字符串视为一个字符序列。在第2 章
中你已了解到，通过用引号将一些字符括起来形成字符串字面量。Python 还允许字符串由
单引号（撇号）分隔。它们没有区别，但用时一定要配对。字符串也可以保存在变量中，
像其他数据一样。下面有一些例子，说明了两种形式的字符串字面量：
你已经知道如何打印字符串。你也看到了如何从用户获取字符串输入。回想一下，input
函数返回用户键入的任何字符串对象。这意味着如果你希望得到一个字符串，可以使用其
“原始”（未转换）形式的输入。下面的简单交互说明了这一点：
第5 章  序列：字符串、列表和文件
请注意，我们如何用变量来保存用户名称，然后用该变量将名称打印出来。
到目前为止，我们已经看到了如何获取字符串作为输入，将它们分配给变量，以及如
何将它们打印出来。这足以写一个鹦鹉学舌式的程序，但不能做任何严肃的基于文本的计
算。因此，我们需要一些字符串操作。本节的其余部分将带你了解更重要的Python 字符串
操作。在下一节中，我们会在一些示例程序中，将这些想法付诸实践。
我们可以用字符串做怎样的事？对于初学者，要记住一个字符串是什么：一个字符序
列。我们可能希望做的一件事是访问组成字符串的单个字符。在Python 中，这可以通过“索
引”操作来完成。我们可以认为字符串中的位置被编号，从左边开始为0。图5.1 用字符串
"Hello Bob"加以说明。索引在字符串表达式中用于访问字符串中的特定字符位置。索引的一
般形式是<string> [<expr>]。表达式的值确定从字符串中选择哪个字符。 
图5.1 字符串"Hello Bob"的索引 
以下是一些交互式的索引示例：
请注意，在n 个字符的字符串中，最后一个字符位于位置n−1，因为索引从0 开始。现
在也许应该提醒你，字符串对象与实际打印输出之间的差异。在上面的交互中，Python shell
通过将字符串的值放在单引号中来显示值，这是Python 的沟通方式，告诉我们正在看一个
字符串对象。实际打印字符串时，Python 不会在字符序列周围添加任何引号。我们只是得
到包含在字符串中的文本。
顺便说一下，Python 还允许使用负索引，从字符串的右端索引。 
这对于获取字符串的最后一个字符特别有用。
索引返回包含较大字符串中单个字符的字符串。也可以从字符串中访问连续的字符序
列或“子字符串”。在Python 中，这是通过一个名为“切片”的操作来实现的。你可以把切
片想象成在字符串中索引一系列位置的方法。切片的形式是<string> [<start>：<end>]。start
和end 都应该是int 值表达式。切片产生从start 直到（但不包括）end 位置给出的子串。 
5.1  字符串数据类型 
继续我们的交互示例，下面是一些切片：
最后三个示例表明，如果任何一个表达式缺失，字符串的开始和结束都是假定的默认
值。最后的表达式实际上给出整个字符串。
索引和切片是将字符串切成更小片段的有用操作。字符串数据类型还支持将字符串放
在一起的操作。连接（+）和重复（*）是两个方便的运算符。连接通过将两个字符串“粘
合”在一起来构建字符串；重复通过字符串与多个自身连接，来构建字符串。另一个有用
的函数是len，它告诉你字符串中有多少个字符。最后，由于字符串是字符序列，因此可以
使用Python 的for 循环遍历这些字符。 
以下是各种字符串操作的一些示例：
基本的字符串操作总结在表5.1 中。 
Python 字符串操作 
第5 章  序列：字符串、列表和文件
5.2  简单字符串处理 
既然明白了各种字符串操作可以做什么，那我们就准备好编写一些程序了。我们的第
一个例子是计算一个计算机系统的用户名的程序。
许多计算机系统使用用户名和密码组合来认证系统用户。系统管理员必须为每个用户
分配唯一的用户名。通常，用户名来自用户的实际姓名。一种用于生成用户名的方案是使
用用户的第一个首字母，然后是用户姓氏的最多七个字母。利用这种方法，Zaphod Beeblebrox
的用户名将是“zbeebleb”，而John Smith 就是“jsmith”。 
我们希望编写一个程序，读取一个人的名字并计算相应的用户名。我们的程序将遵循
基本的输入、处理、输出模式。为简洁起见，我将跳过对算法开发的讨论，并跳到代码。
算法的概要作为注释包含在最终程序中。
这个程序首先利用input 从用户获取字符串，然后组合使用索引、切片和连接来生成用
户名。下面是运行示例：
你知道介绍和名字的提示之间的空白行是从哪里来的吗？在第一个print 语句中将换行
符（\n）放在字符串的末尾，这导致输出跳过一个额外的行。这是一个简单的技巧，输出一
些额外的空白，更好看一些。
下面是另一个问题，我们可以用字符串操作解决。假设要打印给定月份数对应的月份
缩写。程序的输入是一个int，代表一个月份（1～12），输出是相应月份的缩写。例如，如
果输入为3，则输出应为Mar，即3 月。 
初看，这个程序似乎超出了你目前的能力。经验丰富的程序员明白，这是一个判断问
题。也就是说，我们必须根据用户给出的数字，决定12 种不同输出中哪一种合适。我们以
后再介绍判断结构。但是，我们可以通过一些巧妙的字符串切片来编写程序。
5.2  简单字符串处理 
基本思想是将所有月份名称存储在一个大字符串中：
我们可以通过切出适当的子字符串来查找特定的月份，诀窍是计算在哪里切片。由于
每个月由三个字母表示，如果知道一个给定的月份在字符串中开始的位置，就可以很容易
这将获得从pos 指示位置开始的长度为3 的子串。 
如何计算这个位置？让我们试试几个例子（如表5.2 所列），看看有什么发现。记住，
字符串索引从0 开始。 
月份缩写字符串中的位置关系 
当然，这些位置都是3 的倍数。为了得到正确的倍数，我们从月数中减去1，然后乘以
3。所以对于1，我们得到（1−1）* 3 = 0 * 3 = 0，对于12，我们有（12−1）* 3 = 11 * 3 = 33。 
现在我们准备好对程序进行编码了。同样，最终结果又短又好。注释记录了我们开发
请注意，该程序的最后一行利用字符串连接，将句点放在月份缩写的末尾。
下面是程序输出的示例：
这个例子使用“字符串作为查找表”方法，它有一个弱点，即仅当子串都有相同的长
度（在本例中，是3）时才有效。假设我们希望编写一个程序，输出给定数字的完整月份名
第5 章  序列：字符串、列表和文件
称，该如何实现呢？
5.3  列表作为序列 
严格地说，表5.1 中的操作实际上并不是字符串操作。它们是应用于序列的操作。正如
你从第2 章的讨论中知道的，Python 列表也是一种序列。这意味着我们也可以索引、切片
和连接列表，如下面的会话所示：
列表的一个好处是它们比字符串更通用。字符串总是字符序列，而列表可以是任意对
象的序列。你可以创建数字列表或字符串列表。事实上，你甚至可以混合它们，创建一个
包含数字和字符串的列表：
在后面的章节中，我们将把所有的东西放到列表中，如点、矩形、骰子、按钮甚至学生！ 
使用字符串列表，我们可以重写上一节中的月份缩写程序，使其更简单：
关于这个程序，应该注意几点。我创建了一个名为months 的字符串列表作为查找表。
创建列表的代码分为两行。通常，Python 语句写在一行上，但在这种情况下Python 知道列
表没有结束，直到遇到结束括号“]”。将这条语句分成两行让代码更可读。 
列表就像字符串一样，从0 开始索引，因此在此列表中，值[0]是字符串“Jan”。一般
来说，第n 个月在位置n−1。因为这个计算很简单，我甚至不打算把它作为一个单独的步骤，
而是在print 语句中直接用表达式months[n−1]。 
这个缩写问题的解决方案不仅更简单，而且更灵活。例如，改变程序以便打印出整个
月份的名称会很容易。我们只需要重新定义查找列表。
5.4  字符串表示和消息编码 
虽然字符串和列表都是序列，但两者之间有一个重要的区别。列表是可变的。这意味
着列表中项的值可以使用赋值语句修改。另一方面，字符串不能在“适当位置”改变。下
面是一个示例交互，说明了区别：
第一行创建了一个包含4 个数字的列表。索引位置2 返回值15（同样，索引从0 开始）。
下一个命令将值0 赋给位置2 中的项目。赋值后，对列表求值显示新值已替换旧值。在字
符串上尝试类似的操作会产生错误。字符串不可变，但列表可以变。
5.4  字符串表示和消息编码 
5.4.1  字符串表示 
希望你已经开始掌握文本（字符串）数据计算的窍门。但是，我们还没有讨论计算机
实际如何操作字符串。在第3 章，你看到数字以二进制符号（0 和1 组成的序列）存储。计
算机CPU 包含用这种表示进行运算的电路。文本信息以完全相同的方式表示。在底层，计
算机操作文本时，与数字运算真的没有什么不同。
要理解这一点，你可以想想消息和密码。请考虑“老年小学困境”。你坐在课堂上，希
望把一张纸条传给房间里的一个朋友。不幸的是，纸条在到达最终目的地之前，必须经过
许多同学的手以及许多好奇的眼睛。而且，当然总有这样的风险，纸条可能落入敌人（老
师）之手。所以你和你的朋友需要设计一个方案来编码消息的内容。
一种方法是简单地将消息转换为数字序列。你可以选择一个数字对应于字母表中的每
个字母，并用数字代替字母。不需要太多想象力，你可能用数字1～26 来表示字母a～z。
“sourpuss”这个词，你会写成“18，14，20，17，15，20，18，18”。对于那些不知道代码
的人，这看起来像一个无意义的数字串。但对于你和你的朋友，它代表一个词。
这就是计算机表示字符串的方式。每个字符都被翻译成一个数字，整个字符串作为（二
进制）数字序列存储在计算机存储器中。只要计算机的编码/解码过程一致，用什么数字表
示任何给定字符并不重要。在计算的早期，不同的设计者和制造商使用不同的编码。你可
第5 章  序列：字符串、列表和文件
以想象，人们在不同系统之间传输数据时，有多头痛。
请考虑一种情况，如果PC 和Macintosh 计算机各自使用自己的编码，会有什么结果。
如果在PC上键入学期论文并将它另存为文本文件，论文中的字符将表示为特定的数字序列。
然后，如果文件被读入你的老师的Macintosh 计算机，数字在屏幕上显示时，与你键入的字
符不同。结果会乱七八糟！
为了避免这种问题，今天的计算机系统使用工业标准编码。一个重要的标准名为ASCII
（美国信息交换标准代码）。ASCII 用数字0～127 来表示通常（美国）计算机键盘上有的字
符以及被称为控制代码的某些特殊值，用于协调信息的发送和接收。例如，大写字母A～Z
由值65～90 表示，小写字母的代码为97～122。 
ASCII 编码的一个问题，顾名思义，就是它是以美国为中心的。它没有许多其他语言需
要的符号。国际标准组织已经开发了扩展ASCII 编码来纠正这种情况。大多数现代系统正
在向Unicode 转移，这是一个更大的标准，旨在包括几乎所有书面语言的字符。Python 字符
串支持Unicode 标准，因此，只要你的操作系统有适当的字体来显示字符，就可以处理来自
任何语言的字符。
Python 提供了几个内置函数，允许我们在字符和字符串中表示它们的数字值之间来回切
换。ord 函数返回单字符串的数字（“ordinal”）编码，而chr 相反。下面是一些交互的例子： 
如果仔细阅读，你可能会注意到这些结果与我上面提到的字符的ASCII 编码一致。按
照设计，Unicode 使用的相应代码与ASCII 最初定义127 个字符的相同。但Unicode 还包括
更多的异国字符。例如，希腊字母pi 是字符960，欧元的符号是字符8364。 
在计算机存储器中如何存储字符的谜题中，还有一个部分。正如你从第3 章了解的，
底层CPU 处理固定大小的内存。最小可寻址段通常为8 位，称为存储器字节。单个字节可
以存储28 = 256 个不同的值。这足以代表每个可能的ASCII 字符（事实上，ASCII 只是一个
7 位的代码）。但是单个字节远远不足以存储所有10 万个可能的Unicode 字符。为了解决这
个问题，Unicode 标准定义了将Unicode 字符打包成字节序列的各种编码方案。最常见的编
码称为UTF-8。UTF-8 是一种可变长度编码方案，用单个字节存储ASCII 子集中的字符，
但可能需要最多四个字节来表示一些更为深奥的字符。这意味着长度为10 个字符的字符串
最终将以10～40 个字节的序列存储在内存中，具体取决于字符串中使用的实际字符。然而，
作为拉丁字母（通常的西方字符）的经验法则，估计字符平均需要大约一个字节的存储是
5.4.2  编写编码器 
让我们回到传纸条的例子。利用Python 的ord 和chr 函数，我们可以编写一些简单的程
序，将消息转换为数字序列的过程自动化，再转换回来。用于编码消息的算法很简单：
5.5  字符串方法 
从用户处获得消息很容易，一个input 就行了。 
实现循环需要更多工作。我们需要针对消息的每个字符做一些事情。回想一下，for 循
环遍历一系列对象。由于字符串是一种序列，我们可以用for 循环遍历消息的所有字符： 
最后，我们需要将每个字符转换为数字。最简单的方法是对消息中的每个字符采用
Unicode 数字（由ord 提供）。 
下面是编码消息的最终程序：
我们可以用程序来编码重要的消息，像这样：
关于这个结果，有一个问题要注意：即使空格字符也有相应的Unicode 编码。它由值32 表示。 
5.5  字符串方法 
5.5.1  编写解码器 
既然我们有了一个程序将消息转换为数字序列，那么如果我们的朋友在另一端有一个
第5 章  序列：字符串、列表和文件
类似的程序，将数字转回为可读的消息，那就好了。让我们来解决这个问题。我们的解码
器程序将提示用户输入一系列Unicode 数字，然后打印出带有相应字符的文本消息。这个程
序给我们带来了几个挑战，我们将一起解决这些问题。
解码器程序的总体轮廓看起来与编码器程序非常类似。一个结构上的变化是解码版本
将在字符串中收集消息的字符，并在程序结束时打印出整条消息。为此，我们需要用一个
累积器变量，即我们在第3 章的阶乘程序中看到的模式。下面是解码算法： 
在循环之前，累加器变量消息被初始化为空字符串，即不包含字符的字符串（""）。每
次通过循环，来自输入的数字被转换为适当的字符，并附加到之前构造的消息末尾。
算法看起来很简单，但即使第一步也向我们提出一个问题：如何得到要解码的数字序
列？我们甚至不知道会有多少数字。为了解决这个问题，我们将依靠更多的字符串操作。
首先，我们利用输入将整个数字序列读入为单个字符串。其次，我们将大字符串拆分为一
系列较小的字符串，每个字符串代表一个数字。最后，我们可以遍历更小的字符串列表，将每
个字符串转换为一个数字，并使用该数字来产生相应的Unicode 字符。下面是完整的算法： 
这看起来很复杂，但Python 提供了一些函数，正是我们需要的。 
你可能已经注意到，我一直在谈论字符串对象。记得在前一章开始，对象有数据和操作（它
们“知道一些事情”并“做一些事情”）。由于是对象，除了我们前面使用的通用序列操作之外，
字符串还有一些内置的方法。我们将使用其中一些能力来解决我们的解码器问题。
对于解码器，我们将使用split 方法。此方法将字符串拆分为子串列表。默认情况下，
它会在遇到空格时拆分字符串。下面是一个例子：
当然，调用split 操作按惯例使用点符号，即调用对象的一个方法。在结果中，你可以
看到split 如何将原始字符串"Hello, string methods!"转换为"Hello,"、"string"和"methods!"三个
顺便说一下，通过提供要拆分的字符作为参数，split 可以在空格之外的其他地方拆分
字符串。例如，如果有一个逗号分隔的数字串，我们可以按逗号拆分：
如果希望不用eval 而从用户获取多个输入，这非常有用。例如，我们可以获取单个输
5.5  字符串方法 
入字符串中的一个点的x 和y 值，使用split 方法将其转换为列表，然后索引得到的列表，
获取单个字符串部分，像下面这样：
当然，我们仍然需要将这些字符串转换为相应的数字。回想一下第3 章，我们可以用
类型转换函数int 和float 将字符串转换为适当的数字类型。在这个例子中，我们使用float
并将这一切合并成两行代码：
回到解码器，我们可以使用类似的技术。由于我们的程序应该接受编码器程序产生的
相同格式，即一系列具有空格的Unicode 数字，所以默认版本的split 工作得很好： 
同样，结果不是数字列表，而是字符串列表。只是碰巧这些字符串只包含数字，“可以”
解释为数字。在这个例子中，这些字符串是int 字面量，因此我们将int 函数应用于每一个
字符串，将其转换为数字。
使用split 和int，我们可以编写解码器程序： 
稍微研究下这个程序，你应该能够了解它是如何完成它的任务的。程序的核心是循环： 
split 方法生成（子）字符串的列表，numStr 接受列表中的每个连续字符串。我将循环变
第5 章  序列：字符串、列表和文件
量称为numStr，强调它的值是一个数字串，表示一些数字。每次通过循环，下一个子字符串
被转换为一个数字。此数字通过chr 转换为相应的Unicode 字符，并附加到累积器message 的
末尾。循环完成时，inString 中的每个数字都得到处理，message 包含了解码的文本。 
下面是该程序执行的示例：
5.5.2  更多字符串方法 
现在我们有两个程序，可以编码和解码消息，即Unicode 值的序列。由于Python 的字
符串数据类型以及内置的序列操作和字符串方法的强大，这些程序变得相当简单。
要编写操作文本数据的程序，Python 是很好的语言。表5.3 列出了一些其他有用的字符
串方法。了解这些操作的好方法是交互地尝试。
只有第一个字符大写的s 的副本 
在给定宽度的字段中居中的s 的副本 
计算s 中sub 的出现次数 
找到sub 出现在s 中的第一个位置 
将列表连接到字符串中，使用s 作为分隔符 
类似center，但s 是左对齐 
所有字符小写的s 的副本 
删除前导空格的副本
使用newsub 替换s 中的所有出现的oldsub 
类似find，但返回最右边的位置 
类似center，但s 是右对齐 
删除尾部空格的s 的副本 
将s 分割成子字符串列表 
s 的每个单词的第一个字符大写的副本 
所有字符都转换为大写的s 的副本 
5.6  列表也有方法 
我应该指出，许多这些方法，如split，可以接受其他一些参数，从而定制它们的操作。
Python 还有一些其他标准库文本处理，这里没有介绍。你可以参考在线文档或Python 参考
文档，了解更多信息。
5.6  列表也有方法 
在上一节中，我们看到了一些操纵字符串对象的方法。像字符串一样，列表也是对象，
并且带有自己的一组“额外”操作。由于本章主要涉及文本处理，因此我们将在后面章节
中详细讨论各种列表方法。但是，我希望在这里介绍一个重要的列表方法，只是为了让你
append 方法可以在列表末尾添加一项。这通常用于每次一项地构建列表。下面是一段
代码，创建了前100 个自然数的平方的列表： 
在这个例子中，我们从空列表（[]）开始，每个从1～100 的数字计算平方并附加到列
表中。循环完成时，squares 将是列表[1,4,9，……，10000]。这实际上就是累积器模式在发
挥作用，这次与我们的累积值是一个列表。
使用append 方法，我们可以回头看看小解码器程序的替代方法。之前的程序使用字
符串变量作为解码输出消息的累积器。语句message = message + chr(codeNum)本质上创
建了到目前为止的完整的message 副本，并在一端再加一个字符。我们建立消息时，不
断重复复制一个越来越长的字符串，只是为了在末尾添加一个新的字符。在旧版本的
Python 中，字符串连接可能是一个缓慢的操作，而程序员经常使用其他技术来累积一个
避免不断重复复制消息的一种方法是使用列表。消息可以作为字符列表来累积，其中
每个新字符附加到已有列表的末尾。记住，列表是可变的，所以在列表的末尾添加将“当
第5 章  序列：字符串、列表和文件
场”改变列表，而不必将已有内容复制到一个新的对象中
①。一旦我们累积了列表中的所有
字符，就可以用join 操作将这些字符一下子连接成一个字符串。 
下面是使用这种方法的解码器：
在这段代码中，我们将字符附加到名为chars 的列表中，从而收集字符。最终消息是通
过用空字符串作为分隔符将这些字符连接在一起获得的。因此，原始字符连接在一起，之
间没有任何额外的空格。
字符串连接和append/join 技术在现代Python 中是相当高效的，它们之间的选择在很大
程度上是一个品味的问题。列表技术更灵活一些，因为如果需要的话，连接方法可以容易
地在连接项之间使用特殊分隔符（如制表符、逗号或空格）来构建字符串。
5.7  从编码到加密 
我们已经了解了计算机如何将字符串表示为一种编码问题。字符串中的每个字符由一
个数字表示，该数字作为二进制表示存储在计算机中。你应该意识到，这个代码根本没有
什么真正的秘密。事实上，我们只是简单地使用字符到数字的行业标准映射。任何有一点
计算机科学知识的人都能轻易破解我们的代码。
为了保密或秘密传输而对信息进行编码的过程称为“加密”。加密方法的研究是一个日
益重要的数学和计算机科学子领域，称为“密码学”。例如，如果你在互联网上购物，重要
的是你的个人信息（如你的姓名和信用卡号码）采用安全的编码来传输，防止网络上潜在
我们的简单编码/解码程序使用非常弱的加密形式，称为“替换密码”。原始消息的每个
字符（称为“明文”）被来自“密码字母表”的相应符号（在我们的例子中是数字）替换。
①实际上，如果Python 没有空间放置新的项，列表确实需要在幕后重新复制，但这是罕见的情况。
5.8  输入/输出作为字符串操作 
生成的代码称为“密文”。
即使我们的密码不是基于著名的Unicode 编码，仍然很容易发现原始消息。由于每个字
母总是由相同的符号编码，因此解码器可以使用关于各种字母频率的统计信息和一些简单
的试错法测试来发现原始消息。这种简单的加密方法可能对小学的纸条传递已足够，但是
显然不能完成在全球网络上确保通信的任务。
加密的现代方法是先将消息转换为数字，就像我们的编码程序，然后采用复杂的数学
算法将这些数字转换为其他数字。通常，变换基本上是将消息与一些特殊值组合，这称为
“密钥”。为了解密消息，接收方需要具有适当的密钥，以便反转编码，恢复原始消息。
加密方法有“私钥”和“公钥”两种风格。在私钥（也称为“共享密钥”）系统中，相
同的密钥用于加密和解密消息。希望通信的各方需要知道密钥，但它必须对外界保密。这
是人们在考虑密码时通常考虑到的系统。
在公钥系统中，存在用于加密和解密的不同但相关的密钥。知道加密密钥不允许你解
密消息或发现解密密钥。在公钥系统中，加密密钥可以公开获得，而解密密钥保持私有。
任何人都可以用公钥安全地发送消息进行加密。只有持有解密密钥的一方才能够解密。例
如，安全网站可以向Web 浏览器发送其公共密钥，浏览器可以用它对信用卡信息进行编码，
再在因特网上发送。然后只有请求信息的公司才能够用正确的私钥来解密和读取它。
5.8  输入/输出作为字符串操作 
有些程序，即使我们认为主要不是进行文本操作，但也经常需要使用字符串操作。
例如，考虑一个进行财务分析的程序。某些信息（如日期）必须以字符串形式输入。在
进行一些数字处理之后，分析的结果通常是一个格式良好的报告，包括用于标记和解释
数字、图表、表格和图形的文本信息。我们需要字符串操作来处理这些基本的输入和输
5.8.1  示例应用程序：日期转换 
作为一个具体的例子，让我们将月份缩写程序扩展成日期转换。用户将输入一个日期，
例如“05/24/2020”，程序将显示日期为“May 24, 2020”。下面是该程序的算法： 
我们可以用讨论过的字符串操作，在代码中直接实现算法的前两行：
这里我得到了一个字符串的日期，并以斜杠分隔。然后利用同时赋值，将三个字符串
的列表“分拆”到变量monthStr、dayStr 和yearStr 中。 
第5 章  序列：字符串、列表和文件
接下来是将monthStr 转换为适当的数字（再次使用int），然后用该值查找正确的月份
名称。下面是代码：
回忆一下，使用索引表达式int(monthStr)-1 是因为列表索引从0 开始。 
程序的最后一步是以新格式拼出日期：
注意我如何使用连接实现紧跟日期的逗号。
下面是完整的程序：
运行时，输出如下所示：
虽然这个例子没有展示，但我们常常也需要将数字转成字符串。在Python 中，大多数
数据类型可以用str 函数转换为字符串。下面是几个简单的例子： 
特别注意最后一个例子。通过将值转换为字符串，我们可以用字符串连接在句子的结
尾处放置句点。如果我们不首先将值转换为字符串，Python 会将“+”解释为数字运算并产
生错误，因为“.”不是数字。 
我们现在有了一套完整的操作，用于在各种Python 数据类型之间转换值。表5.4 总结
了这四种Python 类型转换函数。 
5.8  输入/输出作为字符串操作 
将expr 转换为浮点值 
将expr 转换为整数值 
返回expr 的字符串表示形式 
将字符串作为表达式求值
将数字转换为字符串有一个常见原因，即字符串操作可用于控制值的打印方式。例如，
执行日期计算的程序必须将月、日和年作为数字操作。对于格式化的输出，这些数字将被
5.8.2  字符串格式化 
如你所见，基本的字符串操作可以用来构建格式正确的输出。这种技术对于简单的格
式化是有用的，但是通过较小字符串的切片和连接来构建复杂的输出可能是无趣的。Python
提供了一个强大的字符串格式化操作，让事情更容易。
让我们从一个简单的例子开始。下面是第3 章中的零钱计数程序的运行： 
注意，最终值是以只有一个小数位的小数形式给出的。这看起来有点怪，因为我们期
望输出是1.50 美元。 
可以通过更改程序的最后一行来解决这个问题，如下所示：
现在程序打印以下消息：
让我们试着解释一下其中的含义。format 方法是内置的Python 字符串方法。想法是用
字符串作为一种模板，值作为参数提供，插入到该模板中，从而形成一个新的字符串。所
以字符串格式化的形式为：
模板字符串中的花括号（{}）标记出“插槽”，提供的值将插入该位置。花括号中的信
息指示插槽中的值以及值应如何格式化。Python 格式化操作符非常灵活。我们将在这里介
绍一些基础知识。如果你希望了解所有的细节，可以参考Python 文档。在本书中，插槽说
明总是具有以下形式：
第5 章  序列：字符串、列表和文件
索引告诉哪个参数被插入到插槽中
①。像Python 中的惯例一样，索引从0 开始。在上面
的例子中，有一个插槽，索引0 用于表示第一个（也是唯一的）参数插入该插槽。 
冒号后的描述部分指定值插入插槽时该值的外观。再次回到示例，格式说明符为0.2f。
此说明符的格式为<宽度>.<精度><类型>。宽度指明值应占用多少“空间”。如果值小于指
定的宽度，则用额外的字符填充（空格是默认值）。如果值需要的空间比分配的更多，它会
占据显示该值所需的空间。所以在这里放置一个0 基本上是说“使用你需要的空间”。精度
②，这告诉Python 将值舍入到两个小数位。最后，类型字符f 表示该值应显示为定点数。
这意味着，将始终显示指定的小数位数，即使它们为0。 
对格式说明符的完整描述相当难理解，但你可以通过查看几个例子较好地掌握它。最
简单的模板字符串只是指定在哪里插入参数。
通常，我们想要控制一个数学值的宽度和精度。
请注意，对于正常（非定点）浮点数，精度指明要打印的有效数字的个数。对于定点（由指
定符末尾的f 表示），精度表示小数位数。在最后一个示例中，相同的数字以两种不同的格式打印
出来。这说明，如果打印一个浮点数的足够数字，你几乎总是会发现“惊喜”。计算机不能将3.14
准确表示为一个浮点数。它可以表示的最接近的值稍大于3.14。如果没有给出明确的精度，Python
会把数字打印到几个小数位。如果打印许多数字，稍多出来的数量就会显示出来。一般来说，Python
只显示一个接近的、舍入的浮点型。使用显式格式化可以查看到完整结果，直到最后一位。
你可能会注意到，默认情况下，数值是右对齐的。这有助于在列中排列数字。另一方
面，字符串在其字段中是左对齐的。通过在格式说明符的开头包含显式调整字符，你可以
更改默认行为。对于左、右和中心对齐，所需的字符分别为<、>和^。 
①在Python 3.1 中，插槽描述的索引部分是可选的。省略索引时，参数仅以从左到右的方式填充到插槽中。
5.9  文件处理 
5.8.3  更好的零钱计数器 
让我们用一个示例程序结束格式化的讨论。考虑到你对浮点数的了解，你可能对用它
们表示货币有点不安。
假设你正在为一家银行编写一个计算机系统。你的客户得知收费是“非常接近107.56
美元”的金额，恐怕不会太高兴。他们希望知道银行正在精确记录他们的钱。即使给定值
中的误差量非常小，如果进行大量计算，小误差也可能复杂化，而且导致的误差可能累积
为真实的金额。这不是令人满意的经营方式。
更好的方法是确保程序用确切的值来表示钱。我们可以用美分来记录货币，并用int 来
存储它。然后我们可以在输出步骤中将它转换为美元和美分。假设我们处理正数，如果total
代表以分为单位的值，那么我们可以通过整数除法total // 100 得到美元数，通过total % 100
得到美分数。这两个都是整数计算，因此会给出确切的结果。下面是更新的程序：
我已经把最后的打印语句分成两行。通常一个语句在行末结束，但有时将较长的语句分成较
小的部分更好。因为这行在打印函数的中间断开，Python 知道，语句在完成最后一个闭括号之前
没有结束。在这个例子中，将语句跨两行，而不是很长的一行，这是可以的，而且更好。
print 语句中的字符串格式化包含两个插槽，一个用于美元，是int，另一个用于美分。
美分插槽说明了格式说明符的另一种变化。美分的值用格式说明符“0>2”打印。前面的调
整字符0 告诉Python 用0 来填充字段（如果必要），而不是空格。这确保10 美元5 美分这
样的值打印为10.05 美元，而不是10.5 美元。 
5.9  文件处理 
本章开始时，我说字处理是字符串数据类型的应用程序。所有字处理程序都有一个关
第5 章  序列：字符串、列表和文件
键特征，即能够保存和读取文档，作为磁盘上的文件。在本节中，我们来看一下文件的输
入和输出。结果表明，这只是另一种形式的字符串处理。
5.9.1  多行字符串 
在概念上，文件是存储在辅助存储器（通常在磁盘驱动器上）的数据序列。文件可以包
含任何数据类型，但最简单的文件是包含文本的文件。文本文件的优点是可以被人阅读和理
解，并且它们可以容易地使用通用文本编辑器（诸如IDLE）和字处理程序来创建和编辑。在
Python 中，文本文件可以非常灵活，因为它很容易在字符串和其他类型之间来回转换。 
你可以将文本文件看成一个（可能很长的）字符串，恰好存储在磁盘上。当然，典型
的文件通常包含多于一行的文本。特殊字符或字符序列用于标记每行的结尾。对于行结束
标记有许多约定。Python 为我们处理这些不同的约定，只要使用常规换行符（\n）来表示换
让我们来看一个具体的例子。假设你在文本编辑器中键入以下行：
如果存储到文件，你会得到以下字符序列：
请注意，在得到的文件/字符串中，空行变为一个换行符。 
顺便说一下，这真的没有什么不同，就像我们将换行字符嵌入到输出字符串，用一个
打印语句生成多行输出一样。下面是上面例子的交互式打印：
记住，如果只是在shell 中对一个包含换行符的字符串求值，将再次得到嵌入换行符的
只有当打印字符串时，特殊字符才会影响字符串的显示方式。
5.9.2  文件处理 
文件处理的确切细节在编程语言之间有很大不同，但实际上所有语言都共享某些
底层的文件操作概念。首先，我们需要一些方法将磁盘上的文件与程序中的对象相关
联。这个过程称为“打开”文件。一旦文件被打开，其内容即可通过相关联的文件对
5.9  文件处理 
其次，我们需要一组可以操作文件对象的操作。这至少包括允许我们从文件中读取信
息并将新信息写入文件的操作。通常，文本文件的读取和写入操作类似于基于文本的交互
式输入和输出的操作。
最后，当我们完成文件操作，它会被“关闭”。关闭文件确保所有必需的记录工作都已
完成，从而保持磁盘上的文件和文件对象之间的一致。例如，如果将信息写入文件对象，
则在文件关闭之前，更改可能不会显示在磁盘版本上。
这种打开和关闭文件的思想，与字处理程序这样的应用程序中处理文件的方式密切相
关。但是，概念不完全相同。当你在Microsoft Word 这样的程序中打开文件时，该文件实际
上是从磁盘读取并存储到RAM 中。用编程术语来说，打开文件以进行读取，然后通过文件
读取操作将文件的内容读入内存。此时，文件被关闭（也是在编程意义上）。当你“编辑文
件”时，真正改变的是内存中的数据，而不是文件本身。这些更改不会显示在磁盘上的文
件中，除非你通知应用程序“保存”。
保存文件还涉及多步骤过程。首先，磁盘上的原始文件被重新打开，这一次用允许它
存储信息的模式：磁盘上的文件被打开以进行写入。这样做实际上会擦除文件的旧内容。
然后用文件写入操作将内存中版本的当前内容复制到磁盘上的新文件中。从你的角度来看，
你似乎编辑了已有文件。从程序的角度来看，你实际上打开了一个文件，读取它的内容到
内存，关闭文件，创建一个新文件（具有相同的名称），将内存中的（修改的）内容写入新
文件，并关闭这个新文件。
在Python 中使用文本文件很容易。第一步是创建一个与磁盘上的文件相对应的文件对
象。这是用open 函数完成的。通常，文件对象立即分配给变量，如下所示： 
这里的name 是一个字符串，它提供了磁盘上文件的名称。mode 参数是字符串“r”或
“w”，这取决于我们打算从文件中读取还是写入文件。 
例如，要打开一个名为“numbers.dat”的文件进行读取，可以使用如下语句： 
现在我们可以利用文件对象infile 从磁盘读取numbers.dat 的内容。 
Python 提供了三个相关操作从文件中读取信息： 
<file>.read()将文件的全部剩余内容作为单个（可能是大的、多行的）字符串返回。 
<file>.readline()返回文件的下一行。即所有文本，直到并包括下一个换行符。 
<file>.readlines()返回文件中剩余行的列表。每个列表项都是一行，包括结尾处的换行符。 
下面是用read 操作将文件内容打印到屏幕上的示例程序： 
第5 章  序列：字符串、列表和文件
程序首先提示用户输入文件名，然后打开文件以便读取变量infile。你可以使用任意名
称作为变量，我使用infile 强调该文件正在用于输入。然后将文件的全部内容读取为一个大
字符串并存储在变量data 中。打印data 从而显示内容。 
readline 操作可用于从文件读取下一行。对readline 的连续调用从文件中获取连续的行。
这类似于输入，它以交互方式读取字符，直到用户按下<Enter>键。每个对输入的调用从用
户获取另一行。但要记住一件事，readline 返回的字符串总是以换行符结束，而input 会丢
作为一个快速示例，这段代码打印出文件的前五行：
请注意，利用切片去掉行尾的换行符。由于print 自动跳转到下一行（即它输出一个换
行符），打印在末尾带有显式换行符时，将在文件行之间多加一个空行输出。或者，你可以
打印整行，但告诉print 不添加自己的换行符。 
循环遍历文件全部内容的一种方法，是使用readlines 读取所有文件，然后循环遍历结
当然，这种方法的潜在缺点是文件可能非常大，并且一次将其读入列表可能占用太多
幸运的是，有一种简单的替代方法。Python 将文件本身视为一系列行。所以循环遍历
文件的行可以直接如下进行：
这是一种特别方便的方法，每次处理文件的一行。
打开用于写入的文件，让该文件准备好接收数据。如果给定名称的文件不存在，就
会创建一个新文件。注意：如果存在给定名称的文件，Python 将删除它并创建一个新的
空文件。写入文件时，应确保不要破坏你以后需要的任何文件！下面是打开文件用作输
将信息写入文本文件最简单的方法是用已经熟悉的print 函数。要打印到文件，只需要
添加一个指定文件的额外关键字参数：
这个行为与正常打印完全相同，只是结果被发送到输出文件而不是显示在屏幕上。
5.9  文件处理 
5.9.3  示例程序：批处理用户名 
为了看看这些部分是如何组合在一起的，我们重写用户名生成程序。以前的版本通过
让用户输入姓名来交互地创建用户名。如果为大量用户设置账户，则该过程可能不会以交
互方式完成，而是以“批处理”方式进行。在批处理时，程序输入和输出通过文件完成。
我们的新程序设计用于处理一个包含名称的文件。输入文件的每一行将包含一个新用
户的名字和姓氏，用一个或多个空格分隔。该程序产生一个输出文件，其中包含每个生成
这个程序中有一些值得注意的事情。我同时打开两个文件，一个用于输入（infile），一
个用于输出（outfile）。一个程序同时操作几个文件并不奇怪。另外，当创建用户名时，我
使用字符串方法lower。请注意，该方法应用于连接产生的字符串。这确保用户名全部是小
写，即使输入名称大小写混合。
5.9.4  文件对话框（可选） 
使用文件操作程序经常出现一个问题，即决定如何指定要使用的文件。如果数据文件
与你的程序位于同一目录（文件夹），那么只需键入正确的文件名称。没有其他信息，Python
将在“当前”目录中查找文件。然而，有时很难知道文件的完整名称是什么。大多数现代
第5 章  序列：字符串、列表和文件
操作系统使用具有类似<name>.<type>形式的文件名，其中type 部分是描述文件包含什么类
型数据的短扩展名（三个或四个字母）。例如，我们的用户名可能存储在名为“users.txt”的
文件中，其中“.txt”扩展名表示文本文件。困难是，一些操作系统（如Windows 和macOS）
默认情况下只显示在点之前的名称的部分，所以很难找出完整的文件名。
当文件存在于除当前目录之外的某处时，情况更加困难。文件处理程序可能用于辅助
存储器中任何位置存储的文件。为了找到这些远程文件，我们必须指定完整路径在用户的
计算机系统中定位文件。路径的确切形式因系统而异。在Windows 系统上，带有路径的完
整文件名可能如下所示：
这不仅需要打很多字，而且大多数用户甚至可能不知道如何找出其系统上任何给定文
件的完整路径+文件名。 
这个问题的解决方案是允许用户可视地浏览文件系统，并导航到特定的目录/文件。向
用户请求打开或保存文件名是许多应用程序的常见任务，底层操作系统通常提供一种标准
的、熟悉的方式来执行此操作。通常的技术包括对话框（用于用户交互的特殊窗口），它允
许用户使用鼠标在文件系统中点击并且选择或键入文件的名称。幸运的是，包含在（大多
数）标准Python 安装中的tkinter GUI 库提供了一些简单易用的函数，用于创建用于获取文
要询问用户打开文件的名称，可以使用askopenfilename 函数。它在tkinter.filedialog 模
块中。在程序的顶部，需要导入该函数：
在导入中使用点符号，是因为tkinter 是由多个模块组成的包。在这个例子中，我们从
tkinter 中指定filedialog 模块。而不是从这个模块导入一切，我指定了在这里使用的一个函
数。调用askopenfilename 将弹出一个系统对应的文件对话框。 
例如，要获取用户名文件的名称，我们可以使用一行代码，如下所示：
在Windows 中执行此行的结果如图5.2 所示。该对话框允许用户键入文件的名称或
简单地用鼠标选择它。当用户单击“打开”按钮时，文件的完整路径名称将作为字符串
返回并保存到变量infileName 中。如果用户单击“取消”按钮，该函数将简单地返回一
个空字符串。在第7 章中，你将了解如何测试结果值，并根据用户选择的按钮采取不同
Python 的tkinter 提供了一个类似的函数asksaveasfilename，用于保存文件。它的用法非
asksaveasfilename 的示例对话框如图5.3 所示。当然，你可以使用导入同时导入这两个
5.10  小结 
这两个函数还有许多可选参数，让程序可以定制得到的对话框，例如改变标题或建议
默认文件名。如果你对这些细节感兴趣，可以参考Python 文档。 
   图5.2 来自askopenfilename 的文件对话框
图5.3 来自asksaveasfilename 的文件对话框 
本章介绍了Python 字符串、列表和文件对象的重要元素。下面是要点的小结。 
字符串是字符序列。字符串文字可以用单引号或双引号分隔。
  可以用内置的序列操作来处理字符串和列表：连接（+）、重复（*）、索引（[]），
切片（[:]）和长度（len()）。可以用for 循环遍历字符串的字符、列表中的项或文
将数字信息转换为字符串信息的一种方法是用字符串或列表作为查找表。
列表比字符串更通用。
字符串总是字符序列，而列表可以包含任何类型的值。
列表是可变的，这意味着可以通过赋新值来修改列表中的项。
  字符串在计算机中表示为数字代码。ASCII 和Unicode 是用于指定字符和底层代码
之间的对应关系的兼容标准。Python 提供ord 和chr 函数，用于在Unicode 代码和
字符之间进行转换。
  Python 字符串和列表对象包括许多有用的内置方法，用于字符串和列表处理。 
将数据编码以保持私密的过程称为加密。有私钥和公钥两种不同类型的加密系统。 
  程序输入和输出通常涉及字符串处理。Python 提供了许多运算符在数字和字符
串之间来回转换。字符串格式化方法（format）对于生成格式良好的输出特别
文本文件是存储在辅助存储器中的多行字符串。可以打开文本文件进行读取或写
入。打开进行写入时，文件的原有内容将被删除。Python 提供了read()、readline()
和readlines()三种文件读取方法。也可以用for 循环遍历文件的行。用print 函数将
数据写入文件。处理完成后，应关闭文件。
第5 章  序列：字符串、列表和文件
5.11  练习 
1．Python 字符串字面量总是用双引号括起来。 
2．字符串s 的最后一个字符在位置len(s)−1。 
3．一个字符串总是包含一行文本。 
4．在Python 中，"4" + "5"是"45"。 
5．Python 列表是可变的，但字符串不是。 
6．ASCII 是使用数字代码表示字符的标准。 
7．split 方法将一个字符串拆分为一个子字符串列表，而join 则相反。 
8．替换加密是保持敏感信息安全的好方法。 
9．可以用add 方法在列表末尾添加一项。 
10．将文件与程序中的对象相关联的过程称为“读取”该文件。 
1．访问字符串中的单个字符称为
项与s[0:-1]相同。 
a．s [-1] 
c．s [：len(s)-1]  
函数给出了字符的Unicode 值。 
项不能用于将数字字符串转换为数字。
5．包括（几乎）所有书面语言的字符的、ASCII 的后继标准是
b．ASCII ++   
c．Unicode  
字符串方法将字符串的所有字符转换为大写。
a．capitalize  
b．capwords  
c．uppercase 
7．format 方法中填充的字符串“插槽”标记为
不是Python 中的文件读取方法。 
b．readline   
c．readall 
d．readlines 
9．使用文件进行输入和输出的程序的术语是
a．面向文件的  b．多行  
5.11  练习 
10．在读取或写入文件之前，必须创建文件对象
b．create  
d．Folder 
1．给定初始化语句： 
写出以下每个字符串表达式求值的结果。
a．"The Knights who say, " + s2
b．3 * s1 + 2 * s2
d．s1[1:3]
e．s1[2] + s2[:2]
f．s1 + s2[-1]
g．s1.upper()
h．s2.upper().ljust(4) * 3
2．给定与上一个问题相同的初始化语句，写出一个Python 表达式，可以通过对s1 和
s2 执行字符串操作构造以下每个结果。 
b．"ni!spamni!"
c．"Spam Ni! Spam Ni! Spam Ni!"
d．"spam"
e．["sp","m"]
3．显示以下每个程序片段产生的输出： 
a．for ch in "aardvark":
b．for w in "Now is the winter of our discontent...".split():
c．for w in "Mississippi".split("i"):
d．msg = ""
e．msg = ""
第5 章  序列：字符串、列表和文件
4．写出以下每个字符串格式化操作产生的字符串。如果操作不合法，请解释原因。 
a．"Looks like {1} and {0} for breakfast".format("eggs", "spam")
b．"There is {0} {1} {2} {3}".format(1,"spam", 4, "you")
c．"Hello {0}".format("Susan", "Computewell")
d．"{0:0.2f} {0:0.2f}".format(2.3, 2.3468)
e．"{7.5f} {7.5f}".format(2.3, 2.3468)
f．"Time left {0:02}:{1:05.2f}".format(1, 37.374)
g．"{1:3}".format("14")
5．解释为什么公钥加密比私人（共享）密钥加密更有利于保护因特网上的通信。 
1．字符串格式化可以用来简化dateconvert2.py 程序（该程序在本章示例代码中，可下
载获得）。用字符串格式化方法重写该程序。
2．某个CS 教授给出了5 分测验，等级为5-A、4-B、3-C、2-D、1-F、0-F。编写一个
程序，接受测验分数作为输入，并打印出相应的等级。
3．某个CS 教授给出100 分的考试，分数等级为90～100：A、80～89：B、70～79：
C、60～69：D、<60：F。编写一个程序，接受考试成绩作为输入，并打印出相应的等级。 
4．首字母缩略词是一个单词，是从短语中的单词取第一个字母形成的。例如，RAM
是“random access memory”的缩写。编写一个程序，允许用户键入一个短语，然后输出
该短语的首字母缩略词。注意：首字母缩略词应该全部为大写，即使短语中的单词没有
5．数字命理学家声称能够基于名字的“数值”来确定一个人的性格特征。名字的值的
确定方法是名字中字母的值之和，其中“a”为1、“b”为2、“c”为3，直到“z”为26。
例如，名字“Zelle”具有的值为26 + 5 + 12 + 12 + 5 = 60（顺便说一下，这恰好是一个非常
吉利的数字）。编写一个程序，计算输入的单个名字的数值。
6．扩展前一个问题的解决方案，允许计算完整的名字，如“John Marvin Zelle”或“John 
Jacob Jingleheimer Smith”。总值就是所有名字的数值之和。 
7．凯撒密码是一种简单的替换密码，其思路是将明文消息的每个字母在字母表中移
动固定数字（称为密钥）。例如，如果键值为2，则单词“Sourpuss”将被编码为“Uqwtrwuu”。
原始消息可以通过使用密钥的负值“重新编码”来恢复。编写一个可以编码和解码凯撒
密码的程序。对程序的输入将是明文的字符串和密钥的值。输出将是一个编码消息，其
中原始消息中的每个字符都将被替换为Unicode 字符集中后移密钥个字符。例如，如果
ch 是字符串中的字符，key 是要移位的量，则替换ch 的字符可以计算为chr（ord（ch）
8．上一个练习有一个问题，它不处理“超出字母表末端”的情况。真正的凯撒密码以
循环方式移动，其中“z”之后的下一个字符是“a”。修改上一个问题的解决方案，让它循
环。你可以假定输入只包含字母和空格。（提示：创建一个包含字母表所有字符的字符串，
并使用此字符串中的位置作为代码。你不必将“z”转换成“a”，只需确保在字母表字符串
中对整个字符序列中使用循环移位。）
5.11  练习 
9．编写一个程序，计算用户输入的句子中的单词数。 
10．编写一个程序，计算用户输入的句子中的平均单词长度。 
11．编写第1 章中的chaos.py 程序的改进版本，允许用户输入两个初始值和迭代次数，
然后打印一个格式很好的表格，显示这些值随时间的变化情况。例如，如果初始值为0.25
和0.26（10 次迭代），表格可能如下所示： 
12．编写第2 章中的futval.py 程序的改进版本。程序将提示用户投资金额、年化利率
和投资年数。然后程序将输出一个格式正确的表，以年为单位跟踪投资的价值。输出可能
13．重做所有以前的编程问题，让它们采用批处理（使用文本文件进行输入和输出）。 
14．单词计数。UNIX/Linux 系统上有一个通用实用程序，名为“wc”。该程序分析一
个文件以确定其中包含的行数、单词数和字符数。编写你自己的wc 版本。程序应接受文件
名作为输入，然后打印三个数字，显示文件的行数、单词数和字符数。
15．编写一个程序来绘制学生考试成绩的水平柱状图。你的程序应该从文件获取输入。
文件的第一行包含文件中学生数量的计数，后续每行包含学生的姓氏，后跟一个0～100 范
围内的分数。你的程序应为每个学生绘制一个水平柱形，其中柱形的长度表示学生的分数。
柱形应该对齐左边缘排列。（提示：使用学生的人数来确定窗口的大小及其坐标。加分需求：
在柱形左边标注学生姓名。）
16．编写一个程序来绘制测验分数直方图。程序应从文件读取数据。该文件的每一行
第5 章  序列：字符串、列表和文件
包含一个在0～10 范围内的数字。程序必须计算每个分数的出现次数，然后为每个可能分
数（0～10）绘制具有柱形的垂直柱形图，其高度对应于该分数。例如，如果15 个学生得
到8，那么8 的柱的高度应该是15。（提示：使用一个列表来存储每个可能得分的计数。）
直方图的示例如下。
了解程序员为什么将程序分成多组合作的函数。
  能够在Python 中定义新的函数。 
  理解Python 中函数调用和参数传递的细节。 
利用函数来编程，减少代码重复并增加程序的模块性。
6.1  函数的功能 
我们之前编写的程序只包含一个函数，通常称为main。我们还使用了预先编写的函数
和方法，包括内置的Python 函数（如print、abs）、来自Python 标准库的函数和方法（如
math.sqrt）以及来自graphics 模块的方法（如myPoint.getX()）。函数是构建复杂程序的重要
工具。本章介绍如何设计自己的函数，让程序更容易编写和理解。
在第4 章中，我们研究了终值问题的图形解决方案。回想一下，这个程序利用graphics
库来绘制显示投资增长的柱形图。下面是之前的程序：
第6 章  定义函数
这当然是一个可行的程序，但是在程序风格方面有点啰嗦，确实应该解决。注意，
这个程序在两个不同的地方绘制柱形。初始柱形在循环之前绘制，而随后的柱形在循环
两个地方有类似的代码，这有一些问题。显然，一个问题是不得不写两次代码。另一
个更微妙的问题是代码必须在两个不同的地方维护。如果我们决定改变柱形的颜色或其他
方面，就必须确保这些变化在两个地方发生。未能保持代码的相关部分同步是程序维护中
函数可用于减少代码重复，并使程序更易于理解和维护。在修正终值程序之前，我们
来看看函数必须提供什么。
6.2  函数的非正式讨论 
你可以将函数想象成一个“子程序”：程序里面的一个小程序。函数的基本思想是写一
个语句序列，并给这个序列取一个名字，然后可以通过引用函数名称，在程序中的任何位
置执行这些指令。
创建函数的程序部分称为“函数定义”。当函数随后在程序中使用时，我们称该定义被
“调用”。单个函数定义可以在程序的许多不同位置被调用。
让我们举个具体的例子。假设你希望编写一个程序，打印“Happy Birthday”的歌词。
标准歌词看起来像这样：
我们将在交互式Python 环境中展示这个例子。你可以启动Python 并自己尝试一下。 
这个问题的一个简单方法是使用四个print 语句。下面的交互式会话创建了一个程序，
对Fred 唱“Happy Birthday”。 
6.2  函数的非正式讨论 
我们可以运行这个程序，得到歌词：
显然，这个程序中有一些重复的代码。对于这样一个简单的程序，这不是大问题，但
即使在这里也有点烦人，要不断键入同一行内容。让我们引入一个函数，打印第一行、第
二行和第四行歌词。
我们定义了一个名为happy 的新函数。下面的例子说明了它的作用： 
调用happy 命令会使Python 打印一行歌词。 
现在我们可以用happy 为Fred 重写歌词。我们把新版本称为singFred。 
这个版本打的字要少得多，感谢happy 命令。让我们试着打印给Fred 的歌词，只是为
了确保它能工作。
到现在为止还挺好。现在假设今天也是Lucy 的生日，我们希望为Fred 唱一首歌，接下
来为Lucy 再唱一首。我们已经得到了Fred 的歌词，可以为Lucy 也准备一个。 
现在我们可以写一个主程序，唱给Fred 和Lucy： 
两个函数调用之间的print 在输出的歌词之间留出空行。下面是最终产品的效果： 
第6 章  定义函数
现在，这似乎肯定能工作，我们已通过定义happy 函数消除了一些重复。然而，还是感
觉有点不对。我们有singFred 和singLucy 两个函数，它们几乎相同。按照这种方法，为Elmer
添加歌词需要我们创建一个singElmer 函数，看起来就像为Fred 和Lucy 的那样。我们能对
歌词的增长做点什么吗？
请注意，singFred 和singLucy 之间的唯一区别是第三个print 语句结束时的名称。除了
这一个变化的部分以外，这些歌词完全相同。我们可以通过使用“参数”，将这两个函数合
并在一起。让我们写一个名为sing 的通用函数： 
此函数利用名为person 的参数。参数是在调用函数时初始化的变量。我们可以用sing
函数为Fred 或Lucy 打印歌词。只需要在调用函数时提供名称作为参数： 
让我们用一个程序结束，这个程序对所有三个过生日的人唱歌：
下面是作为模块文件的完整程序：
6.3  带有函数的终值程序 
6.3  带有函数的终值程序 
既然你已经了解了定义函数如何有助于解决代码重复问题，让我们回到终值的图。记
住，问题是图中的柱形在程序中的两个不同的地方绘制。循环之前的代码如下：
而循环中的代码如下：
让我们尝试将这两段代码合并成一个函数，在屏幕上绘制柱形。
为了画柱形，我们需要一些信息。具体来说，我们需要知道柱形的年份、柱形的高度
以及绘制柱形图的窗口。这三个值将作为函数的参数提供。下面是函数定义：
要使用该函数，只要为三个参数提供值。例如，如果win 是GraphWin，我们可以通过
调用drawBar 来绘制第0 年的柱形，本金为2000 美元，如下所示： 
利用drawBar 函数，下面是终值程序的最新版本： 
第6 章  定义函数
你可以看到drawBar 如何消除了重复的代码。如果我们希望改变图形中柱形的外观，只
需要在一个地方改变drawBar 的定义。如果你不明白这个例子的每一个细节，不要担心。关
于函数，你还有一些事情要了解。
6.4  函数和参数：令人兴奋的细节 
你可能对drawBar 函数的参数选择感到好奇。显然，绘制柱形的年份和柱形的高度是柱
形图的可变部分。但是为什么window 也是这个函数的参数呢？毕竟，我们将在同一个窗口
中绘制所有的柱形，它似乎没有改变。
使用window 参数的原因与函数定义中变量的“范围”有关。范围是指在程序中可以引
用给定变量的位置。记住，每个函数本身都是一个小子程序。在一个函数内部使用的变量
是该函数的“局部”变量，即使它们碰巧与另一个函数中的变量具有相同的名称。
函数要看到另一个函数中的变量，唯一方法是将该变量作为参数传入
①。由于GraphWin
（分配给变量win）是在main 内部创建的，因此不能在drawBar 中直接访问。但是，当drawBar
被调用时，drawBar 中的window 参数被赋值为win 的值。要理解这种情况，我们需要更详
细地了解函数调用的过程。
①技术上，可以在嵌套在另一个函数内的函数中引用变量，但是函数嵌套超出了本书讨论的范围。
6.4  函数和参数：令人兴奋的细节 
函数的name 必须是标识符，而formal-parameters（“形参”）是变量名（也是标识符）
的序列（可能为空）。形参与函数中使用的所有变量一样，只能在函数体中访问。在程序其
他地方，具有相同名称的变量与函数体内的形参和变量不同。
函数的调用是使用其名称后跟“实参”或“参数”的列表。
Python 遇到一个函数调用时，启动一个四步过程： 
第一步，调用程序在调用点暂停执行。
第二步，函数的形参获得由调用中的实参提供的值。
第三步，执行函数体。
第四步，控制返回到函数被调用之后的点。
回到Happy Birthday 的例子，让我们追踪唱两次歌词的过程。下面是main 函数体的一
Python 遇到sing("Fred")时，main 的执行暂停。在这里，Python 查找sing 的定义，并且
看到它具有单个形参person。形参被赋予实参的值，所以这就好像我们执行了下面的语句： 
这种情况的快照如图6.1 所示。注意，sing 里面的变量person 刚刚被初始化。 
图6.1  控制转移到sing 的图示 
在这里，Python 开始执行sing 的函数体。第一个语句是另一个函数调用，这次是happy。
Python 暂停执行sing 并将控制传递给被调用的函数。happy 的函数体包含一个print。这个
语句被执行，然后控制返回到它离开的地方。图6.2 展示了到目前为止执行的快照。 
图6.2  完成对happy 调用的快照 
执行以这种方式继续，Python 又绕路去了两次happy，完成了sing 的执行。当Python
到达sing 的末尾时，控制就返回到main，并在函数调用之后紧接着继续。图6.3 显示了此
时我们的位置。注意，sing 中的person 变量已经消失了。函数完成时，会回收局部函数变
第6 章  定义函数
量占用的内存。局部变量不保留从一个函数执行到下一个函数执行的任何值。
图6.3  完成对sing 调用的快照 
下一个要执行的语句是main 中的空白print 语句。这将在输出中生成空行。然后Python
遇到另一个对sing 的调用。如前所述，控制转移到函数定义。这次形参是“Lucy”。图6.4
展示了第二次开始执行时的情况。
图6.4  第二次调用sing 的快照 
现在我们快进到最后。针对Lucy 执行sing 的函数体（通过happy 的三次绕路执行），
并且在函数调用的点之后控制返回到main。现在我们已经到达代码片段的底部，如图6.5
所示。main 中这三句话导致sing 执行了两次、happy 执行了六次。总共产生了9 行输出。 
图6.5  完成第二次对sing 的调用 
希望你明白了函数调用的工作原理。这个例子没有提到的一点是使用多个参数。通
常，当函数定义具有多个参数时，实参按位置与形参匹配。第一个实参分配给第一个形
参，第二个实参分配给第二个形参，以此类推。可以利用关键字参数修改此行为，这些
参数通过名称匹配（如调用print 中的end=""）。然而，在所有示例函数中，我们将依赖
作为示例，再看看终值程序中drawBar 函数的使用。下面是绘制初始柱形的调用： 
当Python 将控制转移到drawBar 时，这些参数与函数标题中的形参匹配： 
实际效果就像函数体以三个赋值语句开头：
调用函数时，必须始终小心，将实参的顺序写正确，以符合函数定义。
6.5  返回值的函数 
6.5  返回值的函数 
你已经看到，参数传递提供了一种初始化函数中变量的机制。从某种意义上说，参数
是函数的输入。我们可以调用一个函数多次，并通过更改输入参数获得不同的结果。通常
我们还希望从函数中获取信息。事实上，函数的基本思想和词汇是从数学中借用的，其中
函数被认为是输入变量和输出变量之间的关系。例如，数学家可以定义函数f，该函数计算
其输入的平方。数学上我们会写这样的东西：
这表明f 是一个函数，它对单个变量（这里称为x）进行操作，并产生一个值，即x 的
与Python 函数一样，数学家使用括号表示法来表示函数的应用。例如，f(5) = 25 表示
当f 作用于5 时，结果为25。我们将说“f 作用于5 等于25”。数学函数不限于单个参数。
例如，我们可以定义一个函数，该函数利用毕达哥拉斯定理，根据给定的直角边长度，产
生直角三角形的斜边的长度。假定我们称之为函数h： 
根据这个定义，你应该能够验证h(3, 4) = 5。 
到目前为止，我们一直在利用例子讨论Python 函数的细节，其中函数被用作新的命令，
被调用来执行命令。但在数学上，函数调用实际上是一个产生结果的表达式。我们可以轻
松地扩展我们的Python 函数观点，以符合这个思想。事实上，你已经看到了许多这种类型
的函数的例子。例如，考虑从math 库调用sqrt 函数： 
这里b*b-4*a*c 的值是math.sqrt 函数的实参。由于函数调用发生在赋值语句的右侧，
这意味着它是一个表达式。math.sqrt 函数生成一个值，然后将该值赋给变量discRt。技术上，
我们说sqrt 返回其参数的平方根。 
编写返回值的函数非常容易。下面是一个函数的Python 实现，返回其参数的平方： 
你看到这个函数定义与上面的数学版本（f(x)）非常相似吗？Python 函数的主体由一个
return 语句组成。当Python 遇到return 时，它立即退出当前函数，并将控制返回到函数被调
用之后的点。此外，return 语句中提供的值作为表达式结果发送回调用者。本质上，这只是
为前面提到的四步函数调用过程添加了一个小细节：函数的返回值用作表达式的结果。
效果就是，我们可以在代码中任何可以合法使用表达式的地方使用square 函数。下面
是一些交互示例：
第6 章  定义函数
让我们用square 函数来写另一个函数，找到两点之间的距离。给定两个点（x1, y1）和
（x2, y2），它们之间的距离是
。下面是一个Python 函数，计算两个Point
对象之间的距离：
利用distance 函数，我们可以增强第4 章中的交互式三角形程序计算三角形的周长。下
面是完整的程序：
6.5  返回值的函数 
你可以看到一行中三次调用distance，以计算三角形的周长。在这里用一个函数节省了
相当多的冗长编码。返回值的函数非常有用、灵活，因为它们可以组合在这样的表达式中。 
顺便说一下，程序中函数定义的顺序并不重要。例如，如果让main 函数在顶部定义，
同样能工作。我们只要确保在程序实际尝试运行函数之前定义函数。因为直到模块的最后
一行才会发生main()的调用，所以所有的函数在程序实际开始运行之前已被定义。 
作为另一个例子，我们回到Happy Birthday 程序。在最初的版本中，我们使用了几个包
含print 语句的函数。我们可以不让辅助函数执行打印，而是简单地让它们返回值（在这个
例子中是字符串），然后由main 打印。请考虑这个版本的程序： 
注意，所有的打印都在一个地方（main 函数中）进行，而happy 和verseFor 只负责创
建和返回适当的字符串。利用函数返回值的魔力，我们已经精简了程序，让整个句子建立
在单个字符串表达式中。
应确保仔细查看并理解这行代码，它真正地展示了带返回值的函数的力量和美丽。
除了更优雅之外，这个版本的程序也比原来的更灵活，因为打印不再分布在多个函数
中。例如，我们可以轻松地修改程序，将结果写入文件而不是屏幕。我们要做的是打开一
个文件进行写入，并在print 语句中添加一个“file=”参数。不需要修改其他函数。下面是
通常，让函数返回值，而不是将信息打印到屏幕上，几乎总是更好（更灵活）。这样，
调用者可以选择是打印信息还是将它用于其他用途。
有时一个函数需要返回多个值。这可以通过在return 语句中简单地列出多个表达式来完
成。作为一个不太聪明的例子，下面是一个计算两个数字的和与差的函数：
如你所见，这个return 传递回两个值。调用这个函数时，我们将它放在一个同时赋值中： 
第6 章  定义函数
与参数一样，从函数返回多个值时，它们根据位置赋给变量。在这个例子中，s 将获得
return 列出的第一个值（sum），d 将获得第二个值（diff）。 
这差不多就是关于Python 中返回值的函数要知道的一切。有一点要提示你。从技术上
讲，Python 中的所有函数都返回一个值，而不管函数实际上是否包含return 语句。没有return
的函数总是返回一个特殊对象，表示为None。这个对象通常用作变量的一种默认值，如果
它当前没有指向任何有用的对象。新的（和不那么新的）程序员常犯一个错误，即写一个
应该返回值的函数，但忘记在结尾包括return 语句。 
假设我们忘记在distance 函数的结尾包括return 语句： 
用这个版本的distance 运行修订的三角形程序，会产生以下Python 错误消息： 
这里的问题是，这个版本的distance 不返回一个数字，它总是返回None。没有为None（它
是特殊类型NoneType）定义加法，所以Python 抱怨。如果你的返回值的函数产生了奇怪的错
误信息涉及None，或者程序在输出中打印出一个神秘的“None”，应检查是否漏了return 语句。 
6.6  修改参数的函数 
返回值是从函数发送信息到调用函数的程序部分的主要方式。在某些情况下，函数还
可以通过更改函数参数来与调用程序通信。理解何时以及如何实现这一点，需要掌握Python
如何赋值的一些微妙细节，以及这对函数调用中使用的实参和形参之间关系的影响。
我们从一个简单的例子开始。假设你正在编写一个管理银行账户或投资的程序。一个
必须执行的常见任务是在账户上累积利息（就像我们在终值程序中所做的那样）。我们可以
考虑编写一个函数，自动将利息添加到账户余额。下面是第一次尝试这样的函数：
该函数的目的是将账户的余额设置为已按照利息金额更新的值。
让我们通过编写一个非常小的测试程序来测试我们的函数：
6.6  修改参数的函数 
你认为这个程序将打印什么？我们的目的是amount 应该添加%5，给出的结果是1050。
下面是实际发生的情况：
如你所见，amount 没变！出了什么错？ 
事实上，没有出错。如果你仔细考虑我们已经讨论的函数和参数，就会看到，这正是
我们应该期待的结果。让我们跟踪这个例子的执行，看看会发生什么。test 函数的前两行创
建了名为amount 和rate 的两个局部变量，它们分别具有初始值1000 和0.05。 
接下来，控制转移到addInterest 函数。形参balance 和rate 被赋为来自实参amount 和rate 的
值。记住，即使名称rate 出现在两个函数中，它们也是两个单独的变量。addInterest 开始执行的
情况如图6.6 所示。注意，参数的赋值导致addInterest 中的变量balance 和rate 引用了实参的“值”。 
图6.6  控制转移到addInterest 
执行addInterest 的第一行会创建一个新变量newBalance。现在是关键的一步。addInterest
中的下一个语句为balance 赋值，让它具有与newBalance 相同的值。结果如图6.7 所示。注
意，balance 现在指的是与newBalance 相同的值，但这对test 函数中的amount 没有影响。 
图6.7  balance 的赋值 
第6 章  定义函数
此时，addInterest 的执行已完成，控制返回到test。addInterest 中的局部变量（包括参
数）消失，但测试函数中的amount 和rate 仍分别指初始值1000 和0.05。当然，程序打印
的amount 是1000。 
综上所述，函数的形参只接收实参的“值”。该函数不能访问保存实参的变量。因此，
为形参分配新值对包含实参的变量没有影响。用编程语言的术语，Python“按值”传递所有
一些编程语言（如C++和Ada）允许变量本身作为参数发送到函数。这种机制称为“按
引用”传递参数。当变量按引用传递时，向形参分配新值实际上会更改调用程序中的参数
因为Python 不允许按引用传递参数，所以一个明显的替代方法是更改我们的addInterest
函数，让它返回newBalance。然后，该值可用于更新test 函数中的amount。下面是一个能
工作的版本（addinterest2.py）： 
你应该很容易地跟踪这个程序的执行，看看我们如何得到这个输出：
现在假设不是查看单个账户，而是编写一个处理许多银行账户的程序。我们可以将账
户余额存储在Python 列表中。有一个addInterest 函数将累积的利息添加到列表中的所有余
额是很好的。如果balance 是账户余额列表，我们可以使用一行代码更新列表中的第一个数
量（索引为0），如下所示： 
记住，这是因为列表是可变的。这行代码实质上在说，“将列表的第0 个位置的值乘以
(1 + rate)，并将结果存回到列表的第0 个位置。”当然，非常相似的一行代码将更新列表中
下一个位置的余额，我们只要用1 替换0： 
更新列表中所有余额的更一般方法，是使用循环遍历位置0，1，……，长度−1。请考
虑addinterest3.py： 
6.6  修改参数的函数 
请花一点时间研究这个程序。test 函数开始将amounts 设置为四个值的列表。然后
addInterest 函数被调用，amounts 作为第一个参数。在函数调用之后，打印出amounts 的值。
你预期会看到什么？运行程序，看看会发生了什么：
这不是很有趣吗？在这个示例中，函数似乎更改了amounts 变量的值。但我刚才告诉你，
Python 传递参数的值，所以变量本身（amounts）不能被函数改变。那么这里发生了什么？ 
test 的前两行创建了变量的amounts 和rates，然后控制转移到addInterest 函数。此时的
情况如图6.8 所示。 
图6.8  将列表参数传给addInterest 
请注意，变量amounts 的值现在是一个列表对象，它本身包含四个int 值。这个列表对
象被传递给addInterest，因此也是balances 的值。 
接下来，addInterest 执行。循环遍历范围0，1，……，长度−1 中的每个索引，并更新
balances 中的项。结果如图6.9 所示。 
图6.9  在addInterest 中修改的列表 
第6 章  定义函数
你会注意到，在图中我留下了原来的值（1000，2200，800，360），只是放在边上。这
样做是为了强调值框中的数字没有改变。相反，发生的事情是创建了新值，并且列表中的
赋值导致它引用新值。当Python 执行垃圾收集时，原来的值将被清除。 
现在应该清楚了，为什么addInterest 程序的列表版本会产生它的答案。当addInterest
终止时，保存在amounts 中的列表已经包含了新余额，这就是打印的内容。这里的重点是变
量amounts 从未改变。与调用addInterest 之前相比，它仍然引用相同的列表。发生的事情是，
该列表的状态已更改，而这种更改在调用程序中可见。
现在你真的知道了关于Python 如何传递函数参数的一切。 参数始终通过值传递。但是，
如果实参是一个变量，其值是一个可变对象（如列表或图形对象），则对象状态的更改对调
用程序是可见的。这种情况是第4 章讨论的别名问题的另一个例子。 
6.7  函数和程序结构 
到目前为止，我们一直在讨论函数作为减少代码重复的机制，从而缩短和简化程序。
令人惊讶的是，即使函数实际上让程序更长，也会经常使用。使用函数的第二个原因是让
由于你设计的算法越来越复杂，因此理解程序也越来越难。人类很擅长一次跟踪八到
十件事情。如果面对一个几百行的算法，就算最好的程序员，也会在困惑中认输。
处理这种复杂性的一种方法是将算法分解成更小的子程序，每个子程序自身都有意义。
稍后在第9 章讨论程序设计时，我将更进一步讨论。现在，我们来看一个例子。让我们再
次回到终值问题。下面是之前的main 程序： 
6.7  函数和程序结构 
虽然我们已经通过使用drawBar 函数缩短了这个算法，但是它仍然很长，这使得通读它
有点困难。注释有助于解释事情，但（坦白说）这个函数太长了。使程序更可读的一种方
法是将一些细节移动到单独的函数中。例如，在中间有8 行，它们就是创建将绘制图表的
窗口。我们可以把这些步骤放到一个返回值的函数中：
顾名思义，该函数负责绘制初始窗口的所有细节。它是一个自包含的实体，执行这个
明确定义的任务。
利用新函数，main 算法看起来更简单： 
注意，我已经删除了注释，该算法的意图现在是清楚的。使用适当命名的函数，代码
变得几乎是自解释的。
下面是终值程序的最终版本：
第6 章  定义函数
虽然这个版本比以前的版本更长，但有经验的程序员会发现它更容易理解。随着你习
惯于阅读和写作函数，也将学会欣赏更加模块化代码的优雅。
函数是一种子程序。程序员使用函数来减少代码重复，并用于组织或模块化程序。
一旦定义了函数，它可以从程序中的许多不同位置被多次调用。参数允许函数具
有可更改的部分。函数定义中出现的参数称为形参，函数调用中出现的表达式称
对函数的调用启动一个四步过程：
第一步，调用程序暂停。
第二步，实参的值赋给形参。
第三步，执行函数体。
第四步，控制在调用程序中的函数调用之后立即返回。函数返回的值作为表达式结果。 
变量的作用域是程序可以引用它的区域。函数定义中的形参和其他变量是函数的
局部变量。局部变量与可在程序其他地方使用的同名变量不同。
  函数可以通过返回值将信息传递回调用者。在Python 中，函数可以返回多个值。
返回值的函数通常应该从表达式内部调用。没有显式返回值的函数会返回特殊对
  Python 按值传递参数。如果传递的值是可变对象，则对象所做的更改会对调用者
1．程序员很少定义自己的函数。 
2．函数只能在程序中的一个位置调用。 
3．信息可以通过参数传递到函数中。 
4．每个Python 函数都返回某些值。 
5．在Python 中，某些参数按引用传递。 
6．在Python 中，函数只能返回一个值。 
7．Python 函数永远不能修改参数。 
8．使用函数的一个原因是减少代码重复。 
9．函数中定义的变量是该函数的局部变量。 
10．如果定义新的函数使程序更长，那么，这是一个坏主意。 
1．程序中使用函数的部分称为
2．Python 函数定义的开头是
b．define 
c．function 
3．函数可以将输出发送回程序，使用
a．return  
c．assignment d．SASE 
4．正式且实际的参数匹配是按
项“不是”函数调用过程中的一个步骤。
a．调用程序挂起 
b．形参被赋予实参的值 
c．函数的主体执行 
d．控制返回到调用函数之前的点 
6．在Python 中，实际的参数被
项不是使用函数的原因。
第6 章  定义函数
a．减少代码重复 
b．使程序更模块化 
c．使程序更自解释 
d．展示智力优势 
8．如果一个函数返回一个值，它通常应该在
9．没有return 语句的函数返回
10．函数可以修改实参的值，如果它是
c．按引用传递的 d．变量 
1．用你自己的话来描述在程序中定义函数的两个动机。 
2．我们一直将计算机程序看成是指令序列，即计算机有条不紊地执行一个指令，然后
移动到下一个指令。包含函数的程序是否适合这个模型？请解释你的答案。
3．参数是定义函数的一个重要概念。 
a．参数的目的是什么？ 
b．形参和实参之间有什么区别？ 
c．参数与普通变量在哪些方面类似，哪些方面不同？  
4．函数可以被认为是其他程序中的微型（子）程序。与任何其他程序一样，我们可以
将函数看成具有输入和输出，与main 程序通信。 
a．程序如何提供“输入”到一个函数？ 
b．函数如何为程序提供“输出”？ 
5．考虑下面这个非常简单的函数： 
a．这个函数做什么？ 
b．说明程序如何使用此函数打印y3 的值，假设y 是一个变量。 
c．下面是使用这个函数的程序的一个片段： 
result = cube（3） 
print（answer，result） 
这个片段的输出是4 27。解释为什么输出不是27 27，虽然cube 似乎将answer
的值改成了27。 
1．编写一个程序来打印歌曲“Old MacDonald”的歌词。你的程序应该打印五种不同
动物的歌词，类似于下面的例子。
2．写一个程序来打印“The Ants Go Marching.”十段的歌词。下面给出几个例句。你
可以为每一节中的“little one”选择你自己的活动，但一定要选择一些押韵（或几乎押韵）
3．写出这些函数的定义： 
sphereArea(radius)返回具有给定半径的球体的表面积。 
sphereVolume(radius)返回具有给定半径的球体的体积。 
使用你的函数来解决第3 章中的编程练习1。 
4．写出以下两个函数的定义： 
sumN(n)返回前n 个自然数的和。 
sumNCubes(n)返回前n 个自然数的立方的总和。 
然后在提示用户输入n 的程序中使用这些函数，并打印出前n 个自然数的和与前n 个
自然数的立方之和。
5．第3 章的重做编程练习2。使用两个函数：一个计算比萨饼的面积，一个计算每平
6．编写一个函数，给定三边的长度作为参数，计算三角形的面积（参见第3 章编程练
习9）。使用你的函数来增强本章中的triangle2.py，让它也显示三角形的面积。 
7．编写一个函数来计算第n 个斐波纳契数。用你的函数来解决第3 章中的编程练习16。 
8．用返回下一个猜测的函数nextGuess(guess,x)解决第3 章中的编程练习17。 
9．用返回分数的字母等级的函数grade(score)完成第5 章的编程练习3。 
10．用函数acronym(phrase)完成第5 章的编程练习4，该函数返回字符串短语的
11．编写并测试一个函数，满足以下规格说明。 
squareEach(nums) nums 是一个数字列表。修改列表，对每一项平方。 
12．编写并测试一个函数，满足以下规格说明。 
sumList(nums) nums 是一个数字列表。返回列表中数字的和。 
第6 章  定义函数
13．编写并测试一个函数，满足以下规格说明。 
toNumbers(strList) strList 是一个字符串列表，每个字符串表示一个数字。修
改列表，将每一项转换为数字。
14．使用前面三个问题中的函数来实现计算从文件读取的数字的平方和的程序。你的
程序应提示输入文件名，并打印出文件中值的平方和。（提示：使用readlines()。） 
15．编写并测试一个函数，满足以下规模说明。 
drawFace(center,size,win) center 是一个Point，size 是一个int，win 是
一个GraphWin。在win 中绘制一张给定尺寸的简单的脸。 
你的函数可以画一个简单的笑脸（或严峻的脸）。编写一个在单个窗口中绘制不同大小
的几张脸的程序，来演示该函数。
16．使用上一个练习中的drawFace 函数来编写照片匿名程序。此程序允许用户加载
图像文件（例如PPM 或GIF），并在照片中已有的脸上绘制卡通脸。用户首先输入包含图像
的文件的名称。显示图像，并询问用户要遮挡多少脸。然后程序进入一个循环，供用户点
击每个脸的两个点：中心和脸边缘上的某处（以确定脸的大小）。然后程序应使用drawFace
函数在该位置绘制一个脸。
（提示：4.8.4 节描述了图形库中的图像处理方法。将图像居中显示在GraphWin 中，
窗口的大小与图像相同，并将图形绘制到此窗口中。你可以使用屏幕捕获工具程序保存生
17．写一个函数，满足以下规格说明。 
moveTo(shape, newCenter) shape 是一个支持getCenter 方法的图形对象，
newCenter 是一个点。移动形状，使newCenter 成为其中心。 
用你的函数编写一个绘制圆圈的程序，然后允许用户单击窗口10 次。每次用户点击时，
圆圈都会移动到用户点击的位置。
  利用Python 的if 语句来理解简单的判断编程模式及其实现。 
  利用Python 的if-else 语句来理解两路判断编程模式及其实现。 
  利用Python 的if-elif-else 语句来理解多路判断编程模式及其实现。 
  理解异常处理的思想，并能够编写简单异常处理代码，捕捉标准的Python 运行时错误。 
理解布尔表达式和布尔数据类型的概念。
能够阅读、编写和实现使用判断结构的算法，包括使用系列判断和嵌套判断结构
7.1  简单判断 
到目前为止，我们主要将计算机程序视为指令序列，一条接一条。序列是编程的一个
基本概念，但只用它不足以解决所有问题。常常有必要改变程序的顺序流程，以适应特定
情况的需要。这是通过特殊语句完成的，称为“控制结构”。在本章中，我们将学习“判断
结构”，它们是一些语句，允许程序针对不同情况执行不同指令序列，实际上允许程序“选
择”适当的动作过程。
7.1.1  示例：温度警告 
我们从让计算机做简单判断开始。作为一个简单的例子，我们回头看看第2 章中摄氏
温度转换为华氏温度的程序。回忆一下，这是Susan Computewell 写的，帮助她了解在欧洲
每天早晨该怎样穿衣服。下面是之前的程序：
第7 章  判断结构
就其本身而言，这是一个很好的程序，但我们希望增强它。Susan Computewell 不是喜
欢早起的人，即使有一个程序来转换温度，有时她也不太注意看结果。我们对程序的增强
会确保在温度极端时，打印出适当的警告，这样Susan 就会注意到。 
第一步是给出完整的增强规格说明。极端温度是指相当热或相当冷。假设任何超过90
华氏度的温度都应该发出热警告，而低于30 华氏度的温度则会发出冷警告。考虑到这个规
格说明，我们可以设计一个扩展的算法：
这个新设计在结束时有两个简单的“判断”。缩进表示只有满足上一行中列出的条件时
才应执行步骤。这里的意思是，判断引入了一个替代的控制流来通过程序。算法采取的确
切步骤取决于fahrenheit 的值。 
图7.1 是一张流程图，展示算法可能采取的路径。菱形框表示有条件的判断。 如果条
件为假，则控制传递到序列中的下一个语句（下面的语句）；如果条件成立，则控制权转移
到右侧框中的指令。这些指令完成后，控制会传递到下一个语句。
下面是新设计转换为Python 代码的样子： 
    print("It’s really hot out there. Be careful!") 
你可以看到Python 的if 语句用于实现判断。if 的形式非常类似于算法中的伪代码。 
body 只是在if 头部下缩进的一个或多个语句的序列。在convert2.py 中有两个if 语句，
两者在body 中都有一个语句。 
通过上面的例子，if 的语义应该清楚了。首先，对头部中的条件求值。如果条件为
真，则执行body 中的语句序列，然后控制传递到程序中的下一条语句；如果条件为假，
则跳过body 中的语句。图7.2 用流程图展示了if 的语义。注意，if 的body 是否执行取
决于条件。不论哪种情况，控制随后会传递到if 后的下一个语句。这是“一路”判断或
7.1  简单判断 
图7.1  带有警告的温度转换程序流程图
图7.2  简单if 语句的控制流 
7.1.2  形成简单条件 
有一点还没讨论：条件是怎样的？暂时，我们的程序将使用简单条件，它比较两个表
达式的值：<expr> <relop> <expr>。这里<relop>是“关系运算符”的缩写。这只是“小于”
或“等于”这类数学概念的特别名称。Python 中有六个关系运算符，如表7.1 所列。 
Python 中的关系运算符 
特别要注意用“==”表示相等。由于Python 使用“=”符号来表示赋值语句，因此对
于相等概念，需要使用不同的符号。Python 程序中常见的错误是在条件中使用“=”，而实
际需要使用的是“==”。 
条件可以比较数字或字符串。比较字符串时，排序是按“字典序”。基本上，这意味着
根据底层的Unicode 值以字母顺序放置字符串。因此，所有大写拉丁字母都在小写字母之前
（例如，“Bbbb”在“aaaa”之前，因为“B”在“a”之前）。 
我应该提到，条件实际上是一种表达式，称为布尔表达式，为纪念乔治·布尔，一位
第7 章  判断结构
19 世纪英国数学家。对一个布尔表达式求值，会产生值true（条件成立）或false（不成立）。
某些语言（如C ++和旧版本的Python）就用整数1 和0 来表示这些值。其他语言（如Java
和现代Python）有布尔表达式的专用数据类型。 
在Python 中，布尔表达式类型为bool，布尔值true 和false 由字面量True 和False 表示。
下面是一些交互示例：
7.1.3  示例：条件程序执行 
在第1 章，我提到过有几种不同的方式来运行Python 程序。一些Python 模块文件被设
计为直接运行。这些通常被称为“程序”或“脚本”。其他Python 模块主要设计为让其他程
序导入和使用，这些通常被称为“库”。有时我们希望创建一种混合模块，它既可以作为独
立程序使用，也可以作为可以由其他程序导入的库使用。
到目前为止，我们的大多数程序在底部有一行来调用main 函数。 
如你所知，这实际上启动了程序的运行。这些程序适合直接运行。在窗口环境中，
你可以通过点击（或双击）图标来运行该文件。或者键入类似python <myfile> .py 这样的
由于Python 在导入过程中对模块中的行求值，所以当前的程序在导入到交互式Python
会话或另一个Python 程序时也会运行。一般来说，不要让模块在导入时运行。以交互方式
测试程序时，通常的方法是首先导入模块，然后在每次运行它时调用它的main（或一些其
如果程序设计为既可以导入（不运行）又可以直接运行，则对底部的main 的调用必须
是有条件的。一个简单的判断应该就能搞定：
我们只需要找到合适的条件。
无论何时导入模块，Python 都会在该模块内部创建一个特殊的变量__name__，并为其
分配一个表示模块名称的字符串。下面是一个示例交互，显示math 库的情况： 
你可以看到，在导入后，math 模块中的__name__变量赋为字符串'math'。 
但是，如果直接运行Python 代码（不导入），Python 会将__name__的值设置为'__main__'。
7.2  两路判断 
要看到这个效果，只需要启动一个Python shell 并查看该值。 
’_ _main_ _’  
因此，如果模块被导入，那个模块中的代码将看到一个名为__name__的变量，其值是
模块的名称。如果文件直接运行，代码将看到该名称的值为'__main__'。模块可以通过检查
此变量来确定如何使用它。
综上所述，我们可以改变程序的最后一行，像这样：
if _ _name_ _ == ’_ _main_ _’:  
这保证在直接调用程序时自动运行main，但如果导入模块，就不会运行。几乎在每个
Python 程序的底部，都会看到类似这样的一行代码。 
7.2  两路判断 
既然我们利用判断，有办法在程序中选择性地执行某些语句，就可以回头看看第3 章
的二次方程求解程序。下面是之前的程序：
如注释中所述，如果给出没有实根的二次方程的系数时，该程序会崩溃。这段代码的
问题是当b2 − 4ac 小于0 时，程序试图取负数的平方根。由于负数没有实根，所以math 库
报告错误。下面有一个例子：
第7 章  判断结构
可以用一个判断来检查这种情况，并确保程序不会崩溃。下面是第一次尝试：
这个版本首先计算判别式（b2 − 4ac）的值，再检查并确保它不是负数。然后程序继续
取平方根并计算解。如果discrim 为负数，该程序永远不会尝试调用math.sqrt。 
不幸的是，这个更新版本并不是一个完整的解决方案。你看到当方程没有实根时会发
生什么？根据简单if 的语义，当b * b - 4 * a * c 小于零时，程序将简单地跳过计算并转到下
一条语句。由于没有下一条语句，程序就会退出。下面是交互式会话的示例：
这几乎比以前的版本更差，因为它不给用户任何迹象表明什么错误，只是让程序中止。
更好的程序将打印一条消息，告诉用户他们指定的方程没有实数解。我们可以通过在程序
结束时添加另一个简单的判断来实现这一点。
这当然会解决我们的问题，但这个解决方案感觉不对。我们已经编写了两个判断的序
列，但两个结果是互斥的。如果discrim> = 0 为真，则discrim <0 肯定为假，反之亦然。程
序中有两个条件，但实际上只有一个判断。根据discrim 的值，程序应该打印没有实数根，
或者应该计算并显示根。这是一个两路判断的例子。图7.3 说明了情况。 
在Python 中，可以通过在if 子句后加上else 子句来实现两路判断。结果称为if-else 语句。 
7.2  两路判断 
图7.3  二次方程求解程序是一个两路判断 
当Python 解释器遇到这种结构时，它首先对条件求值。如果条件为真，则执行if 下的
语句；如果条件为假，则执行else 下的语句。在任何情况下，控制随后都转到if-else 之后
在二次方程求解程序中使用两路判断，得到了更优雅的解决方案：
这个程序很好地解决了问题。下面是两次运行新程序的示例会话：
第7 章  判断结构
7.3  多路判断 
最新版本的二次方程求解程序肯定改进很大，但它仍然有一些奇怪的地方。下面是另
这在技术上是正确的，给定的系数产生一个方程，有相等的根为−1。但是，输出可能
会使某些用户感到困惑。它看起来像程序错误地打印了两次相同的数字。也许该程序应该
给出更多信息，以避免混乱。
当discrim 为0 时，发生等根的情况。在这种情况下，discRoot 也为0，并且两个根的值为
−b。如果希望捕捉这种特殊情况，程序实际上需要一个三路判断。下面是设计的快速草稿： 
该算法的一种编码方法是用两个if-else 语句。if 或else 子句的主体可以包含任何合法的
Python 语句，包括其他if 或if-else 语句。将一个复合语句放入另一个复合语句称为“嵌套”。
下面是用嵌套来实现三路判断的代码片段：
仔细观察这段代码，会看到有三种可能的路径。代码序列由discrim 的值确定。该解决
方案的流程图如图7.4 所示。你可以看到顶层结构只是一个if-else。（将虚线框视为一个大
语句。）虚线框包含第二个if-else，嵌套在顶级判断的else 部分中。 
我们又有了一个有效的解决方案，但实现让人感觉不太好。我们用两个两路判断巧妙
地实现了一个三路判断。得到的代码不反映原始问题的真正三路判断。设想一下，如果我
们需要像这样做一个五路判断。
7.3  多路判断 
图7.4  使用嵌套if-else 的二次求解器的三路判断 
if-else 结构将嵌套四层，Python 代码会一直写到屏幕的右边。 
在Python 中编写多路判断还有另一种方法，它保留了嵌套结构的语义，但看起来更舒
服。这就是将一个else 和一个if 组合成一个称为elif 的子句（发音为“ell-if”）。 
这个格式用于分隔任意数量的互斥代码块。Python 将依次对每个条件求值，寻找第一
个为真的条件。如果找到真条件，就执行在该条件下缩进的语句，并且控制转到整个
if-elif-else 之后的下一语句。 
如果没有条件为真，则执行else 下的语句。else 子句是可选的，如果省略，则可能没有
缩进语句块被执行。
在我们的二次方程求解程序中，用if-elif-else 表示三路判断得到了一个完成得很好的程序： 
第7 章  判断结构
7.4  异常处理 
我们的二次方程求解程序使用判断结构，避免了对负数取平方根和运行时产生错误。
在许多程序中，这是一种常见的模式：使用判断来防止罕见但可能的错误。
在二次方程求解程序的例子中，我们在调用sqrt 函数之前检查了数据。有时函数本身
会检查可能的错误，并返回一个特殊的值来表示操作失败。例如，另一个平方根运算可能
返回负数（如−1）来表示错误。因为平方根函数应该总是返回非负根，所以该值可以作为
信号，表示已经发生了错误。程序将用判断检查操作的结果：
有时程序充满了检查特殊情况的判断，导致处理一般情况的主要算法似乎快要找不到
了。编程语言设计者提出了“异常处理”的机制，帮助解决这种设计问题。异常处理机制
让程序员可以编写一些代码，捕获和处理程序运行时出现的错误。具有异常处理的程序不
会显式地检查算法中的每个步骤是否成功，本质上它是说，“做这些步骤，如果任何问题出
现，以这种方式处理它。”
我们不打算在这里讨论Python 异常处理机制的所有细节，但我想给出一个具体的例子，
这样你可以看到异常处理的工作原理和使用它的程序。在Python 中，异常处理是通过类似
于判断的特殊控制结构完成的。我们从一个具体的例子开始，然后看看一般的方法。
下面是一个二次方程求解程序的版本，它使用Python 的异常机制来捕获math.sqrt 函数
7.4  异常处理 
注意，这基本上是二次方程求解程序的第一个版本，并在核心程序外面加上了
try...except。try 语句的一般形式为： 
当Python 遇到try 语句时，它尝试执行其中的语句。如果这些语句执行没有错误，控制
随后转到try ... except 后的下一个语句；如果在其中某处发生错误，Python 会查找具有匹配
错误类型的except 子句。如果找到合适的except，则执行处理程序代码。 
原来没有异常处理的程序产生以下错误：
这条错误消息的最后一行说明了产生错误的类型，即ValueError。程序的更新版本提供
了一个except 子句来捕获ValueError。下面是它执行的样子： 
没有崩溃，异常处理程序捕获错误，并打印一条消息，说明方程没有实数根。
有趣的是，我们的新程序还捕获用户输入无效值导致的错误。 让我们再次运行程序，
这次输入“x”作为第一个输入。下面是运行示例： 
看到这里发生了什么吗？Python 执行float("x")时，引发了一个ValueError，因为"x"不
能转换为浮点数。这导致程序退出try 并跳转到该错误的except 子句。当然，最后的消息在
这里看起来有点奇怪。下面是程序的最后一个版本，检查发生什么样的错误：
第7 章  判断结构
多个except 类似于elif。如果发生错误，Python 将依次尝试每个except，查找与错误类
型匹配的错误。在这个例子底部的空except，行为就像一个else，如果前面的except 错误类
型都不匹配，它将作为默认行为。如果底部没有默认值，并且没有任何except 类型匹配错
误，程序将崩溃，Python 会报告错误。 
请注意我是如何处理两种不同ValueErrors 的。异常实际上是一种对象。如果在except
子句中，在错误类型后跟上as <variable>，Python 会将该变量赋值为实际的异常对象。在这
个例子中，我将异常转换成一个字符串，检查该消息，看看是什么导致了ValueError。请注
意，这段文本正是在未捕获错误时，Python 打印出来的内容（即ValueError: math domain 
error）。如果异常不是ValueError，这个程序只打印一般的道歉。作为挑战，你也许希望看
看是否能找到导致道歉的错误输入。
可以看到，try ... except 语句让我们可以编写防御式程序。同样利用这种技术，可以观
察Python 打印的错误消息，设计except 子句来捕获并处理它们。是否需要这么麻烦，取决
于你正在编写的程序类型。在刚开始编程时，你可能不太担心错误的输入。但专业品质的
软件应该采取所有可行的办法，防止用户得到意外的结果。
7.5  设计研究：三者最大 
既然判断可以改变程序的控制流，那么我们的算法就从单调的、逐步的、严格的顺序
处理中解放出来。这是福，也是祸。好的一面是，我们可以开发更复杂的算法，就像我们
对二次方程求解程序所做的那样。不好的是，设计这些更复杂的算法要困难得多。在本节
中，我们将介绍一个更困难的判断问题的设计，从而展示设计过程中的一些挑战和乐趣。
假设我们需要一个算法，找出三个数中最大的一个。这个算法可能是一个更大的问题
的一部分，例如确定等级或计算税额，但我们对最终的细节不感兴趣，只关心问题的关键。
也就是说，计算机如何确定用户的三个输入中哪一个最大？下面是简单的程序大纲：
7.5  设计研究：三者最大 
请注意，我用eval 来获取三个数，这是一种猛糙快的方式。当然，在产品代码中（让
其他用户使用的程序），通常应该避免eval。在这里问题不大，因为我们只关心开发和测试
现在我们只需要填充缺少的部分。在阅读下面的分析之前，你可能希望自己尝试解决
7.5.1  策略1：比较每个值和所有其他值 
显然，这个程序向我们提出了一个判断问题。我们需要一系列语句，将maxval 的值设
置为三个输入x1、x2 和x3 中的最大值。一眼看上去，这像是一个三路判断，我们需要执
行以下任务之一：
似乎我们只需要在每行前面加上适当的条件，让它只在正确的情况下执行。
让我们考虑第一种可能性：x1 是最大的。为了确定x1 确实是最大的，我们只需要检查
它至少与另外两个一样大。下面是第一次尝试：
你首先需要关注，这个语句的语法是否正确。条件x1> = x2> = x3 与上面显示的条件的
模板不匹配。大多数计算机语言不接受它作为一个有效的表达式。事实证明，Python 允许
这种复合条件，它的行为完全就像数学关系x1≥x2≥x3。也就是说，当x1 至少与x2 一样
大且x2 至少与x3 一样大时，条件为真。所以很幸运，Python 对这个条件没有问题。 
每次写判断时，你应该问自己两个重要的问题。首先，当条件为真时，你是否绝对确
定判断后执行语句是正确的操作？ 在这种情况下，条件清楚地表明x1 至少与x2 和x3 一
样大，因此将其值赋给maxval 应该是正确的。始终要特别注意边界值，注意我们的条件包
括等于和大于。我们应该说服自己这是正确的。假设x1、x2 和x3 都相同，这个条件将返
回true。这没关系，因为我们选择什么都不重要。第一个至少与其他一样大，因此最大。 
第二个问题与第一个问题相反。我们是否确定当x1 最大时，在所有情况下这个条件都
是真的？不幸的是，我们的结论不符合这个测试。假设值是5、2 和4。显然，x1 是最大的，
但条件返回false，因为关系5≥2≥4 不成立。我们需要修复这个问题。 
我们要确保x1 是最大的，但我们不关心x2 和x3 的相对顺序。我们真正需要的是两个
单独的测试，以确定x1> = x2 且x1> = x3。Python 允许我们测试这样的多个条件，只要用
and 关键字将它们组合起来。我们将在第8 章讨论and 的确切语义。直觉上，以下条件似乎
是我们要寻找的：
要完成该程序，我们只需要为其他可能性执行类似的测试：
第7 章  判断结构
总结一下，我们的算法基本上是检查每个可能的值和所有其他值，以确定它是否最大。 
只有三个值的结果相当简单，但如果我们试图找到五个值中最大的，这个解决方案怎
样？这样我们需要四个布尔表达式，每个由四个条件组成。复杂的表达式是由于每个判断
都是独立的，在后续测试中忽略了来自前面测试的信息。要明白我的意思，请回顾一下简
单的三者最大的代码。假设第一个判断发现x1 大于x2，但不大于x3。此时，我们知道x3
肯定是最大值。不幸的是，我们的代码忽略了这一点，Python 会继续对下一个表达式求值，
发现它是false，最后执行else。 
7.5.2  策略2：判断树 
要避免先前算法的冗余测试，一种方式是使用“判断树”的方法。假设我们从一个简
单的测试x1 >= x2 开始。这使得x1 或x2 中的一个退出最大值的竞争。如果条件为真，我
们只需要看看x1 和x3 哪个更大。如果初始条件为假，则结果归结为x2 和x3 之间的选择。
如你所见，第一个判断“分支”成两种可能性，每种又是另一个判断，因此称为“判断树”。
图7.5 用流程图展示了这种情况。这个流程图很容易转换成嵌套的if-else 语句。 
图7.5  三者最大问题的判断树方法的流程图 
这种方法的优势是效率。无论三个值的顺序如何，该算法都将进行两次比较，并将正
7.5  设计研究：三者最大 
确的值分配给maxval。然而，这种方法的结构比第一种更复杂，如果我们用三个以上的值
来尝试这个设计，会遭受类似的复杂性爆炸。作为一项挑战，你可能希望尝试能否设计一
个判断树，找到四个值中的最大值。（你需要if-elses 嵌套三层，导致八个赋值语句。） 
7.5.3  策略3：顺序处理 
到目前为止，我们设计了两种非常不同的算法，但没有一种看起来特别优雅。也许还
有第三种方式。设计算法时，一个好的起点是问自己，如果要求你做这项工作，你将如何
解决问题。要找到三个数中最大的，你可能对要采取
的步骤没有很好的直觉。只要看看数字，就知道哪个
是最大的。但是，如果交给你一本书，其中包含几百
个数字，又没有特定的顺序呢？你将如何找到这个集
合中最大的数字？
面对更大的问题时，大多数人会制定一个简单的
策略。扫描数字，直到找到一个大的，用手指指向它。
继续扫描，如果找到一个大于指向的数字，手指移动
到新的数字。到达列表的末尾时，手指将指向最大值。
简而言之，这个策略让我们按顺序浏览列表，记录到
目前为止最大的数字。
计算机没有手指，但我们可以使用变量来记录最大
值。事实上，最简单的方法是用maxval 来完成这项工
作。这样，到了最后，maxval 将自动包含列表中的最大
值。描述三者最大问题策略的流程图如图7.6 所示。 
下面是对应的Python 代码： 
显然，顺序方法是三种算法中最好的。代码本身很简单，只包含两个简单的判断，并
且顺序处理比以前算法中使用的嵌套更容易理解。此外，这个思路能很好地扩展到更大的
问题。例如，添加第四项只需要一个语句：
最后一个解决方案可以扩展到更大的问题，这不奇怪，我们通过明确考虑如何解决更
复杂的问题而发明了该算法。事实上，你可以看到代码是非常重复的。我们可以轻松地编
写一个程序，允许用户将我们的算法折叠成一个循环，找到n 个数字中最大的。不必使用
图7.6  三者最大问题的顺序方法的流程图 
第7 章  判断结构
x1、x2、x3 等单独的变量，我们可以每次取得一个值，并不断重复使用单个变量x。每次
比较最新的x 和maxval 的当前值，看它是否更大。 
这段代码利用嵌套在循环中的判断来完成工作。在循环的每次迭代中，maxval 包含到
目前为止看到的最大值。
7.5.4  策略4：使用Python 
在结束这个问题之前，我确实应该指出，这些努力追求的算法开发都没有必要。Python
实际上有一个内置的函数max，它返回最大的参数。下面是我们程序的最简单版本： 
当然，这个版本不需要开发任何算法，这让练习的意图彻底失败了！有时候Python 太
容易让我们舒服了。
7.5.5  一些经验 
三者最大问题不是什么惊天动地的问题，但解决这个问题的尝试展示了算法和程序设
计中的一些重要思想。
  存在多种方法实现方式。任何有价值的计算问题，都有多种解决方法。虽然这可
能看起来很明显，但许多新程序员没有真正把这一点放在心上。这对你意味着什
么？不要急于编写进入脑海的第一个想法。想想你的设计，问自己是否存在更好
的方法来处理这个问题。写下代码后，再问自己是否可能有更好的方法。你的第
一个任务是找到一个正确的算法。之后，力求清晰、简单、高效、可扩展和优雅。
好的算法和程序就像逻辑的诗，阅读和维护它们让人赏心悦目。
  变成计算机。特别是对于新程序员来说，制定算法的最好方法之一是简单地问自
己如何解决问题。虽然存在其他一些用于设计良好算法的技术（见第13 章），但
是直接的方法通常简单、清楚、有效。
  通用性好。我们通过考虑更通用的n 个数的最大值问题，得到三者最大问题的最
佳解决方案。考虑更通用的问题可以导致对于某些特殊情况的更好的解决方案，
这很常见。不要害怕后退一步去思考总体的问题。同样，在设计程序时，应始
终注意使程序更有用。如果n 者最大的程序和三者最大一样容易，你可以写出
更通用的程序，因为它更有可能在其他情况下有用。这样从编程工作中获得的
  不要重新发明轮子。我们的第四个解决方案是使用Python 的max 函数。你可能认
为这是作弊，但这个例子说明了一个重要问题。很多非常聪明的程序员已经设计
了无数的好算法和程序。如果你希望解决的问题似乎是许多其他人肯定会遇到的
问题，你可以开始先弄清楚问题是否已经被解决了。由于你正在学习编程，从头
开始设计是很好的经验。然而，真正的专家程序员知道什么时候借用。
本章阐述了做出判断的基本控制结构。下面是要点。
判断结构是允许程序针对不同情况执行不同指令序列的控制结构。
  判断在Python 中用if 语句实现。简单的判断是用一个简单的if 来实现的。两路判
断通常使用if-else。多路判断用if-elif-else 实现。 
  判断基于条件的求值，条件是简单的布尔表达式。布尔表达式结果为true 或false。
Python 有专门的bool 数据类型，其字面量为True 和False。条件的构成利用了关
系运算符<、<=、！=、==、>和>=。 
  一些编程语言提供了异常处理机制，让程序更具“防御性”。Python 提供了用于异
常处理的try-except 语句。 
结合判断的算法可能变得相当复杂，因为判断结构是嵌套的。通常有许多解决方
案是可能的，应仔细考虑，得到正确、有效和可理解的程序。
1．一个简单的判断可以用一个if 语句来实现。 
2．在Python 条件中，“=”被写成“/=”。 
3．字符串利用字典顺序进行比较。 
4．用if-elif 语句实现两路判断。 
第7 章  判断结构
5．math.sqrt 函数无法计算负数的平方根。 
6．单个try 语句可以捕获多种错误。 
7．多路判断必须通过嵌套多个if-else 语句来处理。 
8．对于涉及判断结构的问题，通常只有一个正确的解决方案。 
9．在Python 中允许条件x <= y <= z。 
10．输入验证意味着在需要输入时提示用户。 
1．控制其他语句的执行的语句称为
2．在Python 中实现多路判断的最佳结构是
b．if-else  
c．if-elif-else 
3．求值为true 或false 的表达式称为
4．当程序直接运行（未导入）时，__name__的值为
a．script  
c．__main__ 
5．bool 类型的字面量是        。 
b．True,False  
c．true,false  
6．在另一个判断内部做出判断是
7．在Python 中，判断的body 表示为
8．一个判断导致另一组判断，这些判断又导致另一组判断，依此下去，这样的结构称
为判断        。
9．用math.sqrt 取负值的平方根产生
a．ValueError  
10．多项选择问题最类似于        。 
d．异常处理程序 
1．用你自己的话解释以下模式。 
2．用try/except 处理异常与用普通判断结构（if 的变体）处理异常有什么异同？ 
3．下面是一个（愚蠢的）判断结构： 
a, b, c = eval(input(’Enter three numbers: ’)) 
print("It’s a late parrot!") 
显示以下每种可能输入产生的输出：
a．3, 4, 5 
b．3, 3, 3 
c．5, 4, 3 
d．3, 5, 2 
e．5, 4, 7 
f．3, 3, 2 
1．许多公司对每周超出40 小时以上的工作时间支付150%的工资。编写程序输入工作
小时数和小时工资，并计算一周的总工资。
2．某位CS 教授给出了5 分的小测验，评分等级为5-A，4-B，3-C，2-D，1-E，0-F。
编写一个程序，接受测验得分作为输入，并使用判断结构来计算相应的等级。
3．某位CS 教授给出了100 分的考试，分级为90～100：A，80～89：B，70～79：C，
60～69：D，<60：F。编写一个程序，将考试分数作为输入，并使用判断结构来计算相应的
4．某所大学根据学生拿到的学分对学生分年级。小于7 学分的学生是大一新生。至少
有7 个学分才是大二，16 分以上是大三，26 分以上是大四。编写一个程序，根据获得的学
5．身体质量指数（BMI）的计算公式是人的体重（以磅计）乘以720，再除以人的身
高（以英寸计）的平方。BMI 在19～25 范围内（包括边界值）被认为是健康的。编写一个
程序，计算人的BMI，并打印一条消息，告诉他们是在健康范围之上、之中还是之下。 
6．Podunksville 的超速罚单政策是50 美元加上超速部分每mph（一英里每小时）5 美
元，如果超过90mph 再追加罚款200 美元。编写一个程序，接受速度限制和计时速度，并
打印一条消息，表明速度合法，或者在速度非法时，打印罚款。
7．一个保姆每小时收费2.50 美元直到晚上9:00，然后一小时降到1.75 美元（孩子们
在床上）。编写一个程序，接受以小时和分钟为单位的开始时间和结束时间，并计算总的保
姆账单。可以假设开始和结束时间在一个24 小时内。不足1 小时的应该适当地按比例分配。 
第7 章  判断结构
8．如果一个人至少30 岁，并且成为美国公民至少9 年，就有资格成为美国参议员。
作为美国众议员，年限分别是25 岁和7 年。编写一个程序，接受一个人的年龄和公民年数
作为输入，并输出他的参议院和众议院资格。
9．计算1982～2048 年的复活节的计算公式如下：令a = year%19, b = year%4, c = year%7, 
d = (19a + 24)%30, e = (2b +4c +6d + 5)%7。复活节的日期是3 月22 日+ d + e（可能在4 月）。
写一个程序，输入年份，验证它在适当的范围，然后打印出那一年复活节的日期。
10．除1954 年、1981 年、2049 年和2076 年以外，上一个问题中复活节的公式适用于
1900～2099 年。对于这四年，它产生的日期晚了一个星期。修改上述程序，让它适用于1900～
2099 的所有年份。 
11．某年是闰年，如果它可以被4 整除，除非它是世纪年份但不能被400 整除（1800
和1900 不是闰年，而1600 和2000 是。）编写一个程序，计算某年是否为闰年。 
12．编写一个程序，以月/日/年的形式接受日期，并输出日期是否有效。例如5/24/1962
是有效的，但9/31/2000 不是。（9 月只有30 天。） 
13．一年中的第几天通常从1～365（或366）。这个数字可以用整数算术，利用三个步
（a）dayNum = 31(month − 1) + day。
（b）如果月份是在二月份之后减去（4（month）+ 23）// 10。
（c）如果是闰年并在2 月29 日之后，加1。
编写一个程序，以月/日/年的形式接受一个日期，验证它是一个有效的日期（见上一个
问题），然后计算相应的天数。
14．做第4 章的编程练习7，但添加一个判断来处理直线不与圆相交的情况。 
15．做第4 章的编程练习8，但添加一个判断，以防止程序除以零，如果线是垂直的。 
16．射箭计分程序。编写一个绘制箭靶的程序（参见第4 章的程序练习2），并允许用
户点击五次以表示在目标处射击的箭头。采用五级评分，靶心（黄色）得9 分，后续每个
环减2 分，直到白色为1 分。该程序应输出每次点击的分数，并记录整个过程的动态总分。 
17．编写一个程序，用动画显示在窗口中弹跳的圆。基本思想是在窗口内部的某处启
动圆。用变量dx 和dy（都初始化为1）来控制圆的运动。采用大计数循环（例如10000
次迭代），每次循环利用dx 和dy 移动圆。当圆心的x 值过高（碰到边缘）时，将dx 更改
为−1。当它变得太低时，将dx 更改为1。对dy 使用类似的方法。 
注意：你的动画可能会运行得太快。你可以通过使用图形库的更新速率参数来减慢速
度。例如，下面的循环将被限制，以每秒30 次的速率执行： 
18．从上一章找一个最喜欢的编程问题，并根据需要添加判断和/或异常处理，让它真
正健壮（不会因任何输入而崩溃）。与朋友交流你的程序，比赛看看谁可以“攻破”对方的
  理解确定和不定循环的概念，以及它们用Python 的for 和while 语句的实现。 
  理解交互式循环和哨兵循环的编程模式，以及它们用Python 的while 语句的实现。 
  理解文件结束循环的编程模式，以及在Python 中实现这种循环的方法。 
能为涉及循环模式（包括嵌套循环结构）的问题设计和实现解决方案。
理解布尔代数的基本思想，并能分析和编写涉及布尔运算符的布尔表达式。
8.1  for 循环：快速回顾 
在第7 章，我们详细介绍了Python 的if 语句，以及它在实现一些编程模式时的应用，
如单路、两路和多路的判断。本章将详细介绍循环和布尔表达式，圆满完成我们的控制结
你已知道Python 的for 语句提供了一种循环。它允许我们遍历一系列值。 
循环索引变量var 依次取序列中的每个值，循环体中的语句针对每个值执行一次。 
假设我们要编写一个程序，计算用户输入的一系列数字的平均值。为了让程序通用，
它应该适用于任意大小的数字。你知道平均值是通过对数字求和并除以数字的个数来计算
的。我们不需要记录所有输入的数字,只需要一个不断增长的总和，以便最后计算平均值。 
这个问题描述应该会触发你的一些灵感。它让你希望用以前看过的一些设计模式。我
们正在处理一系列数字：它们将由某种形式的循环来处理。如果有n 个数字，循环应该执
行n 次，我们可以用计数的循环模式。我们还需要一个不断增长的总和，这需要一个循环
累积器。将两个想法结合在一起，我们可以为这个问题生成一个设计：
希望你看到集成在这个设计中的计数循环和累积器模式。我们几乎可以将该设计直接
转化为Python 实现： 