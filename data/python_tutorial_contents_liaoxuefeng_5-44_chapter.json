[
  {
    "url": "https://liaoxuefeng.com/books/python/advanced/index.html",
    "title": "高级特性",
    "content": "掌握了Python的数据类型、语句和函数，基本上就可以编写出很多有用的程序了。\n比如构造一个1, 3, 5, 7, ..., 99的列表，可以通过循环实现：\n取list的前一半的元素，也可以通过循环实现。\n但是在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。\n基于这一思想，我们来介绍Python中非常有用的高级特性，1行代码能实现的功能，决不写5行代码。请始终牢记，代码越少，开发效率越高。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/basic/index.html",
    "title": "Python基础",
    "content": "Python是一种计算机编程语言。计算机编程语言和我们日常使用的自然语言有所不同，最大的区别就是，自然语言在不同的语境下有不同的理解，而计算机要根据编程语言执行任务，就必须保证编程语言写出的程序决不能有歧义，所以，任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码，然后执行。Python也不例外。\nPython的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：\n以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。\n缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的惯例，应该始终坚持使用4个空格的缩进。\n缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。\n缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。\n最后，请务必注意，Python程序是大小写敏感的，如果写错了大小写，程序会报错。\nPython使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进；\n在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/basic/match/index.html",
    "title": "模式匹配",
    "content": "当我们用if ... elif ... elif ... else ...判断时，会写很长一串代码，可读性较差。\n如果要针对某个变量匹配若干种情况，可以使用match语句。\n例如，某个学生的成绩只能是A、B、C，用if语句编写如下：\n如果用match语句改写，则改写如下：\n使用match语句时，我们依次用case xxx匹配，并且可以在最后（且仅能在最后）加一个case _表示“任意值”，代码较if ... elif ... else ...更易读。\nmatch语句除了可以匹配简单的单个值外，还可以匹配多个值、匹配一定范围，并且把匹配后的值绑定到变量：\n在上面这个示例中，第一个case x if x < 10表示当age < 10成立时匹配，且赋值给变量x，第二个case 10仅匹配单个值，第三个case 11|12|...|18能匹配多个值，用|分隔。\n可见，match语句的case匹配非常灵活。\nmatch语句还可以匹配列表，功能非常强大。\n我们假设用户输入了一个命令，用args = ['gcc', 'hello.c']存储，下面的代码演示了如何用match匹配来解析这个列表：\n第一个case ['gcc']表示列表仅有'gcc'一个字符串，没有指定文件名，报错；\n第二个case ['gcc', file1, *files]表示列表第一个字符串是'gcc'，第二个字符串绑定到变量file1，后面的任意个字符串绑定到*files（符号*的作用将在函数的参数中讲解），它实际上表示至少指定一个文件；\n第三个case ['clean']表示列表仅有'clean'一个字符串；\n最后一个case _表示其他所有情况。\n可见，match语句的匹配规则非常灵活，可以写出非常简洁的代码。\ndo_match.py"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/first-program/text-editor/index.html",
    "title": "使用文本编辑器",
    "content": "在Python的交互式命令行写程序，好处是一下就能得到结果，坏处是没法保存，下次还想运行的时候，还得再敲一遍。\n所以，实际开发的时候，我们总是使用一个文本编辑器来写代码，写完了，保存为一个文件，这样，程序就可以反复运行了。\n现在，我们就把上次的'hello, world'程序用文本编辑器写出来，保存下来。\n那么问题来了：文本编辑器到底哪家强？\n我们推荐微软出品的Visual Studio Code，它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨平台！Windows、Mac和Linux通用。\n请注意，不要用Word和Windows自带的记事本。Word保存的不是纯文本文件，而记事本会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果会导致程序运行出现莫名其妙的错误。\n安装好文本编辑器后，输入以下代码：\n注意print前面不要有任何空格。然后，选择一个目录，例如C:\\work，把文件保存为hello.py，就可以打开命令行窗口，把当前目录切换到hello.py所在目录，就可以运行这个程序了：\n也可以保存为别的名字，比如first.py，但是必须要以.py结尾，其他的都不行。此外，文件名只能是英文字母、数字和下划线的组合。\n如果当前目录下没有hello.py这个文件，运行python hello.py就会报错：\n报错的意思就是，无法打开hello.py这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。如果hello.py存放在另外一个目录下，要首先用cd命令切换当前目录。\n有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：\n然后，通过命令给hello.py以执行权限：\n就可以直接运行hello.py了，比如在Mac下运行：\nhello.py\n用文本编辑器写Python程序，然后保存为后缀为.py的文件，就可以用Python直接运行这个程序了。\nPython的交互模式和直接运行.py文件有什么区别呢？\n直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。\n直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。\n用Python开发程序，完全可以一边在文本编辑器里写代码，一边开一个交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27'的超大显示器！"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/first-program/input-output/index.html",
    "title": "输入和输出",
    "content": "用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出'hello, world'，用代码实现如下：\nprint()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：\nprint()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：\nprint()也可以打印整数，或者计算结果：\n因此，我们可以把计算100 + 200的结果打印得更漂亮一点：\n注意，对于100 + 200，Python解释器自动计算出结果300，但是，'100 + 200 ='是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。\n现在，你已经可以用print()输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：\n当你输入name = input()并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。\n输入完成后，不会有任何提示，Python交互式命令行又回到>>>状态了。那我们刚才输入的内容到哪去了？答案是存放到name变量里了。可以直接输入name查看变量内容：\n**什么是变量？**请回忆初中数学所学的代数基础知识：\n设正方形的边长为a，则正方形的面积为a x a。把边长a看做一个变量，我们就可以根据a的值计算正方形的面积，比如：\n若a=2，则面积为a x a = 2 x 2 = 4；\n若a=3.5，则面积为a x a = 3.5 x 3.5 = 12.25。\n在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，name作为一个变量就是一个字符串。\n要打印出name变量的内容，除了直接写name然后按回车外，还可以用print()函数：\n有了输入和输出，我们就可以把上次打印'hello, world'的程序改成有点意义的程序了：\n运行上面的程序，第一行代码会让用户输入任意字符作为自己的名字，然后存入name变量中；第二行代码会根据用户的名字向用户说hello，比如输入Michael：\n但是程序运行的时候，没有任何提示信息告诉用户：“嘿，赶紧输入你的名字”，这样显得很不友好。幸好，input()可以让你显示一个字符串来提示用户，于是我们把代码改成：\n再次运行这个程序，你会发现，程序一运行，会首先打印出please enter your name: ，这样，用户就可以根据提示，输入名字后，得到hello, xxx的输出：\n每次运行该程序，根据用户输入的不同，输出结果也会不同。\n在命令行下，输入和输出就是这么简单。\n任何计算机程序都是为了执行一个特定的任务，有了输入，用户才能告诉计算机程序所需的信息，有了输出，程序运行后才能告诉用户任务的结果。\n输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。\ninput()和print()是在命令行下面最基本的输入和输出，但是，用户也可以通过其他更高级的图形界面完成输入和输出，比如，在网页上的一个文本框输入自己的名字，点击“确定”后在网页上看到输出信息。\n请利用print()输出1024 * 768 = xxx：\ndo_input.py"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/basic/loop/index.html",
    "title": "循环",
    "content": "要计算1+2+3，我们可以直接写表达式：\n要计算1+2+3+...+10，勉强也能写出来。\n但是，要计算1+2+3+...+10000，直接写表达式就不可能了。\n为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。\nPython的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：\n执行这段代码，会依次打印names的每一个元素：\n所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。\n再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：\n如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：\nrange(101)就可以生成0-100的整数序列，计算如下：\n请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。\n第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：\n在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。\n请利用循环依次对list中的每个名字打印出Hello, xxx!：\n在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字：\n上面的代码可以打印出1~100。\n如果要提前结束循环，可以用break语句：\n执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。\n可见break的作用是提前结束循环。\n在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。\n上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环：\n执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。\n可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。\ndo_for.py\ndo_while.py\n循环是让计算机做重复任务的有效的方法。\nbreak语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。\n要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。\n有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。\n请试写一个死循环程序。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/function/index.html",
    "title": "函数",
    "content": "我们知道圆的面积计算公式为：\n当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：\n当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。\n有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。\n基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。\n抽象是数学中非常常见的概念。举个例子：\n计算数列的和，比如：1 + 2 + 3 + ... + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + ... + 100记作：\n这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。\n而且，这种抽象记法是可扩展的，比如：\n还原成加法运算就变成了：\n(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)\n可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。\n写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/basic/if/index.html",
    "title": "条件判断",
    "content": "计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。\n比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：\n根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。\n也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：\n注意不要少写了冒号:。\n当然上面的判断是很粗略的，完全可以用elif做更细致的判断：\nelif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：\nif语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager：\nif判断条件还可以简写，比如写：\n只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。\n最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：\n输入1982，结果报错：\n这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：\n再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：\n原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。\n如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。\n小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：\n用if-elif判断并打印结果：\ndo_if.py\n条件判断可以让计算机自己做选择，Python的if...elif...else很灵活。\n条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的elif和else都不再执行。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/basic/dict-set/index.html",
    "title": "使用dict和set",
    "content": "Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：\n给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。\n如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：\n为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。\n第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。\ndict就是第二种实现方式，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。\n你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。\n把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\n如果key不存在，dict就会报错：\n要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：\n二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：\n注意：返回None的时候Python的交互环境不显示结果。\n要删除一个key，用pop(key)方法，对应的value也会从dict中删除：\n请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\n和list比较，dict有以下几个特点：\n而list相反：\n所以，dict是用空间来换取时间的一种方法。\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：\nset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n要创建一个set，用{x,y,z,...}列出每个元素：\n或者提供一个list作为输入集合：\n注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。\n重复元素在set中自动被过滤：\n通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：\n通过remove(key)方法可以删除元素：\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\nset和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n上面我们讲了，str是不变对象，而list是可变对象。\n对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：\n而对于不可变对象，比如str，对str进行操作呢：\n虽然字符串有个replace()方法，也确实变出了'Abc'，但变量a最后仍是'abc'，应该怎么理解呢？\n我们先把代码改成下面这样：\n要始终牢记的是，a是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'：\n当我们调用a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了：\n所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。\nthe_dict.py\nthe_set.py\n使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。\ntuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/basic/list-tuple/index.html",
    "title": "使用list和tuple",
    "content": "Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。\n比如，列出班里所有同学的名字，就可以用一个list表示：\n变量classmates就是一个list。用len()函数可以获得list元素的个数：\n用索引来访问list中每一个位置的元素，记得索引是从0开始的：\n当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。\n如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：\n以此类推，可以获取倒数第2个、倒数第3个：\n当然，倒数第4个就越界了。\nlist是一个可变的有序表，所以，可以往list中追加元素到末尾：\n也可以把元素插入到指定的位置，比如索引号为1的位置：\n要删除list末尾的元素，用pop()方法：\n要删除指定位置的元素，用pop(i)方法，其中i是索引位置：\n要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：\nlist里面的元素的数据类型也可以不同，比如：\nlist元素也可以是另一个list，比如：\n要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：\n要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0：\n另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：\n现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。\n不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\ntuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：\n如果要定义一个空的tuple，可以写成()：\n但是，要定义一个只有1个元素的tuple，如果你这么定义：\n定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。\n所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：\nPython在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。\n最后来看一个“可变的”tuple：\n这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？\n别急，我们先看看定义的时候tuple包含的3个元素：\n当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：\n表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！\n理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。\n请用索引取出下面list的指定元素：\n请问以下变量哪些是tuple类型：\nthe_list.py\nthe_tuple.py\nlist和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/function/define-function/index.html",
    "title": "定义函数",
    "content": "在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\n我们以自定义一个求绝对值的my_abs函数为例：\n请自行测试并调用my_abs看看返回结果是否正确。\n请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。\n如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。\n在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次回车重新回到>>>提示符下：\n如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：\nimport的用法在后续模块一节中会详细介绍。\n如果想定义一个什么事也不做的空函数，可以用pass语句：\npass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。\npass还可以用在其他语句里，比如：\n缺少了pass，代码运行就会有语法错误。\n调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：\n但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：\n当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。\n让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：\n添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：\n错误和异常处理将在后续讲到。\n函数可以返回多个值吗？答案是肯定的。\n比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：\nimport math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。\n然后，我们就可以同时获得返回值：\n但其实这只是一种假象，Python函数返回的仍然是单一值：\n原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n请定义一个函数quadratic(a, b, c)，接收3个参数，返回一元二次方程 ax2+bx+c=0ax^2+bx+c=0ax2+bx+c=0 的两个解。\n提示：\n一元二次方程的求根公式为：\n计算平方根可以调用math.sqrt()函数：\ndef_func.py\n定义函数时，需要确定函数名和参数个数；\n如果有必要，可以先对参数的数据类型做检查；\n函数体内部可以用return随时返回函数结果；\n函数执行完毕也没有return语句时，自动return None。\n函数可以同时返回多个值，但其实就是一个tuple。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/function/recursive-function/index.html",
    "title": "递归函数",
    "content": "在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：\n所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。\n于是，fact(n)用递归的方式写出来就是：\n上面就是一个递归函数。可以试试：\n如果我们计算fact(5)，可以根据函数定义看到计算过程如下：\n递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。\n使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：\n解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。\n尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\n上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：\n可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。\nfact(5)对应的fact_iter(5, 1)的调用如下：\n尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。\n遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。\n汉诺塔的移动可以用递归函数非常简单地实现。\n请编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法，例如：\nrecur.py\n使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。\n针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。\nPython标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/function/call-function/index.html",
    "title": "调用函数",
    "content": "Python内置了很多有用的函数，我们可以直接调用。\n要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档，也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。\n调用abs函数：\n调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：\n如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：\n而max函数max()可以接收任意多个参数，并返回最大的那个：\nPython内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：\n请利用Python内置的hex()函数把一个整数转换成十六进制表示的字符串：\ncall_func.py\n调用Python的函数，需要根据函数定义，传入正确的参数。如果函数调用出错，一定要学会看错误信息，所以英文很重要！"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/basic/data-types/index.html",
    "title": "数据类型和变量",
    "content": "计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：\nPython可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。\n计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。\n对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。十六进制数也可以写成0xa1b2_c3d4。\n浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。\n整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。\n字符串是以单引号'或双引号\"括起来的任意文本，比如'abc'，\"xyz\"等等。请注意，''或\"\"本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用\"\"括起来，比如\"I'm OK\"包含的字符是I，'，m，空格，O，K这6个字符。\n如果字符串内部既包含'又包含\"怎么办？可以用转义字符\\来标识，比如：\n表示的字符串内容是：\n转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\，可以在Python的交互式命令行用print()打印字符串看看：\n如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r''表示''内部的字符串默认不转义，可以自己试试：\n如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容，可以自己试试：\n上面是在交互式命令行内输入，注意在输入多行内容时，提示符由>>>变为...，提示你可以接着上一行输入，注意...是提示符，不是代码的一部分：\n当输入完结束符```和括号)后，执行该语句并打印结果。\n如果写成程序并存为.py文件，就是：\n多行字符串'''...'''还可以在前面加上r使用，请自行测试：\n布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：\n布尔值可以用and、or和not运算。\nand运算是与运算，只有所有都为True，and运算结果才是True：\nor运算是或运算，只要其中有一个为True，or运算结果就是True：\nnot运算是非运算，它是一个单目运算符，把True变成False，False变成True：\n布尔值经常用在条件判断中，比如：\n空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。\n此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。\n变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。\n变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：\n变量a是一个整数。\n变量t_007是一个字符串。\n变量Answer是一个布尔值True。\n在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：\n这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：\n和静态语言相比，动态语言更灵活，就是这个原因。\n请不要把赋值语句的等号等同于数学的等号。比如下面的代码：\n如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。\n最后，理解变量在计算机内存中的表示也非常重要。当我们写：\n时，Python解释器干了两件事情：\n也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：\n最后一行打印出变量b的内容到底是'ABC'呢还是'XYZ'？如果从数学意义上理解，就会错误地得出b和a相同，也应该是'XYZ'，但实际上b的值是'ABC'，让我们一行一行地执行代码，就可以看到到底发生了什么事：\n执行a = 'ABC'，解释器创建了字符串'ABC'和变量a，并把a指向'ABC'：\n执行b = a，解释器创建了变量b，并把b指向a指向的字符串'ABC'：\n执行a = 'XYZ'，解释器创建了字符串'XYZ'，并把a的指向改为'XYZ'，但b并没有更改：\n所以，最后打印变量b的结果自然是'ABC'了。\n所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：\n但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。\n最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：\n/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：\n还有一种除法是//，称为地板除，两个整数的除法仍然是整数：\n你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。\n因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：\n无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。\n请打印出以下变量的值：\nPython支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。\n对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。\n注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。\nPython的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/basic/string-encoding/index.html",
    "title": "字符串和编码",
    "content": "我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。\n因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。\n由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。\n但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。\n你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。\n因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。\nUnicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。\n现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。\n字母A用ASCII编码是十进制的65，二进制的01000001；\n字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；\n汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。\n你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。\n新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：\n从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。\n搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：\n在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。\n用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：\n浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：\n所以你看到很多网页的源码上会有类似<meta charset=\"UTF-8\" />的信息，表示该网页正是用的UTF-8编码。\n搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。\n在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：\n对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：\n如果知道字符的整数编码，还可以用十六进制这么写str：\n两种写法完全是等价的。\n由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。\nPython对bytes类型的数据用带b前缀的单引号或双引号表示：\n要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。\n以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：\n纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。\n在bytes中，无法显示为ASCII字符的字节，用\\x##显示。\n反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：\n如果bytes中包含无法解码的字节，decode()方法会报错：\n如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：\n要计算str包含多少个字符，可以用len()函数：\nlen()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：\n可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。\n在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。\n由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：\n第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；\n第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。\n申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8编码。\n如果.py文件本身使用UTF-8编码，并且也申明了# -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文：\n最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似'亲爱的xxx你好！你xx月的话费是xx，余额是xx'之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。\n在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：\n你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。\n常见的占位符有：\n其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：\n如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：\n有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：\n另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：\n最后一种格式化字符串的方法是使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换：\n上述代码中，{r}被变量r的值替换，{s:.2f}被变量s的值替换，并且:后面的.2f指定了格式化参数（即保留两位小数），因此，{s:.2f}的替换结果是19.62。\n小明的成绩从去年的72分提升到了今年的85分，请计算小明成绩提升的百分点，并用字符串格式化显示出'xx.x%'，只保留小数点后1位：\nthe_string.py\nPython 3的字符串使用Unicode，直接支持多语言。\n当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：\n但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。\n格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/function/parameter/index.html",
    "title": "函数的参数",
    "content": "定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。\nPython的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。\n我们先写一个计算x2的函数：\n对于power(x)函数，参数x就是一个位置参数。\n当我们调用power函数时，必须传入有且仅有的一个参数x：\n现在，如果我们要计算x3怎么办？可以再定义一个power3函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。\n你也许想到了，可以把power(x)修改为power(x, n)，用来计算xn，说干就干：\n对于这个修改后的power(x, n)函数，可以计算任意n次方：\n修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。\n新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：\nPython的错误信息很明确：调用函数power()缺少了一个位置参数n。\n这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：\n这样，当我们调用power(5)时，相当于调用power(5, 2)：\n而对于n > 2的其他情况，就必须明确地传入n，比如power(5, 3)。\n从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：\n一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；\n二是如何设置默认参数。\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\n举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：\n这样，调用enroll()函数只需要传入两个参数：\n如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。\n我们可以把年龄和城市设为默认参数：\n这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：\n只有与默认参数不符的学生才需要提供额外的信息：\n可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。\n有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。\n也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。\n默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：\n先定义一个函数，传入一个list，添加一个END再返回：\n当你正常调用时，结果似乎不错：\n当你使用默认参数调用时，一开始结果也是对的：\n但是，再次调用add_end()时，结果就不对了：\n很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。\n原因解释如下：\nPython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。\n特别注意\n定义默认参数要牢记一点：默认参数必须指向不变对象！\n要修改上面的例子，我们可以用None这个不变对象来实现：\n现在，无论调用多少次，都不会有问题：\n为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\n我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。\n要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：\n但是调用的时候，需要先组装出一个list或tuple：\n如果利用可变参数，调用函数的方式可以简化成这样：\n所以，我们把函数的参数改为可变参数：\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：\n如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：\n这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：\n函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：\n也可以传入任意个数的关键字参数：\n关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。\n和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n当然，上面复杂的调用可以用简化的写法：\n**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。\n对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。\n仍以person()函数为例，我们希望检查是否有city和job参数：\n但是调用者仍可以传入不受限制的关键字参数：\n如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：\n和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n调用方式如下：\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：\n由于调用时缺少参数名city和job，Python解释器把前两个参数视为位置参数，后两个参数传给*args，但缺少命名关键字参数导致报错。\n命名关键字参数可以有缺省值，从而简化调用：\n由于命名关键字参数city具有默认值，调用时，可不传入city参数：\n使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：\n在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n比如定义一个函数，包含上述若干种参数：\n在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。\n最神奇的是通过一个tuple和dict，你也可以调用上述函数：\n所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n提示\n虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。\n以下函数允许计算两个数的乘积，请稍加改造，变成可接收一个或多个数并计算乘积：\nvar_args.py\nkw_args.py\nPython的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。\n默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！\n要注意定义可变参数和关键字参数的语法：\n*args是可变参数，args接收的是一个tuple；\n**kw是关键字参数，kw接收的是一个dict。\n以及调用函数时如何传入可变参数和关键字参数的语法：\n可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。\n使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。\n命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/advanced/generator/index.html",
    "title": "生成器",
    "content": "通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：\n创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。\n我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？\n如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：\n我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。\n当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：\n所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。\ngenerator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。\n比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：\n1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：\n注意，赋值语句：\n相当于：\n但不必显式写出临时变量t就可以赋值。\n上面的函数可以输出斐波那契数列的前N个数：\n仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。\n也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator函数，只需要把print(b)改为yield b就可以了：\n这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator函数，调用一个generator函数将返回一个generator：\n这里，最难理解的就是generator函数和普通函数的执行流程不一样。普通函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n举个简单的例子，定义一个generator函数，依次返回数字1，3，5：\n调用该generator函数时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：\n可以看到，odd不是普通函数，而是generator函数，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。\n有的童鞋会发现这样调用next()每次都返回1：\n原因在于odd()会创建一个新的generator对象，上述代码实际上创建了3个完全独立的generator，对3个generator分别调用next()当然每个都会返回第一个值。\n正确的写法是创建一个generator对象，然后不断对这一个generator对象调用next()：\n回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。\n同样的，把函数改成generator函数后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：\n但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：\n关于如何捕获错误，后面的错误处理还会详细讲解。\n杨辉三角定义如下：\n把每一行看做一个list，试写一个generator，不断输出下一行的list：\ndo_generator.py\ngenerator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。\n要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。\n请注意区分普通函数和generator函数，普通函数调用直接返回结果：\ngenerator函数的调用实际返回一个generator对象："
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/decorator/index.html",
    "title": "装饰器",
    "content": "由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。\n函数对象有一个__name__属性（注意：是前后各两个下划线），可以拿到函数的名字：\n现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。\n本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：\n观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：\n调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：\n把@log放到now()函数的定义处，相当于执行了语句：\n由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。\nwrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。\n如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：\n这个3层嵌套的decorator用法如下：\n执行结果如下：\n和两层嵌套的decorator相比，3层嵌套的效果是这样的：\n我们来剖析上面的语句，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。\n以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'：\n因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。\n不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：\n或者针对带参数的decorator：\nimport functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。\n请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：\n请编写一个decorator，能在函数调用的前后打印出'begin call'和'end call'的日志。\n再思考一下能否写出一个@log的decorator，使它既支持：\n又支持：\ndecorator.py\n在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。\ndecorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/module/index.html",
    "title": "模块",
    "content": "在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。\n为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。\n使用模块有什么好处？\n最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。\n使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点这里查看Python的所有内置函数。\n你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。\n举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。\n现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：\n引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。\n请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。\n类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：\n文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。\n特别注意\n自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。\nmycompany.web也是一个模块，请指出该模块对应的.py文件。\n模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。\n创建自己的模块时，要注意："
  },
  {
    "url": "https://liaoxuefeng.com/books/python/advanced/list-comprehension/index.html",
    "title": "列表生成式",
    "content": "列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。\n举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：\n但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：\n但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：\n写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。\nfor循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：\n还可以使用两层循环，可以生成全排列：\n三层和三层以上的循环就很少用到了。\n运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：\nfor循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：\n因此，列表生成式也可以使用两个变量来生成list：\n最后把一个list中所有的字符串变成小写：\n使用列表生成式的时候，有些童鞋经常搞不清楚if...else的用法。\n例如，以下代码正常输出偶数：\n但是，我们不能在最后的if加上else：\n这是因为跟在for后面的if是一个筛选条件，不能带else，否则如何筛选？\n另一些童鞋发现把if写在for前面必须加else，否则报错：\n这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else：\n上述for前面的表达式x if x % 2 == 0 else -x才能根据x计算出确定的结果。\n可见，在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else。\n如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法，所以列表生成式会报错：\n使用内建的isinstance函数可以判断一个变量是不是字符串：\n请修改列表生成式，通过添加if语句保证列表生成式能正确地执行：\ndo_list_compr.py\n运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/return-function/index.html",
    "title": "返回函数",
    "content": "高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：\n但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：\n当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：\n调用函数f时，才真正计算求和的结果：\n在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。\n请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：\nf1()和f2()的调用结果互不影响。\n注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。\n另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：\n在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。\n你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：\n全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。\n注意\n返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：\n再看看结果：\n缺点是代码较长，可利用lambda函数缩短代码。\n使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常：\n但是，如果对外层变量赋值，由于Python解释器会把x当作函数fn()的局部变量，它会报错：\n原因是x作为局部变量并没有初始化，直接计算x+1是不行的。但我们其实是想引用inc()函数内部的x，所以需要在fn()函数内部加一个nonlocal x的声明。加上这个声明后，解释器把fn()的x看作外层函数的局部变量，它已经被初始化了，可以正确计算x+1。\n提示\n使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。\n利用闭包返回一个计数器函数，每次调用它返回递增整数：\nreturn_func.py\n一个函数可以返回一个计算结果，也可以返回一个函数。\n返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/partial/index.html",
    "title": "偏函数",
    "content": "Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。\n在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：\nint()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：\n但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：\n假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：\n这样，我们转换二进制就非常方便了：\nfunctools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：\n所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。\n注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：\n最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：\n实际上固定了int()函数的关键字参数base，也就是：\n相当于：\n当传入：\n实际上会把10作为*args的一部分自动加到左边，也就是：\n相当于：\n结果为10。\ndo_partial.py\n当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/advanced/slice/index.html",
    "title": "切片",
    "content": "取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：\n取前3个元素，应该怎么做？\n笨办法：\n之所以是笨办法是因为扩展一下，取前N个元素就没辙了。\n取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：\n对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。\n对应上面的问题，取前3个元素，用一行代码就可以完成切片：\nL[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。\n如果第一个索引是0，还可以省略：\n也可以从索引1开始，取出2个元素出来：\n类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：\n记住倒数第一个元素的索引是-1。\n切片操作十分有用。我们先创建一个0-99的数列：\n可以通过切片轻松取出某一段数列。比如前10个数：\n后10个数：\n前11-20个数：\n前10个数，每两个取一个：\n所有数，每5个取一个：\n甚至什么都不写，只写[:]就可以原样复制一个list：\ntuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：\n字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：\n在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。\n利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法：\ndo_slice.py\n有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/higher-order-function/map-reduce/index.html",
    "title": "map/reduce",
    "content": "Python内建了map()和reduce()函数。\n如果你读过Google的那篇大名鼎鼎的论文“MapReduce: Simplified Data Processing on Large Clusters”，你就能大概明白map/reduce的概念。\n我们先看map。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\n举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：\n现在，我们用Python代码实现：\nmap()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。\n你可能会想，不需要map()函数，写一个循环，也可以计算出结果：\n的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？\n所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：\n只需要一行代码。\n再看reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\n比方说对一个序列求和，就可以用reduce实现：\n当然求和运算可以直接用Python内建函数sum()，没必要动用reduce。\n但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：\n这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：\n整理成一个str2int的函数就是：\n还可以用lambda函数进一步简化成：\n也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！\nlambda函数的用法在后面介绍。\n利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：\nPython提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积：\n利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456：\ndo_map.py\ndo_reduce.py\nmap用于将一个函数作用于一个序列，以此得到另一个序列；\nreduce用于将一个函数依次作用于上次计算的结果和序列的下一个元素，以此得到最终结果。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/advanced/iterator/index.html",
    "title": "迭代器",
    "content": "我们已经知道，可以直接作用于for循环的数据类型有以下几种：\n一类是集合数据类型，如list、tuple、dict、set、str等；\n一类是generator，包括生成器和带yield的generator function。\n这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。\n可以使用isinstance()判断一个对象是否是Iterable对象：\n而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。\n可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。\n可以使用isinstance()判断一个对象是否是Iterator对象：\n生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。\n把list、dict、str等Iterable变成Iterator可以使用iter()函数：\n你可能会问，为什么list、dict、str等数据类型不是Iterator？\n这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。\nIterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。\ndo_iterator.py\n凡是可作用于for循环的对象都是Iterable类型；\n凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；\n集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。\nPython的for循环本质上就是通过不断调用next()函数实现的，例如：\n实际上完全等价于："
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/lambda/index.html",
    "title": "匿名函数",
    "content": "当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。\n在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：\n通过对比可以看出，匿名函数lambda x: x * x实际上就是：\n关键字lambda表示匿名函数，冒号前面的x表示函数参数。\n匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。\n用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：\n同样，也可以把匿名函数作为返回值返回，比如：\n请用匿名函数改造下面的代码：\nPython对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/module/use-module/index.html",
    "title": "使用模块",
    "content": "Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。\n我们以内建的sys模块为例，编写一个hello的模块：\n第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；\n第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；\n第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；\n以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。\n后面开始就是真正的代码部分。\n你可能注意到了，使用sys模块的第一步，就是导入该模块：\n导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。\nsys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：\n运行python3 hello.py获得的sys.argv就是['hello.py']；\n运行python3 hello.py Michael获得的sys.argv就是['hello.py', 'Michael']。\n最后，注意到这两行代码：\n当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n我们可以用命令行运行hello.py看看效果：\n如果启动Python交互环境，再导入hello模块：\n导入时，没有打印Hello, word!，因为没有执行test()函数。\n调用hello.test()时，才能打印出Hello, word!：\n在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。\n正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；\n类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；\n类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；\n之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。\nprivate函数或变量不应该被别人引用，那它们有什么用呢？请看例子：\n我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：\n外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/advanced/iterate/index.html",
    "title": "迭代",
    "content": "如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。\n在Python中，迭代是通过for ... in来完成的，而很多语言比如C语言，迭代list是通过下标完成的，比如C代码：\n可以看出，Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。\nlist这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：\n因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。\n默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。\n由于字符串也是可迭代对象，因此，也可以作用于for循环：\n所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。\n那么，如何判断一个对象是可迭代对象呢？方法是通过collections.abc模块的Iterable类型判断：\n最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：\n上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：\n请使用迭代查找一个list中最小和最大值，并返回一个tuple：\ndo_iter.py\n任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/module/install/index.html",
    "title": "安装第三方模块",
    "content": "在Python中，安装第三方模块，是通过包管理工具pip完成的。\n如果你正在使用Mac或Linux，安装pip本身这个步骤就可以跳过了。\n如果你正在使用Windows，请参考安装Python一节的内容，确保安装时勾选了pip和Add python.exe to Path。\n在命令提示符窗口下尝试运行pip，如果Windows提示未找到命令，可以重新运行安装程序添加pip。\n注意：Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。\n例如，我们要安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。不过，PIL目前只支持到Python 2.7，并且有年头没有更新了，因此，基于PIL的Pillow项目开发非常活跃，并且支持最新的Python 3。\n一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：\n耐心等待下载并安装后，就可以使用Pillow了。\n在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。\n可以从Anaconda官网下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。\n安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：\n可以尝试直接import numpy等已安装的第三方模块。\n当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：\n默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：\n如果我们要添加自己的搜索目录，有两种方法：\n一是直接修改sys.path，添加要搜索的目录：\n这种方法是在运行时修改，运行结束后失效。\n第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加我们自己的搜索路径，Python本身的搜索路径不受影响。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/higher-order-function/sorted/index.html",
    "title": "sorted",
    "content": "排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。\nPython内置的sorted()函数就可以对list进行排序：\n此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：\nkey指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：\n然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：\n我们再看一个字符串排序的例子：\n默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面。\n现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。\n这样，我们给sorted传入key函数，即可实现忽略大小写的排序：\n要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：\n从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。\nsorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。\n假设我们用一组tuple表示学生名字和成绩：\n请用sorted()对上述列表分别按名字排序：\n再按成绩从高到低排序：\ndo_sorted.py"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/higher-order-function/filter/index.html",
    "title": "filter",
    "content": "Python内建的filter()函数用于过滤序列。\n和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\n例如，在一个list中，删掉偶数，只保留奇数，可以这么写：\n把一个序列中的空字符串删掉，可以这么写：\n可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。\n注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。\n计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：\n首先，列出从2开始的所有自然数，构造一个序列：\n2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...\n取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：\n3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...\n取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：\n5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...\n取新序列的第一个数5，然后用5把序列的5的倍数筛掉：\n7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...\n不断筛下去，就可以得到所有的素数。\n用Python来实现这个算法，可以先构造一个从3开始的奇数序列：\n注意这是一个生成器，并且是一个无限序列。\n然后定义一个筛选函数：\n最后，定义一个生成器，不断返回下一个素数：\n这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。\n由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：\n注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。\n回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数：\nfilter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。\ndo_filter.py\nprime_numbers.py"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/higher-order-function/index.html",
    "title": "高阶函数",
    "content": "高阶函数英文叫Higher-order function。什么是高阶函数？我们以实际代码为例子，一步一步深入概念。\n以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：\n但是，如果只写abs呢？\n可见，abs(-10)是函数调用，而abs是函数本身。\n要获得函数调用结果，我们可以把结果赋值给变量：\n但是，如果把函数本身赋值给变量呢？\n结论：函数本身也可以赋值给变量，即：变量可以指向函数。\n如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：\n成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。\n那么函数名是什么呢？函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！\n如果把abs指向其他对象，会有什么情况发生？\n把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！\n当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。\n注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。\n既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n一个最简单的高阶函数：\n当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：\n用代码验证一下：\n编写高阶函数，就是让函数的参数能够接收别的函数。\ndo_f_add.py\n把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/functional/index.html",
    "title": "函数式编程",
    "content": "函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。\n而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。\n我们首先要搞明白计算机（Computer）和计算（Compute）的概念。\n在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。\n而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。\n对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。\n函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/oop/index.html",
    "title": "面向对象编程",
    "content": "面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。\n面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。\n而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。\n在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。\n我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。\n假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：\n而处理学生成绩可以通过函数实现，比如打印学生的成绩：\n如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。\n给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：\n面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。\n所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。\n面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。\n数据封装、继承和多态是面向对象的三大特点，我们后面会详细讲解。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/oop/extend/index.html",
    "title": "继承和多态",
    "content": "在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。\n比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：\n当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：\n对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。\n继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animal实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：\n运行结果如下：\n当然，也可以对子类增加一些方法，比如Dog类：\n继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...，因此，对Dog和Cat类改进如下：\n再次运行，结果如下：\n当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。\n要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：\n判断一个变量是否是某个类型可以用isinstance()判断：\n看来a、b、c确实对应着list、Animal、Dog这3种类型。\n但是等等，试试：\n看来c不仅仅是Dog，c还是Animal！\n不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！\n所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：\nDog可以看成Animal，但Animal不可以看成Dog。\n要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：\n当我们传入Animal的实例时，run_twice()就打印出：\n当我们传入Dog的实例时，run_twice()就打印出：\n当我们传入Cat的实例时，run_twice()就打印出：\n看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：\n当我们调用run_twice()时，传入Tortoise的实例：\n你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。\n多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：\n对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：\n对扩展开放：允许新增Animal子类；\n对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。\n继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：\n对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。\n对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：\n这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。\nPython的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。\n继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。\n动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。\nanimals.py\nget_instance.py"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/oop/props/index.html",
    "title": "实例属性和类属性",
    "content": "由于Python是动态语言，根据类创建的实例可以任意绑定属性。\n给实例绑定属性的方法是通过实例变量，或者通过self变量：\n但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：\n当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：\n从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。\n为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：\n实例属性属于各个实例所有，互不干扰；\n类属性属于类所有，所有实例共享一个属性；\n不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/oop/attr/index.html",
    "title": "获取对象信息",
    "content": "当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？\n首先，我们来判断对象类型，使用type()函数：\n基本类型都可以用type()判断：\n如果一个变量指向函数或者类，也可以用type()判断：\n但是type()函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：\n判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以使用types模块中定义的常量：\n对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。\n我们回顾上次的例子，如果继承关系是：\n那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：\n然后，判断：\n没有问题，因为h变量指向的就是Husky对象。\n再判断：\nh虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型。换句话说，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。\n因此，我们可以确信，h还是Animal类型：\n同理，实际类型是Dog的d也是Animal类型：\n但是，d不是Husky类型：\n能用type()判断的基本类型也可以用isinstance()判断：\n并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：\n提示\n总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。\n如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：\n类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：\n我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：\n剩下的都是普通属性或方法，比如lower()返回小写的字符串：\n仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：\n紧接着，可以测试该对象的属性：\n如果试图获取不存在的属性，会抛出AttributeError的错误：\n可以传入一个default参数，如果属性不存在，就返回默认值：\n也可以获得对象的方法：\n通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：\n就不要写：\n一个正确的用法的例子如下：\n假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。\n请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。\nget_type.py\nattrs.py"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/oop/access/index.html",
    "title": "访问限制",
    "content": "在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。\n但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：\n改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：\n这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。\n但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：\n如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：\n你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：\n需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。\n有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。\n双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：\n但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。\n总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。\n最后注意下面的这种错误写法：\n表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：\n请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性：\nprotected_student.py"
  },
  {
    "url": "https://liaoxuefeng.com/books/python/oop/class/index.html",
    "title": "类和实例",
    "content": "面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\n仍以Student类为例，在Python中，定义类是通过class关键字：\nclass后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。\n定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：\n可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。\n可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：\n由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：\n注意\n特殊方法__init__前后分别有两个下划线！！！\n注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。\n有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：\n和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。\n面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：\n但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：\n要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：\n这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。\n封装的另一个好处是可以给Student类增加新的方法，比如get_grade：\n同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节：\n类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；\n方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；\n通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。\n和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：\nstudent.py"
  }
]